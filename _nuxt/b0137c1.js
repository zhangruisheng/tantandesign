/*! For license information please see LICENSES */
(window.webpackJsonp = window.webpackJsonp || []).push([
    [2], {
        212: function (t, e, r) {
            "use strict";
            var n = r(9),
                o = r(6),
                h = r(83),
                l = r(15),
                c = r(10),
                d = r(42),
                m = r(162),
                f = r(62),
                y = r(5),
                v = r(50),
                x = r(63).f,
                _ = r(30).f,
                M = r(14).f,
                S = r(213).trim,
                w = "Number",
                E = o.Number,
                T = E.prototype,
                A = d(v(T)) == w,
                P = function (t) {
                    var e, r, n, o, h, l, c, code, d = f(t, !1);
                    if ("string" == typeof d && d.length > 2)
                        if (43 === (e = (d = S(d)).charCodeAt(0)) || 45 === e) {
                            if (88 === (r = d.charCodeAt(2)) || 120 === r) return NaN
                        } else if (48 === e) {
                        switch (d.charCodeAt(1)) {
                            case 66:
                            case 98:
                                n = 2, o = 49;
                                break;
                            case 79:
                            case 111:
                                n = 8, o = 55;
                                break;
                            default:
                                return +d
                        }
                        for (l = (h = d.slice(2)).length, c = 0; c < l; c++)
                            if ((code = h.charCodeAt(c)) < 48 || code > o) return NaN;
                        return parseInt(h, n)
                    }
                    return +d
                };
            if (h(w, !E(" 0o1") || !E("0b1") || E("+0x1"))) {
                for (var C, L = function (t) {
                        var e = arguments.length < 1 ? 0 : t,
                            r = this;
                        return r instanceof L && (A ? y((function () {
                            T.valueOf.call(r)
                        })) : d(r) != w) ? m(new E(P(e)), r, L) : P(e)
                    }, D = n ? x(E) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(","), R = 0; D.length > R; R++) c(E, C = D[R]) && !c(L, C) && M(L, C, _(E, C));
                L.prototype = T, T.constructor = L, l(o, w, L)
            }
        },
        213: function (t, e, r) {
            var n = r(18),
                o = "[" + r(214) + "]",
                h = RegExp("^" + o + o + "*"),
                l = RegExp(o + o + "*$"),
                c = function (t) {
                    return function (e) {
                        var r = String(n(e));
                        return 1 & t && (r = r.replace(h, "")), 2 & t && (r = r.replace(l, "")), r
                    }
                };
            t.exports = {
                start: c(1),
                end: c(2),
                trim: c(3)
            }
        },
        214: function (t, e) {
            t.exports = "\t\n\v\f\r                　\u2028\u2029\ufeff"
        },
        242: function (module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_RESULT__, root, factory;
            "undefined" != typeof navigator && (root = window || {}, factory = function (window) {
                "use strict";
                var svgNS = "http://www.w3.org/2000/svg",
                    locationHref = "",
                    initialDefaultFrame = -999999,
                    subframeEnabled = !0,
                    idPrefix = "",
                    expressionsPlugin, isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                    cachedColors = {},
                    bmRnd, bmPow = Math.pow,
                    bmSqrt = Math.sqrt,
                    bmFloor = Math.floor,
                    bmMax = Math.max,
                    bmMin = Math.min,
                    BMMath = {};

                function ProjectInterface() {
                    return {}
                }! function () {
                    var i, t = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"],
                        e = t.length;
                    for (i = 0; i < e; i += 1) BMMath[t[i]] = Math[t[i]]
                }(), BMMath.random = Math.random, BMMath.abs = function (t) {
                    if ("object" == typeof t && t.length) {
                        var i, e = createSizedArray(t.length),
                            r = t.length;
                        for (i = 0; i < r; i += 1) e[i] = Math.abs(t[i]);
                        return e
                    }
                    return Math.abs(t)
                };
                var defaultCurveSegments = 150,
                    degToRads = Math.PI / 180,
                    roundCorner = .5519;

                function roundValues(t) {
                    bmRnd = t ? Math.round : function (t) {
                        return t
                    }
                }

                function styleDiv(element) {
                    element.style.position = "absolute", element.style.top = 0, element.style.left = 0, element.style.display = "block", element.style.transformOrigin = "0 0", element.style.webkitTransformOrigin = "0 0", element.style.backfaceVisibility = "visible", element.style.webkitBackfaceVisibility = "visible", element.style.transformStyle = "preserve-3d", element.style.webkitTransformStyle = "preserve-3d", element.style.mozTransformStyle = "preserve-3d"
                }

                function BMEnterFrameEvent(t, e, r, n) {
                    this.type = t, this.currentTime = e, this.totalTime = r, this.direction = n < 0 ? -1 : 1
                }

                function BMCompleteEvent(t, e) {
                    this.type = t, this.direction = e < 0 ? -1 : 1
                }

                function BMCompleteLoopEvent(t, e, r, n) {
                    this.type = t, this.currentLoop = r, this.totalLoops = e, this.direction = n < 0 ? -1 : 1
                }

                function BMSegmentStartEvent(t, e, r) {
                    this.type = t, this.firstFrame = e, this.totalFrames = r
                }

                function BMDestroyEvent(t, e) {
                    this.type = t, this.target = e
                }

                function BMRenderFrameErrorEvent(t, e) {
                    this.type = "renderFrameError", this.nativeError = t, this.currentTime = e
                }

                function BMConfigErrorEvent(t) {
                    this.type = "configError", this.nativeError = t
                }

                function BMAnimationConfigErrorEvent(t, e) {
                    this.type = t, this.nativeError = e
                }
                roundValues(!1);
                var createElementID = (_count = 0, function () {
                        return idPrefix + "__lottie_element_" + (_count += 1)
                    }),
                    _count;

                function HSVtoRGB(t, s, e) {
                    var r, g, b, i, n, p, q, o;
                    switch (p = e * (1 - s), q = e * (1 - (n = 6 * t - (i = Math.floor(6 * t))) * s), o = e * (1 - (1 - n) * s), i % 6) {
                        case 0:
                            r = e, g = o, b = p;
                            break;
                        case 1:
                            r = q, g = e, b = p;
                            break;
                        case 2:
                            r = p, g = e, b = o;
                            break;
                        case 3:
                            r = p, g = q, b = e;
                            break;
                        case 4:
                            r = o, g = p, b = e;
                            break;
                        case 5:
                            r = e, g = p, b = q
                    }
                    return [r, g, b]
                }

                function RGBtoHSV(t, g, b) {
                    var e, r = Math.max(t, g, b),
                        n = Math.min(t, g, b),
                        o = r - n,
                        s = 0 === r ? 0 : o / r,
                        h = r / 255;
                    switch (r) {
                        case n:
                            e = 0;
                            break;
                        case t:
                            e = g - b + o * (g < b ? 6 : 0), e /= 6 * o;
                            break;
                        case g:
                            e = b - t + 2 * o, e /= 6 * o;
                            break;
                        case b:
                            e = t - g + 4 * o, e /= 6 * o
                    }
                    return [e, s, h]
                }

                function addSaturationToRGB(t, e) {
                    var r = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
                    return r[1] += e, r[1] > 1 ? r[1] = 1 : r[1] <= 0 && (r[1] = 0), HSVtoRGB(r[0], r[1], r[2])
                }

                function addBrightnessToRGB(t, e) {
                    var r = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
                    return r[2] += e, r[2] > 1 ? r[2] = 1 : r[2] < 0 && (r[2] = 0), HSVtoRGB(r[0], r[1], r[2])
                }

                function addHueToRGB(t, e) {
                    var r = RGBtoHSV(255 * t[0], 255 * t[1], 255 * t[2]);
                    return r[0] += e / 360, r[0] > 1 ? r[0] -= 1 : r[0] < 0 && (r[0] += 1), HSVtoRGB(r[0], r[1], r[2])
                }
                var rgbToHex = function () {
                    var i, t, e = [];
                    for (i = 0; i < 256; i += 1) t = i.toString(16), e[i] = 1 === t.length ? "0" + t : t;
                    return function (t, g, b) {
                        return t < 0 && (t = 0), g < 0 && (g = 0), b < 0 && (b = 0), "#" + e[t] + e[g] + e[b]
                    }
                }();

                function BaseEvent() {}
                BaseEvent.prototype = {
                    triggerEvent: function (t, e) {
                        if (this._cbs[t])
                            for (var r = this._cbs[t], i = 0; i < r.length; i += 1) r[i](e)
                    },
                    addEventListener: function (t, e) {
                        return this._cbs[t] || (this._cbs[t] = []), this._cbs[t].push(e),
                            function () {
                                this.removeEventListener(t, e)
                            }.bind(this)
                    },
                    removeEventListener: function (t, e) {
                        if (e) {
                            if (this._cbs[t]) {
                                for (var i = 0, r = this._cbs[t].length; i < r;) this._cbs[t][i] === e && (this._cbs[t].splice(i, 1), i -= 1, r -= 1), i += 1;
                                this._cbs[t].length || (this._cbs[t] = null)
                            }
                        } else this._cbs[t] = null
                    }
                };
                var createTypedArray = function () {
                    function t(t, e) {
                        var r, i = 0,
                            n = [];
                        switch (t) {
                            case "int16":
                            case "uint8c":
                                r = 1;
                                break;
                            default:
                                r = 1.1
                        }
                        for (i = 0; i < e; i += 1) n.push(r);
                        return n
                    }
                    return "function" == typeof Uint8ClampedArray && "function" == typeof Float32Array ? function (e, r) {
                        return "float32" === e ? new Float32Array(r) : "int16" === e ? new Int16Array(r) : "uint8c" === e ? new Uint8ClampedArray(r) : t(e, r)
                    } : t
                }();

                function createSizedArray(t) {
                    return Array.apply(null, {
                        length: t
                    })
                }

                function createNS(t) {
                    return document.createElementNS(svgNS, t)
                }

                function createTag(t) {
                    return document.createElement(t)
                }

                function DynamicPropertyContainer() {}
                DynamicPropertyContainer.prototype = {
                    addDynamicProperty: function (t) {
                        -1 === this.dynamicProperties.indexOf(t) && (this.dynamicProperties.push(t), this.container.addDynamicProperty(this), this._isAnimated = !0)
                    },
                    iterateDynamicProperties: function () {
                        var i;
                        this._mdf = !1;
                        var t = this.dynamicProperties.length;
                        for (i = 0; i < t; i += 1) this.dynamicProperties[i].getValue(), this.dynamicProperties[i]._mdf && (this._mdf = !0)
                    },
                    initDynamicPropertyContainer: function (t) {
                        this.container = t, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1
                    }
                };
                var getBlendMode = (blendModeEnums = {
                        0: "source-over",
                        1: "multiply",
                        2: "screen",
                        3: "overlay",
                        4: "darken",
                        5: "lighten",
                        6: "color-dodge",
                        7: "color-burn",
                        8: "hard-light",
                        9: "soft-light",
                        10: "difference",
                        11: "exclusion",
                        12: "hue",
                        13: "saturation",
                        14: "color",
                        15: "luminosity"
                    }, function (t) {
                        return blendModeEnums[t] || ""
                    }),
                    blendModeEnums, lineCapEnum = {
                        1: "butt",
                        2: "round",
                        3: "square"
                    },
                    lineJoinEnum = {
                        1: "miter",
                        2: "round",
                        3: "bevel"
                    },
                    Matrix = function () {
                        var t = Math.cos,
                            e = Math.sin,
                            r = Math.tan,
                            n = Math.round;

                        function o() {
                            return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this
                        }

                        function h(r) {
                            if (0 === r) return this;
                            var n = t(r),
                                o = e(r);
                            return this._t(n, -o, 0, 0, o, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                        }

                        function l(r) {
                            if (0 === r) return this;
                            var n = t(r),
                                o = e(r);
                            return this._t(1, 0, 0, 0, 0, n, -o, 0, 0, o, n, 0, 0, 0, 0, 1)
                        }

                        function c(r) {
                            if (0 === r) return this;
                            var n = t(r),
                                o = e(r);
                            return this._t(n, 0, o, 0, 0, 1, 0, 0, -o, 0, n, 0, 0, 0, 0, 1)
                        }

                        function d(r) {
                            if (0 === r) return this;
                            var n = t(r),
                                o = e(r);
                            return this._t(n, -o, 0, 0, o, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                        }

                        function m(t, e) {
                            return this._t(1, e, t, 1, 0, 0)
                        }

                        function f(t, e) {
                            return this.shear(r(t), r(e))
                        }

                        function y(n, o) {
                            var h = t(o),
                                l = e(o);
                            return this._t(h, l, 0, 0, -l, h, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, r(n), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(h, -l, 0, 0, l, h, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                        }

                        function v(t, e, r) {
                            return r || 0 === r || (r = 1), 1 === t && 1 === e && 1 === r ? this : this._t(t, 0, 0, 0, 0, e, 0, 0, 0, 0, r, 0, 0, 0, 0, 1)
                        }

                        function x(a, b, t, e, r, n, g, o, i, h, l, c, d, m, f, p) {
                            return this.props[0] = a, this.props[1] = b, this.props[2] = t, this.props[3] = e, this.props[4] = r, this.props[5] = n, this.props[6] = g, this.props[7] = o, this.props[8] = i, this.props[9] = h, this.props[10] = l, this.props[11] = c, this.props[12] = d, this.props[13] = m, this.props[14] = f, this.props[15] = p, this
                        }

                        function _(t, e, r) {
                            return r = r || 0, 0 !== t || 0 !== e || 0 !== r ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, t, e, r, 1) : this
                        }

                        function M(t, e, r, n, o, h, l, h2, c, d, m, f, y, v, x, _) {
                            var M = this.props;
                            if (1 === t && 0 === e && 0 === r && 0 === n && 0 === o && 1 === h && 0 === l && 0 === h2 && 0 === c && 0 === d && 1 === m && 0 === f) return M[12] = M[12] * t + M[15] * y, M[13] = M[13] * h + M[15] * v, M[14] = M[14] * m + M[15] * x, M[15] *= _, this._identityCalculated = !1, this;
                            var S = M[0],
                                w = M[1],
                                E = M[2],
                                T = M[3],
                                A = M[4],
                                P = M[5],
                                C = M[6],
                                h1 = M[7],
                                L = M[8],
                                D = M[9],
                                R = M[10],
                                I = M[11],
                                F = M[12],
                                k = M[13],
                                N = M[14],
                                B = M[15];
                            return M[0] = S * t + w * o + E * c + T * y, M[1] = S * e + w * h + E * d + T * v, M[2] = S * r + w * l + E * m + T * x, M[3] = S * n + w * h2 + E * f + T * _, M[4] = A * t + P * o + C * c + h1 * y, M[5] = A * e + P * h + C * d + h1 * v, M[6] = A * r + P * l + C * m + h1 * x, M[7] = A * n + P * h2 + C * f + h1 * _, M[8] = L * t + D * o + R * c + I * y, M[9] = L * e + D * h + R * d + I * v, M[10] = L * r + D * l + R * m + I * x, M[11] = L * n + D * h2 + R * f + I * _, M[12] = F * t + k * o + N * c + B * y, M[13] = F * e + k * h + N * d + B * v, M[14] = F * r + k * l + N * m + B * x, M[15] = F * n + k * h2 + N * f + B * _, this._identityCalculated = !1, this
                        }

                        function S() {
                            return this._identityCalculated || (this._identity = !(1 !== this.props[0] || 0 !== this.props[1] || 0 !== this.props[2] || 0 !== this.props[3] || 0 !== this.props[4] || 1 !== this.props[5] || 0 !== this.props[6] || 0 !== this.props[7] || 0 !== this.props[8] || 0 !== this.props[9] || 1 !== this.props[10] || 0 !== this.props[11] || 0 !== this.props[12] || 0 !== this.props[13] || 0 !== this.props[14] || 1 !== this.props[15]), this._identityCalculated = !0), this._identity
                        }

                        function w(t) {
                            for (var i = 0; i < 16;) {
                                if (t.props[i] !== this.props[i]) return !1;
                                i += 1
                            }
                            return !0
                        }

                        function E(t) {
                            var i;
                            for (i = 0; i < 16; i += 1) t.props[i] = this.props[i];
                            return t
                        }

                        function T(t) {
                            var i;
                            for (i = 0; i < 16; i += 1) this.props[i] = t[i]
                        }

                        function A(t, e, r) {
                            return {
                                x: t * this.props[0] + e * this.props[4] + r * this.props[8] + this.props[12],
                                y: t * this.props[1] + e * this.props[5] + r * this.props[9] + this.props[13],
                                z: t * this.props[2] + e * this.props[6] + r * this.props[10] + this.props[14]
                            }
                        }

                        function P(t, e, r) {
                            return t * this.props[0] + e * this.props[4] + r * this.props[8] + this.props[12]
                        }

                        function C(t, e, r) {
                            return t * this.props[1] + e * this.props[5] + r * this.props[9] + this.props[13]
                        }

                        function L(t, e, r) {
                            return t * this.props[2] + e * this.props[6] + r * this.props[10] + this.props[14]
                        }

                        function D() {
                            var t = this.props[0] * this.props[5] - this.props[1] * this.props[4],
                                a = this.props[5] / t,
                                b = -this.props[1] / t,
                                e = -this.props[4] / t,
                                r = this.props[0] / t,
                                n = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / t,
                                o = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / t,
                                h = new Matrix;
                            return h.props[0] = a, h.props[1] = b, h.props[4] = e, h.props[5] = r, h.props[12] = n, h.props[13] = o, h
                        }

                        function R(t) {
                            return this.getInverseMatrix().applyToPointArray(t[0], t[1], t[2] || 0)
                        }

                        function I(t) {
                            var i, e = t.length,
                                r = [];
                            for (i = 0; i < e; i += 1) r[i] = R(t[i]);
                            return r
                        }

                        function F(t, e, r) {
                            var n = createTypedArray("float32", 6);
                            if (this.isIdentity()) n[0] = t[0], n[1] = t[1], n[2] = e[0], n[3] = e[1], n[4] = r[0], n[5] = r[1];
                            else {
                                var o = this.props[0],
                                    h = this.props[1],
                                    l = this.props[4],
                                    c = this.props[5],
                                    d = this.props[12],
                                    m = this.props[13];
                                n[0] = t[0] * o + t[1] * l + d, n[1] = t[0] * h + t[1] * c + m, n[2] = e[0] * o + e[1] * l + d, n[3] = e[0] * h + e[1] * c + m, n[4] = r[0] * o + r[1] * l + d, n[5] = r[0] * h + r[1] * c + m
                            }
                            return n
                        }

                        function k(t, e, r) {
                            return this.isIdentity() ? [t, e, r] : [t * this.props[0] + e * this.props[4] + r * this.props[8] + this.props[12], t * this.props[1] + e * this.props[5] + r * this.props[9] + this.props[13], t * this.props[2] + e * this.props[6] + r * this.props[10] + this.props[14]]
                        }

                        function N(t, e) {
                            if (this.isIdentity()) return t + "," + e;
                            var r = this.props;
                            return Math.round(100 * (t * r[0] + e * r[4] + r[12])) / 100 + "," + Math.round(100 * (t * r[1] + e * r[5] + r[13])) / 100
                        }

                        function B() {
                            for (var i = 0, t = this.props, e = "matrix3d("; i < 16;) e += n(1e4 * t[i]) / 1e4, e += 15 === i ? ")" : ",", i += 1;
                            return e
                        }

                        function z(t) {
                            return t < 1e-6 && t > 0 || t > -1e-6 && t < 0 ? n(1e4 * t) / 1e4 : t
                        }

                        function V() {
                            var t = this.props;
                            return "matrix(" + z(t[0]) + "," + z(t[1]) + "," + z(t[4]) + "," + z(t[5]) + "," + z(t[12]) + "," + z(t[13]) + ")"
                        }
                        return function () {
                            this.reset = o, this.rotate = h, this.rotateX = l, this.rotateY = c, this.rotateZ = d, this.skew = f, this.skewFromAxis = y, this.shear = m, this.scale = v, this.setTransform = x, this.translate = _, this.transform = M, this.applyToPoint = A, this.applyToX = P, this.applyToY = C, this.applyToZ = L, this.applyToPointArray = k, this.applyToTriplePoints = F, this.applyToPointStringified = N, this.toCSS = B, this.to2dCSS = V, this.clone = E, this.cloneFromProps = T, this.equals = w, this.inversePoints = I, this.inversePoint = R, this.getInverseMatrix = D, this._t = this.transform, this.isIdentity = S, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset()
                        }
                    }();
                ! function (t, e) {
                    var r = this,
                        n = 256,
                        o = e.pow(n, 6),
                        h = e.pow(2, 52),
                        l = 2 * h,
                        mask = 255;

                    function c(t) {
                        var e, r = t.length,
                            o = this,
                            i = 0,
                            h = o.i = o.j = 0,
                            s = o.S = [];
                        for (r || (t = [r++]); i < n;) s[i] = i++;
                        for (i = 0; i < n; i++) s[i] = s[h = mask & h + t[i % r] + (e = s[i])], s[h] = e;
                        o.g = function (t) {
                            for (var e, r = 0, i = o.i, h = o.j, s = o.S; t--;) e = s[i = mask & i + 1], r = r * n + s[mask & (s[i] = s[h = mask & h + e]) + (s[h] = e)];
                            return o.i = i, o.j = h, r
                        }
                    }

                    function d(t, e) {
                        return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e
                    }

                    function m(t, e) {
                        var r, n = [],
                            o = typeof t;
                        if (e && "object" == o)
                            for (r in t) try {
                                n.push(m(t[r], e - 1))
                            } catch (t) {}
                        return n.length ? n : "string" == o ? t : t + "\0"
                    }

                    function f(t, e) {
                        for (var r, n = t + "", o = 0; o < n.length;) e[mask & o] = mask & (r ^= 19 * e[mask & o]) + n.charCodeAt(o++);
                        return y(e)
                    }

                    function y(a) {
                        return String.fromCharCode.apply(0, a)
                    }
                    e.seedrandom = function (v, x, _) {
                        var M = [],
                            S = f(m((x = !0 === x ? {
                                entropy: !0
                            } : x || {}).entropy ? [v, y(t)] : null === v ? function () {
                                try {
                                    var e = new Uint8Array(n);
                                    return (r.crypto || r.msCrypto).getRandomValues(e), y(e)
                                } catch (e) {
                                    var o = r.navigator,
                                        h = o && o.plugins;
                                    return [+new Date, r, h, r.screen, y(t)]
                                }
                            }() : v, 3), M),
                            w = new c(M),
                            E = function () {
                                for (var t = w.g(6), e = o, r = 0; t < h;) t = (t + r) * n, e *= n, r = w.g(1);
                                for (; t >= l;) t /= 2, e /= 2, r >>>= 1;
                                return (t + r) / e
                            };
                        return E.int32 = function () {
                            return 0 | w.g(4)
                        }, E.quick = function () {
                            return w.g(4) / 4294967296
                        }, E.double = E, f(y(w.S), t), (x.pass || _ || function (t, r, n, o) {
                            return o && (o.S && d(o, w), t.state = function () {
                                return d(w, {})
                            }), n ? (e.random = t, r) : t
                        })(E, S, "global" in x ? x.global : this == e, x.state)
                    }, f(e.random(), t)
                }([], BMMath);
                var BezierFactory = function () {
                    var t = {
                            getBezierEasing: function (a, b, t, r, n) {
                                var o = n || ("bez_" + a + "_" + b + "_" + t + "_" + r).replace(/\./g, "p");
                                if (e[o]) return e[o];
                                var h = new m([a, b, t, r]);
                                return e[o] = h, h
                            }
                        },
                        e = {},
                        r = .1,
                        n = "function" == typeof Float32Array;

                    function o(t, e) {
                        return 1 - 3 * e + 3 * t
                    }

                    function h(t, e) {
                        return 3 * e - 6 * t
                    }

                    function l(t) {
                        return 3 * t
                    }

                    function c(t, e, r) {
                        return ((o(e, r) * t + h(e, r)) * t + l(e)) * t
                    }

                    function d(t, e, r) {
                        return 3 * o(e, r) * t * t + 2 * h(e, r) * t + l(e)
                    }

                    function m(t) {
                        this._p = t, this._mSampleValues = n ? new Float32Array(11) : new Array(11), this._precomputed = !1, this.get = this.get.bind(this)
                    }
                    return m.prototype = {
                        get: function (t) {
                            var e = this._p[0],
                                r = this._p[1],
                                n = this._p[2],
                                o = this._p[3];
                            return this._precomputed || this._precompute(), e === r && n === o ? t : 0 === t ? 0 : 1 === t ? 1 : c(this._getTForX(t), r, o)
                        },
                        _precompute: function () {
                            var t = this._p[0],
                                e = this._p[1],
                                r = this._p[2],
                                n = this._p[3];
                            this._precomputed = !0, t === e && r === n || this._calcSampleValues()
                        },
                        _calcSampleValues: function () {
                            for (var t = this._p[0], e = this._p[2], i = 0; i < 11; ++i) this._mSampleValues[i] = c(i * r, t, e)
                        },
                        _getTForX: function (t) {
                            for (var e = this._p[0], n = this._p[2], o = this._mSampleValues, h = 0, l = 1; 10 !== l && o[l] <= t; ++l) h += r;
                            var m = h + (t - o[--l]) / (o[l + 1] - o[l]) * r,
                                f = d(m, e, n);
                            return f >= .001 ? function (t, e, r, n) {
                                for (var i = 0; i < 4; ++i) {
                                    var o = d(e, r, n);
                                    if (0 === o) return e;
                                    e -= (c(e, r, n) - t) / o
                                }
                                return e
                            }(t, m, e, n) : 0 === f ? m : function (t, e, r, n, o) {
                                var h, l, i = 0;
                                do {
                                    (h = c(l = e + (r - e) / 2, n, o) - t) > 0 ? r = l : e = l
                                } while (Math.abs(h) > 1e-7 && ++i < 10);
                                return l
                            }(t, h, h + r, e, n)
                        }
                    }, t
                }();

                function extendPrototype(t, e) {
                    var i, r, n = t.length;
                    for (i = 0; i < n; i += 1)
                        for (var o in r = t[i].prototype) Object.prototype.hasOwnProperty.call(r, o) && (e.prototype[o] = r[o])
                }

                function getDescriptor(object, t) {
                    return Object.getOwnPropertyDescriptor(object, t)
                }

                function createProxyFunction(t) {
                    function e() {}
                    return e.prototype = t, e
                }

                function bezFunction() {
                    var t = Math;

                    function e(t, e, r, n, o, h) {
                        var l = t * n + e * o + r * h - o * n - h * t - r * e;
                        return l > -.001 && l < .001
                    }
                    var r = function (t, e, r, n) {
                        var o, i, h, l, c, d, m = defaultCurveSegments,
                            f = 0,
                            y = [],
                            v = [],
                            x = bezierLengthPool.newElement();
                        for (h = r.length, o = 0; o < m; o += 1) {
                            for (c = o / (m - 1), d = 0, i = 0; i < h; i += 1) l = bmPow(1 - c, 3) * t[i] + 3 * bmPow(1 - c, 2) * c * r[i] + 3 * (1 - c) * bmPow(c, 2) * n[i] + bmPow(c, 3) * e[i], y[i] = l, null !== v[i] && (d += bmPow(y[i] - v[i], 2)), v[i] = y[i];
                            d && (f += d = bmSqrt(d)), x.percents[o] = c, x.lengths[o] = f
                        }
                        return x.addedLength = f, x
                    };

                    function n(t) {
                        this.segmentLength = 0, this.points = new Array(t)
                    }

                    function o(t, e) {
                        this.partialLength = t, this.point = e
                    }
                    var h, l = (h = {}, function (t, r, l, c) {
                        var d = (t[0] + "_" + t[1] + "_" + r[0] + "_" + r[1] + "_" + l[0] + "_" + l[1] + "_" + c[0] + "_" + c[1]).replace(/\./g, "p");
                        if (!h[d]) {
                            var m, i, f, y, v, x, _, M = defaultCurveSegments,
                                S = 0,
                                w = null;
                            2 === t.length && (t[0] !== r[0] || t[1] !== r[1]) && e(t[0], t[1], r[0], r[1], t[0] + l[0], t[1] + l[1]) && e(t[0], t[1], r[0], r[1], r[0] + c[0], r[1] + c[1]) && (M = 2);
                            var E = new n(M);
                            for (f = l.length, m = 0; m < M; m += 1) {
                                for (_ = createSizedArray(f), v = m / (M - 1), x = 0, i = 0; i < f; i += 1) y = bmPow(1 - v, 3) * t[i] + 3 * bmPow(1 - v, 2) * v * (t[i] + l[i]) + 3 * (1 - v) * bmPow(v, 2) * (r[i] + c[i]) + bmPow(v, 3) * r[i], _[i] = y, null !== w && (x += bmPow(_[i] - w[i], 2));
                                S += x = bmSqrt(x), E.points[m] = new o(x, _), w = _
                            }
                            E.segmentLength = S, h[d] = E
                        }
                        return h[d]
                    });

                    function c(t, e) {
                        var r = e.percents,
                            n = e.lengths,
                            o = r.length,
                            h = bmFloor((o - 1) * t),
                            l = t * e.addedLength,
                            c = 0;
                        if (h === o - 1 || 0 === h || l === n[h]) return r[h];
                        for (var d = n[h] > l ? -1 : 1, m = !0; m;)
                            if (n[h] <= l && n[h + 1] > l ? (c = (l - n[h]) / (n[h + 1] - n[h]), m = !1) : h += d, h < 0 || h >= o - 1) {
                                if (h === o - 1) return r[h];
                                m = !1
                            } return r[h] + (r[h + 1] - r[h]) * c
                    }
                    var d = createTypedArray("float32", 8);
                    return {
                        getSegmentsLength: function (t) {
                            var i, e = segmentsLengthPool.newElement(),
                                n = t.c,
                                o = t.v,
                                h = t.o,
                                l = t.i,
                                c = t._length,
                                d = e.lengths,
                                m = 0;
                            for (i = 0; i < c - 1; i += 1) d[i] = r(o[i], o[i + 1], h[i], l[i + 1]), m += d[i].addedLength;
                            return n && c && (d[i] = r(o[i], o[0], h[i], l[0]), m += d[i].addedLength), e.totalLength = m, e
                        },
                        getNewSegment: function (e, r, n, o, h, l, m) {
                            h < 0 ? h = 0 : h > 1 && (h = 1);
                            var i, f = c(h, m),
                                y = c(l = l > 1 ? 1 : l, m),
                                v = e.length,
                                x = 1 - f,
                                _ = 1 - y,
                                M = x * x * x,
                                S = f * x * x * 3,
                                w = f * f * x * 3,
                                E = f * f * f,
                                T = x * x * _,
                                A = f * x * _ + x * f * _ + x * x * y,
                                P = f * f * _ + x * f * y + f * x * y,
                                C = f * f * y,
                                L = x * _ * _,
                                D = f * _ * _ + x * y * _ + x * _ * y,
                                R = f * y * _ + x * y * y + f * _ * y,
                                I = f * y * y,
                                F = _ * _ * _,
                                k = y * _ * _ + _ * y * _ + _ * _ * y,
                                N = y * y * _ + _ * y * y + y * _ * y,
                                B = y * y * y;
                            for (i = 0; i < v; i += 1) d[4 * i] = t.round(1e3 * (M * e[i] + S * n[i] + w * o[i] + E * r[i])) / 1e3, d[4 * i + 1] = t.round(1e3 * (T * e[i] + A * n[i] + P * o[i] + C * r[i])) / 1e3, d[4 * i + 2] = t.round(1e3 * (L * e[i] + D * n[i] + R * o[i] + I * r[i])) / 1e3, d[4 * i + 3] = t.round(1e3 * (F * e[i] + k * n[i] + N * o[i] + B * r[i])) / 1e3;
                            return d
                        },
                        getPointInSegment: function (e, r, n, o, h, l) {
                            var d = c(h, l),
                                m = 1 - d;
                            return [t.round(1e3 * (m * m * m * e[0] + (d * m * m + m * d * m + m * m * d) * n[0] + (d * d * m + m * d * d + d * m * d) * o[0] + d * d * d * r[0])) / 1e3, t.round(1e3 * (m * m * m * e[1] + (d * m * m + m * d * m + m * m * d) * n[1] + (d * d * m + m * d * d + d * m * d) * o[1] + d * d * d * r[1])) / 1e3]
                        },
                        buildBezierData: l,
                        pointOnLine2D: e,
                        pointOnLine3D: function (r, n, o, h, l, c, d, m, f) {
                            if (0 === o && 0 === c && 0 === f) return e(r, n, h, l, d, m);
                            var y, v = t.sqrt(t.pow(h - r, 2) + t.pow(l - n, 2) + t.pow(c - o, 2)),
                                x = t.sqrt(t.pow(d - r, 2) + t.pow(m - n, 2) + t.pow(f - o, 2)),
                                _ = t.sqrt(t.pow(d - h, 2) + t.pow(m - l, 2) + t.pow(f - c, 2));
                            return (y = v > x ? v > _ ? v - x - _ : _ - x - v : _ > x ? _ - x - v : x - v - _) > -1e-4 && y < 1e-4
                        }
                    }
                }! function () {
                    for (var t = 0, e = ["ms", "moz", "webkit", "o"], r = 0; r < e.length && !window.requestAnimationFrame; ++r) window.requestAnimationFrame = window[e[r] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[e[r] + "CancelAnimationFrame"] || window[e[r] + "CancelRequestAnimationFrame"];
                    window.requestAnimationFrame || (window.requestAnimationFrame = function (e) {
                        var r = (new Date).getTime(),
                            n = Math.max(0, 16 - (r - t)),
                            o = setTimeout((function () {
                                e(r + n)
                            }), n);
                        return t = r + n, o
                    }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function (t) {
                        clearTimeout(t)
                    })
                }();
                var bez = bezFunction();

                function dataFunctionManager() {
                    function t(o, h, l) {
                        var c, i, d, m, f, y, data, v = o.length;
                        for (i = 0; i < v; i += 1)
                            if ("ks" in (c = o[i]) && !c.completed) {
                                if (c.completed = !0, c.tt && (o[i - 1].td = c.tt), c.hasMask) {
                                    var x = c.masksProperties;
                                    for (m = x.length, d = 0; d < m; d += 1)
                                        if (x[d].pt.k.i) n(x[d].pt.k);
                                        else
                                            for (y = x[d].pt.k.length, f = 0; f < y; f += 1) x[d].pt.k[f].s && n(x[d].pt.k[f].s[0]), x[d].pt.k[f].e && n(x[d].pt.k[f].e[0])
                                }
                                0 === c.ty ? (c.layers = e(c.refId, h), t(c.layers, h, l)) : 4 === c.ty ? r(c.shapes) : 5 === c.ty && (0 !== (data = c).t.a.length || "m" in data.t.p || (data.singleShape = !0))
                            }
                    }

                    function e(t, e) {
                        for (var i = 0, r = e.length; i < r;) {
                            if (e[i].id === t) return e[i].layers.__used ? JSON.parse(JSON.stringify(e[i].layers)) : (e[i].layers.__used = !0, e[i].layers);
                            i += 1
                        }
                        return null
                    }

                    function r(t) {
                        var i, e, o;
                        for (i = t.length - 1; i >= 0; i -= 1)
                            if ("sh" === t[i].ty)
                                if (t[i].ks.k.i) n(t[i].ks.k);
                                else
                                    for (o = t[i].ks.k.length, e = 0; e < o; e += 1) t[i].ks.k[e].s && n(t[i].ks.k[e].s[0]), t[i].ks.k[e].e && n(t[i].ks.k[e].e[0]);
                        else "gr" === t[i].ty && r(t[i].it)
                    }

                    function n(path) {
                        var i, t = path.i.length;
                        for (i = 0; i < t; i += 1) path.i[i][0] += path.v[i][0], path.i[i][1] += path.v[i][1], path.o[i][0] += path.v[i][0], path.o[i][1] += path.v[i][1]
                    }

                    function o(t, e) {
                        var r = e ? e.split(".") : [100, 100, 100];
                        return t[0] > r[0] || !(r[0] > t[0]) && (t[1] > r[1] || !(r[1] > t[1]) && (t[2] > r[2] || !(r[2] > t[2]) && null))
                    }
                    var h, l = function () {
                            var t = [4, 4, 14];

                            function e(t) {
                                var i, e, r, n = t.length;
                                for (i = 0; i < n; i += 1) 5 === t[i].ty && (e = t[i], r = void 0, r = e.t.d, e.t.d = {
                                    k: [{
                                        s: r,
                                        t: 0
                                    }]
                                })
                            }
                            return function (r) {
                                if (o(t, r.v) && (e(r.layers), r.assets)) {
                                    var i, n = r.assets.length;
                                    for (i = 0; i < n; i += 1) r.assets[i].layers && e(r.assets[i].layers)
                                }
                            }
                        }(),
                        c = (h = [4, 7, 99], function (t) {
                            if (t.chars && !o(h, t.v)) {
                                var i, e, r, l, c, d = t.chars.length;
                                for (i = 0; i < d; i += 1)
                                    if (t.chars[i].data && t.chars[i].data.shapes)
                                        for (r = (c = t.chars[i].data.shapes[0].it).length, e = 0; e < r; e += 1)(l = c[e].ks.k).__converted || (n(c[e].ks.k), l.__converted = !0)
                            }
                        }),
                        d = function () {
                            var t = [4, 1, 9];

                            function e(t) {
                                var i, r, n, o = t.length;
                                for (i = 0; i < o; i += 1)
                                    if ("gr" === t[i].ty) e(t[i].it);
                                    else if ("fl" === t[i].ty || "st" === t[i].ty)
                                    if (t[i].c.k && t[i].c.k[0].i)
                                        for (n = t[i].c.k.length, r = 0; r < n; r += 1) t[i].c.k[r].s && (t[i].c.k[r].s[0] /= 255, t[i].c.k[r].s[1] /= 255, t[i].c.k[r].s[2] /= 255, t[i].c.k[r].s[3] /= 255), t[i].c.k[r].e && (t[i].c.k[r].e[0] /= 255, t[i].c.k[r].e[1] /= 255, t[i].c.k[r].e[2] /= 255, t[i].c.k[r].e[3] /= 255);
                                    else t[i].c.k[0] /= 255, t[i].c.k[1] /= 255, t[i].c.k[2] /= 255, t[i].c.k[3] /= 255
                            }

                            function r(t) {
                                var i, r = t.length;
                                for (i = 0; i < r; i += 1) 4 === t[i].ty && e(t[i].shapes)
                            }
                            return function (e) {
                                if (o(t, e.v) && (r(e.layers), e.assets)) {
                                    var i, n = e.assets.length;
                                    for (i = 0; i < n; i += 1) e.assets[i].layers && r(e.assets[i].layers)
                                }
                            }
                        }(),
                        m = function () {
                            var t = [4, 4, 18];

                            function e(t) {
                                var i, r, n;
                                for (i = t.length - 1; i >= 0; i -= 1)
                                    if ("sh" === t[i].ty)
                                        if (t[i].ks.k.i) t[i].ks.k.c = t[i].closed;
                                        else
                                            for (n = t[i].ks.k.length, r = 0; r < n; r += 1) t[i].ks.k[r].s && (t[i].ks.k[r].s[0].c = t[i].closed), t[i].ks.k[r].e && (t[i].ks.k[r].e[0].c = t[i].closed);
                                else "gr" === t[i].ty && e(t[i].it)
                            }

                            function r(t) {
                                var r, i, n, o, h, l, c = t.length;
                                for (i = 0; i < c; i += 1) {
                                    if ((r = t[i]).hasMask) {
                                        var d = r.masksProperties;
                                        for (o = d.length, n = 0; n < o; n += 1)
                                            if (d[n].pt.k.i) d[n].pt.k.c = d[n].cl;
                                            else
                                                for (l = d[n].pt.k.length, h = 0; h < l; h += 1) d[n].pt.k[h].s && (d[n].pt.k[h].s[0].c = d[n].cl), d[n].pt.k[h].e && (d[n].pt.k[h].e[0].c = d[n].cl)
                                    }
                                    4 === r.ty && e(r.shapes)
                                }
                            }
                            return function (e) {
                                if (o(t, e.v) && (r(e.layers), e.assets)) {
                                    var i, n = e.assets.length;
                                    for (i = 0; i < n; i += 1) e.assets[i].layers && r(e.assets[i].layers)
                                }
                            }
                        }();
                    var f = {
                        completeData: function (e, r) {
                            e.__complete || (d(e), l(e), c(e), m(e), t(e.layers, e.assets, r), e.__complete = !0)
                        }
                    };
                    return f.checkColors = d, f.checkChars = c, f.checkShapes = m, f.completeLayers = t, f
                }
                var dataManager = dataFunctionManager();

                function getFontProperties(t) {
                    for (var e = t.fStyle ? t.fStyle.split(" ") : [], r = "normal", n = "normal", o = e.length, i = 0; i < o; i += 1) switch (e[i].toLowerCase()) {
                        case "italic":
                            n = "italic";
                            break;
                        case "bold":
                            r = "700";
                            break;
                        case "black":
                            r = "900";
                            break;
                        case "medium":
                            r = "500";
                            break;
                        case "regular":
                        case "normal":
                            r = "400";
                            break;
                        case "light":
                        case "thin":
                            r = "200"
                    }
                    return {
                        style: n,
                        weight: t.fWeight || r
                    }
                }
                var FontManager = function () {
                        var t = {
                                w: 0,
                                size: 0,
                                shapes: []
                            },
                            e = [];
                        e = e.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
                        var r = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"],
                            n = [65039, 8205];

                        function o(t, e) {
                            var r = createTag("span");
                            r.setAttribute("aria-hidden", !0), r.style.fontFamily = e;
                            var n = createTag("span");
                            n.innerText = "giItT1WQy@!-/#", r.style.position = "absolute", r.style.left = "-10000px", r.style.top = "-10000px", r.style.fontSize = "300px", r.style.fontVariant = "normal", r.style.fontStyle = "normal", r.style.fontWeight = "normal", r.style.letterSpacing = "0", r.appendChild(n), document.body.appendChild(r);
                            var o = n.offsetWidth;
                            return n.style.fontFamily = function (t) {
                                var i, e = t.split(","),
                                    r = e.length,
                                    n = [];
                                for (i = 0; i < r; i += 1) "sans-serif" !== e[i] && "monospace" !== e[i] && n.push(e[i]);
                                return n.join(",")
                            }(t) + ", " + e, {
                                node: n,
                                w: o,
                                parent: r
                            }
                        }

                        function h(t, e) {
                            var r = createNS("text");
                            r.style.fontSize = "100px";
                            var n = getFontProperties(e);
                            return r.setAttribute("font-family", e.fFamily), r.setAttribute("font-style", n.style), r.setAttribute("font-weight", n.weight), r.textContent = "1", e.fClass ? (r.style.fontFamily = "inherit", r.setAttribute("class", e.fClass)) : r.style.fontFamily = e.fFamily, t.appendChild(r), createTag("canvas").getContext("2d").font = e.fWeight + " " + e.fStyle + " 100px " + e.fFamily, r
                        }
                        var l = function () {
                            this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)
                        };
                        return l.isModifier = function (t, e) {
                            var n = t.toString(16) + e.toString(16);
                            return -1 !== r.indexOf(n)
                        }, l.isZeroWidthJoiner = function (t, e) {
                            return e ? t === n[0] && e === n[1] : t === n[1]
                        }, l.isCombinedCharacter = function (t) {
                            return -1 !== e.indexOf(t)
                        }, l.prototype = {
                            addChars: function (t) {
                                if (t) {
                                    var i;
                                    this.chars || (this.chars = []);
                                    var e, r, n = t.length,
                                        o = this.chars.length;
                                    for (i = 0; i < n; i += 1) {
                                        for (e = 0, r = !1; e < o;) this.chars[e].style === t[i].style && this.chars[e].fFamily === t[i].fFamily && this.chars[e].ch === t[i].ch && (r = !0), e += 1;
                                        r || (this.chars.push(t[i]), o += 1)
                                    }
                                }
                            },
                            addFonts: function (t, defs) {
                                if (t) {
                                    if (this.chars) return this.isLoaded = !0, void(this.fonts = t.list);
                                    var i, e = t.list,
                                        r = e.length,
                                        n = r;
                                    for (i = 0; i < r; i += 1) {
                                        var l, c, d = !0;
                                        if (e[i].loaded = !1, e[i].monoCase = o(e[i].fFamily, "monospace"), e[i].sansCase = o(e[i].fFamily, "sans-serif"), e[i].fPath) {
                                            if ("p" === e[i].fOrigin || 3 === e[i].origin) {
                                                if ((l = document.querySelectorAll('style[f-forigin="p"][f-family="' + e[i].fFamily + '"], style[f-origin="3"][f-family="' + e[i].fFamily + '"]')).length > 0 && (d = !1), d) {
                                                    var s = createTag("style");
                                                    s.setAttribute("f-forigin", e[i].fOrigin), s.setAttribute("f-origin", e[i].origin), s.setAttribute("f-family", e[i].fFamily), s.type = "text/css", s.innerText = "@font-face {font-family: " + e[i].fFamily + "; font-style: normal; src: url('" + e[i].fPath + "');}", defs.appendChild(s)
                                                }
                                            } else if ("g" === e[i].fOrigin || 1 === e[i].origin) {
                                                for (l = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), c = 0; c < l.length; c += 1) - 1 !== l[c].href.indexOf(e[i].fPath) && (d = !1);
                                                if (d) {
                                                    var m = createTag("link");
                                                    m.setAttribute("f-forigin", e[i].fOrigin), m.setAttribute("f-origin", e[i].origin), m.type = "text/css", m.rel = "stylesheet", m.href = e[i].fPath, document.body.appendChild(m)
                                                }
                                            } else if ("t" === e[i].fOrigin || 2 === e[i].origin) {
                                                for (l = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), c = 0; c < l.length; c += 1) e[i].fPath === l[c].src && (d = !1);
                                                if (d) {
                                                    var f = createTag("link");
                                                    f.setAttribute("f-forigin", e[i].fOrigin), f.setAttribute("f-origin", e[i].origin), f.setAttribute("rel", "stylesheet"), f.setAttribute("href", e[i].fPath), defs.appendChild(f)
                                                }
                                            }
                                        } else e[i].loaded = !0, n -= 1;
                                        e[i].helper = h(defs, e[i]), e[i].cache = {}, this.fonts.push(e[i])
                                    }
                                    0 === n ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
                                } else this.isLoaded = !0
                            },
                            getCharData: function (e, style, r) {
                                for (var i = 0, n = this.chars.length; i < n;) {
                                    if (this.chars[i].ch === e && this.chars[i].style === style && this.chars[i].fFamily === r) return this.chars[i];
                                    i += 1
                                }
                                return ("string" == typeof e && 13 !== e.charCodeAt(0) || !e) && console && console.warn && !this._warned && (this._warned = !0, console.warn("Missing character from exported characters list: ", e, style, r)), t
                            },
                            getFontByName: function (t) {
                                for (var i = 0, e = this.fonts.length; i < e;) {
                                    if (this.fonts[i].fName === t) return this.fonts[i];
                                    i += 1
                                }
                                return this.fonts[0]
                            },
                            measureText: function (t, e, r) {
                                var n = this.getFontByName(e),
                                    o = t.charCodeAt(0);
                                if (!n.cache[o + 1]) {
                                    var h = n.helper;
                                    if (" " === t) {
                                        h.textContent = "|" + t + "|";
                                        var l = h.getComputedTextLength();
                                        h.textContent = "||";
                                        var c = h.getComputedTextLength();
                                        n.cache[o + 1] = (l - c) / 100
                                    } else h.textContent = t, n.cache[o + 1] = h.getComputedTextLength() / 100
                                }
                                return n.cache[o + 1] * r
                            },
                            checkLoadedFonts: function () {
                                var i, t, e, r = this.fonts.length,
                                    n = r;
                                for (i = 0; i < r; i += 1) this.fonts[i].loaded ? n -= 1 : "n" === this.fonts[i].fOrigin || 0 === this.fonts[i].origin ? this.fonts[i].loaded = !0 : (t = this.fonts[i].monoCase.node, e = this.fonts[i].monoCase.w, t.offsetWidth !== e ? (n -= 1, this.fonts[i].loaded = !0) : (t = this.fonts[i].sansCase.node, e = this.fonts[i].sansCase.w, t.offsetWidth !== e && (n -= 1, this.fonts[i].loaded = !0)), this.fonts[i].loaded && (this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent), this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent)));
                                0 !== n && Date.now() - this.initTime < 5e3 ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10)
                            },
                            setIsLoaded: function () {
                                this.isLoaded = !0
                            }
                        }, l
                    }(),
                    PropertyFactory = function () {
                        var t = initialDefaultFrame,
                            e = Math.abs;

                        function r(t, e) {
                            var r, o = this.offsetTime;
                            "multidimensional" === this.propType && (r = createTypedArray("float32", this.pv.length));
                            for (var h, l, c, d, m, f, y, v, x = e.lastIndex, i = x, _ = this.keyframes.length - 1, M = !0; M;) {
                                if (h = this.keyframes[i], l = this.keyframes[i + 1], i === _ - 1 && t >= l.t - o) {
                                    h.h && (h = l), x = 0;
                                    break
                                }
                                if (l.t - o > t) {
                                    x = i;
                                    break
                                }
                                i < _ - 1 ? i += 1 : (x = 0, M = !1)
                            }
                            var S, w, E, T, A, P, C, L, D, R, I = l.t - o,
                                F = h.t - o;
                            if (h.to) {
                                h.bezierData || (h.bezierData = bez.buildBezierData(h.s, l.s || h.e, h.to, h.ti));
                                var k = h.bezierData;
                                if (t >= I || t < F) {
                                    var N = t >= I ? k.points.length - 1 : 0;
                                    for (d = k.points[N].point.length, c = 0; c < d; c += 1) r[c] = k.points[N].point[c]
                                } else {
                                    h.__fnct ? v = h.__fnct : (v = BezierFactory.getBezierEasing(h.o.x, h.o.y, h.i.x, h.i.y, h.n).get, h.__fnct = v), m = v((t - F) / (I - F));
                                    var B, z = k.segmentLength * m,
                                        V = e.lastFrame < t && e._lastKeyframeIndex === i ? e._lastAddedLength : 0;
                                    for (y = e.lastFrame < t && e._lastKeyframeIndex === i ? e._lastPoint : 0, M = !0, f = k.points.length; M;) {
                                        if (V += k.points[y].partialLength, 0 === z || 0 === m || y === k.points.length - 1) {
                                            for (d = k.points[y].point.length, c = 0; c < d; c += 1) r[c] = k.points[y].point[c];
                                            break
                                        }
                                        if (z >= V && z < V + k.points[y + 1].partialLength) {
                                            for (B = (z - V) / k.points[y + 1].partialLength, d = k.points[y].point.length, c = 0; c < d; c += 1) r[c] = k.points[y].point[c] + (k.points[y + 1].point[c] - k.points[y].point[c]) * B;
                                            break
                                        }
                                        y < f - 1 ? y += 1 : M = !1
                                    }
                                    e._lastPoint = y, e._lastAddedLength = V - k.points[y].partialLength, e._lastKeyframeIndex = i
                                }
                            } else {
                                var O, G, H, U, W;
                                if (_ = h.s.length, S = l.s || h.e, this.sh && 1 !== h.h)
                                    if (t >= I) r[0] = S[0], r[1] = S[1], r[2] = S[2];
                                    else if (t <= F) r[0] = h.s[0], r[1] = h.s[1], r[2] = h.s[2];
                                else {
                                    var j = n(h.s),
                                        X = n(S);
                                    w = r, E = function (a, b, t) {
                                        var e, r, n, o, h, l = [],
                                            c = a[0],
                                            d = a[1],
                                            m = a[2],
                                            f = a[3],
                                            y = b[0],
                                            v = b[1],
                                            x = b[2],
                                            _ = b[3];
                                        return (r = c * y + d * v + m * x + f * _) < 0 && (r = -r, y = -y, v = -v, x = -x, _ = -_), 1 - r > 1e-6 ? (e = Math.acos(r), n = Math.sin(e), o = Math.sin((1 - t) * e) / n, h = Math.sin(t * e) / n) : (o = 1 - t, h = t), l[0] = o * c + h * y, l[1] = o * d + h * v, l[2] = o * m + h * x, l[3] = o * f + h * _, l
                                    }(j, X, (t - F) / (I - F)), T = E[0], A = E[1], P = E[2], C = E[3], L = Math.atan2(2 * A * C - 2 * T * P, 1 - 2 * A * A - 2 * P * P), D = Math.asin(2 * T * A + 2 * P * C), R = Math.atan2(2 * T * C - 2 * A * P, 1 - 2 * T * T - 2 * P * P), w[0] = L / degToRads, w[1] = D / degToRads, w[2] = R / degToRads
                                } else
                                    for (i = 0; i < _; i += 1) 1 !== h.h && (t >= I ? m = 1 : t < F ? m = 0 : (h.o.x.constructor === Array ? (h.__fnct || (h.__fnct = []), h.__fnct[i] ? v = h.__fnct[i] : (O = void 0 === h.o.x[i] ? h.o.x[0] : h.o.x[i], G = void 0 === h.o.y[i] ? h.o.y[0] : h.o.y[i], H = void 0 === h.i.x[i] ? h.i.x[0] : h.i.x[i], U = void 0 === h.i.y[i] ? h.i.y[0] : h.i.y[i], v = BezierFactory.getBezierEasing(O, G, H, U).get, h.__fnct[i] = v)) : h.__fnct ? v = h.__fnct : (O = h.o.x, G = h.o.y, H = h.i.x, U = h.i.y, v = BezierFactory.getBezierEasing(O, G, H, U).get, h.__fnct = v), m = v((t - F) / (I - F)))), S = l.s || h.e, W = 1 === h.h ? h.s[i] : h.s[i] + (S[i] - h.s[i]) * m, "multidimensional" === this.propType ? r[i] = W : r = W
                            }
                            return e.lastIndex = x, r
                        }

                        function n(t) {
                            var e = t[0] * degToRads,
                                r = t[1] * degToRads,
                                n = t[2] * degToRads,
                                o = Math.cos(e / 2),
                                h = Math.cos(r / 2),
                                l = Math.cos(n / 2),
                                c = Math.sin(e / 2),
                                d = Math.sin(r / 2),
                                m = Math.sin(n / 2);
                            return [c * d * l + o * h * m, c * h * l + o * d * m, o * d * l - c * h * m, o * h * l - c * d * m]
                        }

                        function o() {
                            var e = this.comp.renderedFrame - this.offsetTime,
                                r = this.keyframes[0].t - this.offsetTime,
                                n = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
                            if (!(e === this._caching.lastFrame || this._caching.lastFrame !== t && (this._caching.lastFrame >= n && e >= n || this._caching.lastFrame < r && e < r))) {
                                this._caching.lastFrame >= e && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0);
                                var o = this.interpolateValue(e, this._caching);
                                this.pv = o
                            }
                            return this._caching.lastFrame = e, this.pv
                        }

                        function h(t) {
                            var r;
                            if ("unidimensional" === this.propType) r = t * this.mult, e(this.v - r) > 1e-5 && (this.v = r, this._mdf = !0);
                            else
                                for (var i = 0, n = this.v.length; i < n;) r = t[i] * this.mult, e(this.v[i] - r) > 1e-5 && (this.v[i] = r, this._mdf = !0), i += 1
                        }

                        function l() {
                            if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length)
                                if (this.lock) this.setVValue(this.pv);
                                else {
                                    var i;
                                    this.lock = !0, this._mdf = this._isFirstFrame;
                                    var t = this.effectsSequence.length,
                                        e = this.kf ? this.pv : this.data.k;
                                    for (i = 0; i < t; i += 1) e = this.effectsSequence[i](e);
                                    this.setVValue(e), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId
                                }
                        }

                        function c(t) {
                            this.effectsSequence.push(t), this.container.addDynamicProperty(this)
                        }

                        function d(t, data, e, r) {
                            this.propType = "unidimensional", this.mult = e || 1, this.data = data, this.v = e ? data.k * e : data.k, this.pv = data.k, this._mdf = !1, this.elem = t, this.container = r, this.comp = t.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = l, this.setVValue = h, this.addEffect = c
                        }

                        function m(t, data, e, r) {
                            var i;
                            this.propType = "multidimensional", this.mult = e || 1, this.data = data, this._mdf = !1, this.elem = t, this.container = r, this.comp = t.comp, this.k = !1, this.kf = !1, this.frameId = -1;
                            var n = data.k.length;
                            for (this.v = createTypedArray("float32", n), this.pv = createTypedArray("float32", n), this.vel = createTypedArray("float32", n), i = 0; i < n; i += 1) this.v[i] = data.k[i] * this.mult, this.pv[i] = data.k[i];
                            this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = l, this.setVValue = h, this.addEffect = c
                        }

                        function f(e, data, n, d) {
                            this.propType = "unidimensional", this.keyframes = data.k, this.offsetTime = e.data.st, this.frameId = -1, this._caching = {
                                lastFrame: t,
                                lastIndex: 0,
                                value: 0,
                                _lastKeyframeIndex: -1
                            }, this.k = !0, this.kf = !0, this.data = data, this.mult = n || 1, this.elem = e, this.container = d, this.comp = e.comp, this.v = t, this.pv = t, this._isFirstFrame = !0, this.getValue = l, this.setVValue = h, this.interpolateValue = r, this.effectsSequence = [o.bind(this)], this.addEffect = c
                        }

                        function y(e, data, n, d) {
                            var i;
                            this.propType = "multidimensional";
                            var s, m, f, y, v = data.k.length;
                            for (i = 0; i < v - 1; i += 1) data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s && (s = data.k[i].s, m = data.k[i + 1].s, f = data.k[i].to, y = data.k[i].ti, (2 === s.length && (s[0] !== m[0] || s[1] !== m[1]) && bez.pointOnLine2D(s[0], s[1], m[0], m[1], s[0] + f[0], s[1] + f[1]) && bez.pointOnLine2D(s[0], s[1], m[0], m[1], m[0] + y[0], m[1] + y[1]) || 3 === s.length && (s[0] !== m[0] || s[1] !== m[1] || s[2] !== m[2]) && bez.pointOnLine3D(s[0], s[1], s[2], m[0], m[1], m[2], s[0] + f[0], s[1] + f[1], s[2] + f[2]) && bez.pointOnLine3D(s[0], s[1], s[2], m[0], m[1], m[2], m[0] + y[0], m[1] + y[1], m[2] + y[2])) && (data.k[i].to = null, data.k[i].ti = null), s[0] === m[0] && s[1] === m[1] && 0 === f[0] && 0 === f[1] && 0 === y[0] && 0 === y[1] && (2 === s.length || s[2] === m[2] && 0 === f[2] && 0 === y[2]) && (data.k[i].to = null, data.k[i].ti = null));
                            this.effectsSequence = [o.bind(this)], this.data = data, this.keyframes = data.k, this.offsetTime = e.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = n || 1, this.elem = e, this.container = d, this.comp = e.comp, this.getValue = l, this.setVValue = h, this.interpolateValue = r, this.frameId = -1;
                            var x = data.k[0].s.length;
                            for (this.v = createTypedArray("float32", x), this.pv = createTypedArray("float32", x), i = 0; i < x; i += 1) this.v[i] = t, this.pv[i] = t;
                            this._caching = {
                                lastFrame: t,
                                lastIndex: 0,
                                value: createTypedArray("float32", x)
                            }, this.addEffect = c
                        }
                        return {
                            getProp: function (t, data, e, r, n) {
                                var p;
                                if (data.k.length)
                                    if ("number" == typeof data.k[0]) p = new m(t, data, r, n);
                                    else switch (e) {
                                        case 0:
                                            p = new f(t, data, r, n);
                                            break;
                                        case 1:
                                            p = new y(t, data, r, n)
                                    } else p = new d(t, data, r, n);
                                return p.effectsSequence.length && n.addDynamicProperty(p), p
                            }
                        }
                    }(),
                    TransformPropertyFactory = function () {
                        var t = [0, 0];

                        function e(t, data, e) {
                            if (this.elem = t, this.frameId = -1, this.propType = "transform", this.data = data, this.v = new Matrix, this.pre = new Matrix, this.appliedTransformations = 0, this.initDynamicPropertyContainer(e || t), data.p && data.p.s ? (this.px = PropertyFactory.getProp(t, data.p.x, 0, 0, this), this.py = PropertyFactory.getProp(t, data.p.y, 0, 0, this), data.p.z && (this.pz = PropertyFactory.getProp(t, data.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(t, data.p || {
                                    k: [0, 0, 0]
                                }, 1, 0, this), data.rx) {
                                if (this.rx = PropertyFactory.getProp(t, data.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(t, data.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(t, data.rz, 0, degToRads, this), data.or.k[0].ti) {
                                    var i, r = data.or.k.length;
                                    for (i = 0; i < r; i += 1) data.or.k[i].to = null, data.or.k[i].ti = null
                                }
                                this.or = PropertyFactory.getProp(t, data.or, 1, degToRads, this), this.or.sh = !0
                            } else this.r = PropertyFactory.getProp(t, data.r || {
                                k: 0
                            }, 0, degToRads, this);
                            data.sk && (this.sk = PropertyFactory.getProp(t, data.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(t, data.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(t, data.a || {
                                k: [0, 0, 0]
                            }, 1, 0, this), this.s = PropertyFactory.getProp(t, data.s || {
                                k: [100, 100, 100]
                            }, 1, .01, this), data.o ? this.o = PropertyFactory.getProp(t, data.o, 0, .01, t) : this.o = {
                                _mdf: !1,
                                v: 1
                            }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0)
                        }
                        return e.prototype = {
                            applyToMatrix: function (t) {
                                var e = this._mdf;
                                this.iterateDynamicProperties(), this._mdf = this._mdf || e, this.a && t.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && t.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && t.skewFromAxis(-this.sk.v, this.sa.v), this.r ? t.rotate(-this.r.v) : t.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? t.translate(this.px.v, this.py.v, -this.pz.v) : t.translate(this.px.v, this.py.v, 0) : t.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                            },
                            getValue: function (e) {
                                if (this.elem.globalData.frameId !== this.frameId) {
                                    if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || e) {
                                        var r;
                                        if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) {
                                            var n, o;
                                            if (r = this.elem.globalData.frameRate, this.p && this.p.keyframes && this.p.getValueAtTime) this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (n = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / r, 0), o = this.p.getValueAtTime(this.p.keyframes[0].t / r, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (n = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / r, 0), o = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / r, 0)) : (n = this.p.pv, o = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / r, this.p.offsetTime));
                                            else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                                                n = [], o = [];
                                                var h = this.px,
                                                    l = this.py;
                                                h._caching.lastFrame + h.offsetTime <= h.keyframes[0].t ? (n[0] = h.getValueAtTime((h.keyframes[0].t + .01) / r, 0), n[1] = l.getValueAtTime((l.keyframes[0].t + .01) / r, 0), o[0] = h.getValueAtTime(h.keyframes[0].t / r, 0), o[1] = l.getValueAtTime(l.keyframes[0].t / r, 0)) : h._caching.lastFrame + h.offsetTime >= h.keyframes[h.keyframes.length - 1].t ? (n[0] = h.getValueAtTime(h.keyframes[h.keyframes.length - 1].t / r, 0), n[1] = l.getValueAtTime(l.keyframes[l.keyframes.length - 1].t / r, 0), o[0] = h.getValueAtTime((h.keyframes[h.keyframes.length - 1].t - .01) / r, 0), o[1] = l.getValueAtTime((l.keyframes[l.keyframes.length - 1].t - .01) / r, 0)) : (n = [h.pv, l.pv], o[0] = h.getValueAtTime((h._caching.lastFrame + h.offsetTime - .01) / r, h.offsetTime), o[1] = l.getValueAtTime((l._caching.lastFrame + l.offsetTime - .01) / r, l.offsetTime))
                                            } else n = o = t;
                                            this.v.rotate(-Math.atan2(n[1] - o[1], n[0] - o[0]))
                                        }
                                        this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                                    }
                                    this.frameId = this.elem.globalData.frameId
                                }
                            },
                            precalculateMatrix: function () {
                                if (!this.a.k && (this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1, !this.s.effectsSequence.length)) {
                                    if (this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2, this.sk) {
                                        if (this.sk.effectsSequence.length || this.sa.effectsSequence.length) return;
                                        this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3
                                    }
                                    this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v), this.appliedTransformations = 4) : this.rz.effectsSequence.length || this.ry.effectsSequence.length || this.rx.effectsSequence.length || this.or.effectsSequence.length || (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4)
                                }
                            },
                            autoOrient: function () {}
                        }, extendPrototype([DynamicPropertyContainer], e), e.prototype.addDynamicProperty = function (t) {
                            this._addDynamicProperty(t), this.elem.addDynamicProperty(t), this._isDirty = !0
                        }, e.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty, {
                            getTransformProperty: function (t, data, r) {
                                return new e(t, data, r)
                            }
                        }
                    }();

                function ShapePath() {
                    this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength)
                }
                ShapePath.prototype.setPathData = function (t, e) {
                    this.c = t, this.setLength(e);
                    for (var i = 0; i < e;) this.v[i] = pointPool.newElement(), this.o[i] = pointPool.newElement(), this.i[i] = pointPool.newElement(), i += 1
                }, ShapePath.prototype.setLength = function (t) {
                    for (; this._maxLength < t;) this.doubleArrayLength();
                    this._length = t
                }, ShapePath.prototype.doubleArrayLength = function () {
                    this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2
                }, ShapePath.prototype.setXYAt = function (t, e, r, n, o) {
                    var h;
                    switch (this._length = Math.max(this._length, n + 1), this._length >= this._maxLength && this.doubleArrayLength(), r) {
                        case "v":
                            h = this.v;
                            break;
                        case "i":
                            h = this.i;
                            break;
                        case "o":
                            h = this.o;
                            break;
                        default:
                            h = []
                    }(!h[n] || h[n] && !o) && (h[n] = pointPool.newElement()), h[n][0] = t, h[n][1] = e
                }, ShapePath.prototype.setTripleAt = function (t, e, r, n, o, h, l, c) {
                    this.setXYAt(t, e, "v", l, c), this.setXYAt(r, n, "o", l, c), this.setXYAt(o, h, "i", l, c)
                }, ShapePath.prototype.reverse = function () {
                    var t = new ShapePath;
                    t.setPathData(this.c, this._length);
                    var e = this.v,
                        r = this.o,
                        n = this.i,
                        o = 0;
                    this.c && (t.setTripleAt(e[0][0], e[0][1], n[0][0], n[0][1], r[0][0], r[0][1], 0, !1), o = 1);
                    var i, h = this._length - 1,
                        l = this._length;
                    for (i = o; i < l; i += 1) t.setTripleAt(e[h][0], e[h][1], n[h][0], n[h][1], r[h][0], r[h][1], i, !1), h -= 1;
                    return t
                };
                var ShapePropertyFactory = function () {
                        var t = -999999;

                        function e(t, e, r) {
                            var n, o, h, l, c, d, m, f, y, v = r.lastIndex,
                                x = this.keyframes;
                            if (t < x[0].t - this.offsetTime) n = x[0].s[0], h = !0, v = 0;
                            else if (t >= x[x.length - 1].t - this.offsetTime) n = x[x.length - 1].s ? x[x.length - 1].s[0] : x[x.length - 2].e[0], h = !0;
                            else {
                                for (var _, M, i = v, S = x.length - 1, w = !0; w && (_ = x[i], !((M = x[i + 1]).t - this.offsetTime > t));) i < S - 1 ? i += 1 : w = !1;
                                if (v = i, !(h = 1 === _.h)) {
                                    if (t >= M.t - this.offsetTime) f = 1;
                                    else if (t < _.t - this.offsetTime) f = 0;
                                    else {
                                        var E;
                                        _.__fnct ? E = _.__fnct : (E = BezierFactory.getBezierEasing(_.o.x, _.o.y, _.i.x, _.i.y).get, _.__fnct = E), f = E((t - (_.t - this.offsetTime)) / (M.t - this.offsetTime - (_.t - this.offsetTime)))
                                    }
                                    o = M.s ? M.s[0] : _.e[0]
                                }
                                n = _.s[0]
                            }
                            for (d = e._length, m = n.i[0].length, r.lastIndex = v, l = 0; l < d; l += 1)
                                for (c = 0; c < m; c += 1) y = h ? n.i[l][c] : n.i[l][c] + (o.i[l][c] - n.i[l][c]) * f, e.i[l][c] = y, y = h ? n.o[l][c] : n.o[l][c] + (o.o[l][c] - n.o[l][c]) * f, e.o[l][c] = y, y = h ? n.v[l][c] : n.v[l][c] + (o.v[l][c] - n.v[l][c]) * f, e.v[l][c] = y
                        }

                        function r() {
                            var e = this.comp.renderedFrame - this.offsetTime,
                                r = this.keyframes[0].t - this.offsetTime,
                                n = this.keyframes[this.keyframes.length - 1].t - this.offsetTime,
                                o = this._caching.lastFrame;
                            return o !== t && (o < r && e < r || o > n && e > n) || (this._caching.lastIndex = o < e ? this._caching.lastIndex : 0, this.interpolateShape(e, this.pv, this._caching)), this._caching.lastFrame = e, this.pv
                        }

                        function n() {
                            this.paths = this.localShapeCollection
                        }

                        function o(t) {
                            (function (t, e) {
                                if (t._length !== e._length || t.c !== e.c) return !1;
                                var i, r = t._length;
                                for (i = 0; i < r; i += 1)
                                    if (t.v[i][0] !== e.v[i][0] || t.v[i][1] !== e.v[i][1] || t.o[i][0] !== e.o[i][0] || t.o[i][1] !== e.o[i][1] || t.i[i][0] !== e.i[i][0] || t.i[i][1] !== e.i[i][1]) return !1;
                                return !0
                            })(this.v, t) || (this.v = shapePool.clone(t), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection)
                        }

                        function h() {
                            if (this.elem.globalData.frameId !== this.frameId)
                                if (this.effectsSequence.length)
                                    if (this.lock) this.setVValue(this.pv);
                                    else {
                                        var t, i;
                                        this.lock = !0, this._mdf = !1, t = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k;
                                        var e = this.effectsSequence.length;
                                        for (i = 0; i < e; i += 1) t = this.effectsSequence[i](t);
                                        this.setVValue(t), this.lock = !1, this.frameId = this.elem.globalData.frameId
                                    }
                            else this._mdf = !1
                        }

                        function l(t, data, e) {
                            this.propType = "shape", this.comp = t.comp, this.container = t, this.elem = t, this.data = data, this.k = !1, this.kf = !1, this._mdf = !1;
                            var r = 3 === e ? data.pt.k : data.ks.k;
                            this.v = shapePool.clone(r), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = n, this.effectsSequence = []
                        }

                        function c(t) {
                            this.effectsSequence.push(t), this.container.addDynamicProperty(this)
                        }

                        function d(e, data, o) {
                            this.propType = "shape", this.comp = e.comp, this.elem = e, this.container = e, this.offsetTime = e.data.st, this.keyframes = 3 === o ? data.pt.k : data.ks.k, this.k = !0, this.kf = !0;
                            var h = this.keyframes[0].s[0].i.length;
                            this.v = shapePool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, h), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = t, this.reset = n, this._caching = {
                                lastFrame: t,
                                lastIndex: 0
                            }, this.effectsSequence = [r.bind(this)]
                        }
                        l.prototype.interpolateShape = e, l.prototype.getValue = h, l.prototype.setVValue = o, l.prototype.addEffect = c, d.prototype.getValue = h, d.prototype.interpolateShape = e, d.prototype.setVValue = o, d.prototype.addEffect = c;
                        var m = function () {
                                var t = roundCorner;

                                function e(t, data) {
                                    this.v = shapePool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = data.d, this.elem = t, this.comp = t.comp, this.frameId = -1, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, data.p, 1, 0, this), this.s = PropertyFactory.getProp(t, data.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath())
                                }
                                return e.prototype = {
                                    reset: n,
                                    getValue: function () {
                                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath())
                                    },
                                    convertEllToPath: function () {
                                        var e = this.p.v[0],
                                            r = this.p.v[1],
                                            n = this.s.v[0] / 2,
                                            o = this.s.v[1] / 2,
                                            h = 3 !== this.d,
                                            l = this.v;
                                        l.v[0][0] = e, l.v[0][1] = r - o, l.v[1][0] = h ? e + n : e - n, l.v[1][1] = r, l.v[2][0] = e, l.v[2][1] = r + o, l.v[3][0] = h ? e - n : e + n, l.v[3][1] = r, l.i[0][0] = h ? e - n * t : e + n * t, l.i[0][1] = r - o, l.i[1][0] = h ? e + n : e - n, l.i[1][1] = r - o * t, l.i[2][0] = h ? e + n * t : e - n * t, l.i[2][1] = r + o, l.i[3][0] = h ? e - n : e + n, l.i[3][1] = r + o * t, l.o[0][0] = h ? e + n * t : e - n * t, l.o[0][1] = r - o, l.o[1][0] = h ? e + n : e - n, l.o[1][1] = r + o * t, l.o[2][0] = h ? e - n * t : e + n * t, l.o[2][1] = r + o, l.o[3][0] = h ? e - n : e + n, l.o[3][1] = r - o * t
                                    }
                                }, extendPrototype([DynamicPropertyContainer], e), e
                            }(),
                            f = function () {
                                function t(t, data) {
                                    this.v = shapePool.newElement(), this.v.setPathData(!0, 0), this.elem = t, this.comp = t.comp, this.data = data, this.frameId = -1, this.d = data.d, this.initDynamicPropertyContainer(t), 1 === data.sy ? (this.ir = PropertyFactory.getProp(t, data.ir, 0, 0, this), this.is = PropertyFactory.getProp(t, data.is, 0, .01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(t, data.pt, 0, 0, this), this.p = PropertyFactory.getProp(t, data.p, 1, 0, this), this.r = PropertyFactory.getProp(t, data.r, 0, degToRads, this), this.or = PropertyFactory.getProp(t, data.or, 0, 0, this), this.os = PropertyFactory.getProp(t, data.os, 0, .01, this), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath())
                                }
                                return t.prototype = {
                                    reset: n,
                                    getValue: function () {
                                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath())
                                    },
                                    convertStarToPath: function () {
                                        var i, t, e, r, n = 2 * Math.floor(this.pt.v),
                                            o = 2 * Math.PI / n,
                                            h = !0,
                                            l = this.or.v,
                                            c = this.ir.v,
                                            d = this.os.v,
                                            m = this.is.v,
                                            f = 2 * Math.PI * l / (2 * n),
                                            y = 2 * Math.PI * c / (2 * n),
                                            v = -Math.PI / 2;
                                        v += this.r.v;
                                        var x = 3 === this.data.d ? -1 : 1;
                                        for (this.v._length = 0, i = 0; i < n; i += 1) {
                                            e = h ? d : m, r = h ? f : y;
                                            var _ = (t = h ? l : c) * Math.cos(v),
                                                M = t * Math.sin(v),
                                                S = 0 === _ && 0 === M ? 0 : M / Math.sqrt(_ * _ + M * M),
                                                w = 0 === _ && 0 === M ? 0 : -_ / Math.sqrt(_ * _ + M * M);
                                            _ += +this.p.v[0], M += +this.p.v[1], this.v.setTripleAt(_, M, _ - S * r * e * x, M - w * r * e * x, _ + S * r * e * x, M + w * r * e * x, i, !0), h = !h, v += o * x
                                        }
                                    },
                                    convertPolygonToPath: function () {
                                        var i, t = Math.floor(this.pt.v),
                                            e = 2 * Math.PI / t,
                                            r = this.or.v,
                                            n = this.os.v,
                                            o = 2 * Math.PI * r / (4 * t),
                                            h = .5 * -Math.PI,
                                            l = 3 === this.data.d ? -1 : 1;
                                        for (h += this.r.v, this.v._length = 0, i = 0; i < t; i += 1) {
                                            var c = r * Math.cos(h),
                                                d = r * Math.sin(h),
                                                m = 0 === c && 0 === d ? 0 : d / Math.sqrt(c * c + d * d),
                                                f = 0 === c && 0 === d ? 0 : -c / Math.sqrt(c * c + d * d);
                                            c += +this.p.v[0], d += +this.p.v[1], this.v.setTripleAt(c, d, c - m * o * n * l, d - f * o * n * l, c + m * o * n * l, d + f * o * n * l, i, !0), h += e * l
                                        }
                                        this.paths.length = 0, this.paths[0] = this.v
                                    }
                                }, extendPrototype([DynamicPropertyContainer], t), t
                            }(),
                            y = function () {
                                function t(t, data) {
                                    this.v = shapePool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = t, this.comp = t.comp, this.frameId = -1, this.d = data.d, this.initDynamicPropertyContainer(t), this.p = PropertyFactory.getProp(t, data.p, 1, 0, this), this.s = PropertyFactory.getProp(t, data.s, 1, 0, this), this.r = PropertyFactory.getProp(t, data.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath())
                                }
                                return t.prototype = {
                                    convertRectToPath: function () {
                                        var t = this.p.v[0],
                                            e = this.p.v[1],
                                            r = this.s.v[0] / 2,
                                            n = this.s.v[1] / 2,
                                            o = bmMin(r, n, this.r.v),
                                            h = o * (1 - roundCorner);
                                        this.v._length = 0, 2 === this.d || 1 === this.d ? (this.v.setTripleAt(t + r, e - n + o, t + r, e - n + o, t + r, e - n + h, 0, !0), this.v.setTripleAt(t + r, e + n - o, t + r, e + n - h, t + r, e + n - o, 1, !0), 0 !== o ? (this.v.setTripleAt(t + r - o, e + n, t + r - o, e + n, t + r - h, e + n, 2, !0), this.v.setTripleAt(t - r + o, e + n, t - r + h, e + n, t - r + o, e + n, 3, !0), this.v.setTripleAt(t - r, e + n - o, t - r, e + n - o, t - r, e + n - h, 4, !0), this.v.setTripleAt(t - r, e - n + o, t - r, e - n + h, t - r, e - n + o, 5, !0), this.v.setTripleAt(t - r + o, e - n, t - r + o, e - n, t - r + h, e - n, 6, !0), this.v.setTripleAt(t + r - o, e - n, t + r - h, e - n, t + r - o, e - n, 7, !0)) : (this.v.setTripleAt(t - r, e + n, t - r + h, e + n, t - r, e + n, 2), this.v.setTripleAt(t - r, e - n, t - r, e - n + h, t - r, e - n, 3))) : (this.v.setTripleAt(t + r, e - n + o, t + r, e - n + h, t + r, e - n + o, 0, !0), 0 !== o ? (this.v.setTripleAt(t + r - o, e - n, t + r - o, e - n, t + r - h, e - n, 1, !0), this.v.setTripleAt(t - r + o, e - n, t - r + h, e - n, t - r + o, e - n, 2, !0), this.v.setTripleAt(t - r, e - n + o, t - r, e - n + o, t - r, e - n + h, 3, !0), this.v.setTripleAt(t - r, e + n - o, t - r, e + n - h, t - r, e + n - o, 4, !0), this.v.setTripleAt(t - r + o, e + n, t - r + o, e + n, t - r + h, e + n, 5, !0), this.v.setTripleAt(t + r - o, e + n, t + r - h, e + n, t + r - o, e + n, 6, !0), this.v.setTripleAt(t + r, e + n - o, t + r, e + n - o, t + r, e + n - h, 7, !0)) : (this.v.setTripleAt(t - r, e - n, t - r + h, e - n, t - r, e - n, 1, !0), this.v.setTripleAt(t - r, e + n, t - r, e + n - h, t - r, e + n, 2, !0), this.v.setTripleAt(t + r, e + n, t + r - h, e + n, t + r, e + n, 3, !0)))
                                    },
                                    getValue: function () {
                                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath())
                                    },
                                    reset: n
                                }, extendPrototype([DynamicPropertyContainer], t), t
                            }(),
                            v = {
                                getShapeProp: function (t, data, e) {
                                    var r;
                                    return 3 === e || 4 === e ? r = (3 === e ? data.pt : data.ks).k.length ? new d(t, data, e) : new l(t, data, e) : 5 === e ? r = new y(t, data) : 6 === e ? r = new m(t, data) : 7 === e && (r = new f(t, data)), r.k && t.addDynamicProperty(r), r
                                },
                                getConstructorFunction: function () {
                                    return l
                                },
                                getKeyframedConstructorFunction: function () {
                                    return d
                                }
                            };
                        return v
                    }(),
                    ShapeModifiers = (ob = {}, modifiers = {}, ob.registerModifier = function (t, e) {
                        modifiers[t] || (modifiers[t] = e)
                    }, ob.getModifier = function (t, e, data) {
                        return new modifiers[t](e, data)
                    }, ob),
                    ob, modifiers;

                function ShapeModifier() {}

                function TrimModifier() {}

                function RoundCornersModifier() {}

                function PuckerAndBloatModifier() {}

                function RepeaterModifier() {}

                function ShapeCollection() {
                    this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength)
                }

                function DashProperty(t, data, e, r) {
                    var i;
                    this.elem = t, this.frameId = -1, this.dataProps = createSizedArray(data.length), this.renderer = e, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", data.length ? data.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(r);
                    var n, o = data.length || 0;
                    for (i = 0; i < o; i += 1) n = PropertyFactory.getProp(t, data[i].v, 0, 0, this), this.k = n.k || this.k, this.dataProps[i] = {
                        n: data[i].n,
                        p: n
                    };
                    this.k || this.getValue(!0), this._isAnimated = this.k
                }

                function GradientProperty(t, data, e) {
                    this.data = data, this.c = createTypedArray("uint8c", 4 * data.p);
                    var r = data.k.k[0].s ? data.k.k[0].s.length - 4 * data.p : data.k.k.length - 4 * data.p;
                    this.o = createTypedArray("float32", r), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = r, this.initDynamicPropertyContainer(e), this.prop = PropertyFactory.getProp(t, data.k, 1, null, this), this.k = this.prop.k, this.getValue(!0)
                }
                ShapeModifier.prototype.initModifierProperties = function () {}, ShapeModifier.prototype.addShapeToModifier = function () {}, ShapeModifier.prototype.addShape = function (data) {
                    if (!this.closed) {
                        data.sh.container.addDynamicProperty(data.sh);
                        var t = {
                            shape: data.sh,
                            data: data,
                            localShapeCollection: shapeCollectionPool.newShapeCollection()
                        };
                        this.shapes.push(t), this.addShapeToModifier(t), this._isAnimated && data.setAsAnimated()
                    }
                }, ShapeModifier.prototype.init = function (t, data) {
                    this.shapes = [], this.elem = t, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, data), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
                }, ShapeModifier.prototype.processKeys = function () {
                    this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties())
                }, extendPrototype([DynamicPropertyContainer], ShapeModifier), extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function (t, data) {
                    this.s = PropertyFactory.getProp(t, data.s, 0, .01, this), this.e = PropertyFactory.getProp(t, data.e, 0, .01, this), this.o = PropertyFactory.getProp(t, data.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = data.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
                }, TrimModifier.prototype.addShapeToModifier = function (t) {
                    t.pathsData = []
                }, TrimModifier.prototype.calculateShapeEdges = function (s, t, e, r, n) {
                    var o = [];
                    t <= 1 ? o.push({
                        s: s,
                        e: t
                    }) : s >= 1 ? o.push({
                        s: s - 1,
                        e: t - 1
                    }) : (o.push({
                        s: s,
                        e: 1
                    }), o.push({
                        s: 0,
                        e: t - 1
                    }));
                    var i, h, l = [],
                        c = o.length;
                    for (i = 0; i < c; i += 1) {
                        var d, m;
                        (h = o[i]).e * n < r || h.s * n > r + e || (d = h.s * n <= r ? 0 : (h.s * n - r) / e, m = h.e * n >= r + e ? 1 : (h.e * n - r) / e, l.push([d, m]))
                    }
                    return l.length || l.push([0, 0]), l
                }, TrimModifier.prototype.releasePathsData = function (t) {
                    var i, e = t.length;
                    for (i = 0; i < e; i += 1) segmentsLengthPool.release(t[i]);
                    return t.length = 0, t
                }, TrimModifier.prototype.processShapes = function (t) {
                    var s, e, r, i;
                    if (this._mdf || t) {
                        var n = this.o.v % 360 / 360;
                        if (n < 0 && (n += 1), (s = this.s.v > 1 ? 1 + n : this.s.v < 0 ? 0 + n : this.s.v + n) > (e = this.e.v > 1 ? 1 + n : this.e.v < 0 ? 0 + n : this.e.v + n)) {
                            var o = s;
                            s = e, e = o
                        }
                        s = 1e-4 * Math.round(1e4 * s), e = 1e-4 * Math.round(1e4 * e), this.sValue = s, this.eValue = e
                    } else s = this.sValue, e = this.eValue;
                    var h, l, c, d, m, f = this.shapes.length,
                        y = 0;
                    if (e === s)
                        for (i = 0; i < f; i += 1) this.shapes[i].localShapeCollection.releaseShapes(), this.shapes[i].shape._mdf = !0, this.shapes[i].shape.paths = this.shapes[i].localShapeCollection, this._mdf && (this.shapes[i].pathsData.length = 0);
                    else if (1 === e && 0 === s || 0 === e && 1 === s) {
                        if (this._mdf)
                            for (i = 0; i < f; i += 1) this.shapes[i].pathsData.length = 0, this.shapes[i].shape._mdf = !0
                    } else {
                        var v, x, _ = [];
                        for (i = 0; i < f; i += 1)
                            if ((v = this.shapes[i]).shape._mdf || this._mdf || t || 2 === this.m) {
                                if (l = (r = v.shape.paths)._length, m = 0, !v.shape._mdf && v.pathsData.length) m = v.totalShapeLength;
                                else {
                                    for (c = this.releasePathsData(v.pathsData), h = 0; h < l; h += 1) d = bez.getSegmentsLength(r.shapes[h]), c.push(d), m += d.totalLength;
                                    v.totalShapeLength = m, v.pathsData = c
                                }
                                y += m, v.shape._mdf = !0
                            } else v.shape.paths = v.localShapeCollection;
                        var M, S = s,
                            w = e,
                            E = 0;
                        for (i = f - 1; i >= 0; i -= 1)
                            if ((v = this.shapes[i]).shape._mdf) {
                                for ((x = v.localShapeCollection).releaseShapes(), 2 === this.m && f > 1 ? (M = this.calculateShapeEdges(s, e, v.totalShapeLength, E, y), E += v.totalShapeLength) : M = [
                                        [S, w]
                                    ], l = M.length, h = 0; h < l; h += 1) {
                                    S = M[h][0], w = M[h][1], _.length = 0, w <= 1 ? _.push({
                                        s: v.totalShapeLength * S,
                                        e: v.totalShapeLength * w
                                    }) : S >= 1 ? _.push({
                                        s: v.totalShapeLength * (S - 1),
                                        e: v.totalShapeLength * (w - 1)
                                    }) : (_.push({
                                        s: v.totalShapeLength * S,
                                        e: v.totalShapeLength
                                    }), _.push({
                                        s: 0,
                                        e: v.totalShapeLength * (w - 1)
                                    }));
                                    var T = this.addShapes(v, _[0]);
                                    if (_[0].s !== _[0].e) {
                                        if (_.length > 1)
                                            if (v.shape.paths.shapes[v.shape.paths._length - 1].c) {
                                                var A = T.pop();
                                                this.addPaths(T, x), T = this.addShapes(v, _[1], A)
                                            } else this.addPaths(T, x), T = this.addShapes(v, _[1]);
                                        this.addPaths(T, x)
                                    }
                                }
                                v.shape.paths = x
                            }
                    }
                }, TrimModifier.prototype.addPaths = function (t, e) {
                    var i, r = t.length;
                    for (i = 0; i < r; i += 1) e.addShape(t[i])
                }, TrimModifier.prototype.addSegment = function (t, e, r, n, o, h, l) {
                    o.setXYAt(e[0], e[1], "o", h), o.setXYAt(r[0], r[1], "i", h + 1), l && o.setXYAt(t[0], t[1], "v", h), o.setXYAt(n[0], n[1], "v", h + 1)
                }, TrimModifier.prototype.addSegmentFromArray = function (t, e, r, n) {
                    e.setXYAt(t[1], t[5], "o", r), e.setXYAt(t[2], t[6], "i", r + 1), n && e.setXYAt(t[0], t[4], "v", r), e.setXYAt(t[3], t[7], "v", r + 1)
                }, TrimModifier.prototype.addShapes = function (t, e, r) {
                    var i, n, o, h, l, c, d, m, f = t.pathsData,
                        y = t.shape.paths.shapes,
                        v = t.shape.paths._length,
                        x = 0,
                        _ = [],
                        M = !0;
                    for (r ? (l = r._length, m = r._length) : (r = shapePool.newElement(), l = 0, m = 0), _.push(r), i = 0; i < v; i += 1) {
                        for (c = f[i].lengths, r.c = y[i].c, o = y[i].c ? c.length : c.length + 1, n = 1; n < o; n += 1)
                            if (x + (h = c[n - 1]).addedLength < e.s) x += h.addedLength, r.c = !1;
                            else {
                                if (x > e.e) {
                                    r.c = !1;
                                    break
                                }
                                e.s <= x && e.e >= x + h.addedLength ? (this.addSegment(y[i].v[n - 1], y[i].o[n - 1], y[i].i[n], y[i].v[n], r, l, M), M = !1) : (d = bez.getNewSegment(y[i].v[n - 1], y[i].v[n], y[i].o[n - 1], y[i].i[n], (e.s - x) / h.addedLength, (e.e - x) / h.addedLength, c[n - 1]), this.addSegmentFromArray(d, r, l, M), M = !1, r.c = !1), x += h.addedLength, l += 1
                            } if (y[i].c && c.length) {
                            if (h = c[n - 1], x <= e.e) {
                                var S = c[n - 1].addedLength;
                                e.s <= x && e.e >= x + S ? (this.addSegment(y[i].v[n - 1], y[i].o[n - 1], y[i].i[0], y[i].v[0], r, l, M), M = !1) : (d = bez.getNewSegment(y[i].v[n - 1], y[i].v[0], y[i].o[n - 1], y[i].i[0], (e.s - x) / S, (e.e - x) / S, c[n - 1]), this.addSegmentFromArray(d, r, l, M), M = !1, r.c = !1)
                            } else r.c = !1;
                            x += h.addedLength, l += 1
                        }
                        if (r._length && (r.setXYAt(r.v[m][0], r.v[m][1], "i", m), r.setXYAt(r.v[r._length - 1][0], r.v[r._length - 1][1], "o", r._length - 1)), x > e.e) break;
                        i < v - 1 && (r = shapePool.newElement(), M = !0, _.push(r), l = 0)
                    }
                    return _
                }, ShapeModifiers.registerModifier("tm", TrimModifier), extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function (t, data) {
                    this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(t, data.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length
                }, RoundCornersModifier.prototype.processPath = function (path, t) {
                    var i, e = shapePool.newElement();
                    e.c = path.c;
                    var r, n, o, h, l, c, d, m, f, y, v, x, _ = path._length,
                        M = 0;
                    for (i = 0; i < _; i += 1) r = path.v[i], o = path.o[i], n = path.i[i], r[0] === o[0] && r[1] === o[1] && r[0] === n[0] && r[1] === n[1] ? 0 !== i && i !== _ - 1 || path.c ? (h = 0 === i ? path.v[_ - 1] : path.v[i - 1], c = (l = Math.sqrt(Math.pow(r[0] - h[0], 2) + Math.pow(r[1] - h[1], 2))) ? Math.min(l / 2, t) / l : 0, d = v = r[0] + (h[0] - r[0]) * c, m = x = r[1] - (r[1] - h[1]) * c, f = d - (d - r[0]) * roundCorner, y = m - (m - r[1]) * roundCorner, e.setTripleAt(d, m, f, y, v, x, M), M += 1, h = i === _ - 1 ? path.v[0] : path.v[i + 1], c = (l = Math.sqrt(Math.pow(r[0] - h[0], 2) + Math.pow(r[1] - h[1], 2))) ? Math.min(l / 2, t) / l : 0, d = f = r[0] + (h[0] - r[0]) * c, m = y = r[1] + (h[1] - r[1]) * c, v = d - (d - r[0]) * roundCorner, x = m - (m - r[1]) * roundCorner, e.setTripleAt(d, m, f, y, v, x, M), M += 1) : (e.setTripleAt(r[0], r[1], o[0], o[1], n[0], n[1], M), M += 1) : (e.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], M), M += 1);
                    return e
                }, RoundCornersModifier.prototype.processShapes = function (t) {
                    var e, i, r, n, o, h, l = this.shapes.length,
                        c = this.rd.v;
                    if (0 !== c)
                        for (i = 0; i < l; i += 1) {
                            if (h = (o = this.shapes[i]).localShapeCollection, o.shape._mdf || this._mdf || t)
                                for (h.releaseShapes(), o.shape._mdf = !0, e = o.shape.paths.shapes, n = o.shape.paths._length, r = 0; r < n; r += 1) h.addShape(this.processPath(e[r], c));
                            o.shape.paths = o.localShapeCollection
                        }
                    this.dynamicProperties.length || (this._mdf = !1)
                }, ShapeModifiers.registerModifier("rd", RoundCornersModifier), extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function (t, data) {
                    this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(t, data.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length
                }, PuckerAndBloatModifier.prototype.processPath = function (path, t) {
                    var e = t / 100,
                        r = [0, 0],
                        n = path._length,
                        i = 0;
                    for (i = 0; i < n; i += 1) r[0] += path.v[i][0], r[1] += path.v[i][1];
                    r[0] /= n, r[1] /= n;
                    var o, h, l, c, d, m, f = shapePool.newElement();
                    for (f.c = path.c, i = 0; i < n; i += 1) o = path.v[i][0] + (r[0] - path.v[i][0]) * e, h = path.v[i][1] + (r[1] - path.v[i][1]) * e, l = path.o[i][0] + (r[0] - path.o[i][0]) * -e, c = path.o[i][1] + (r[1] - path.o[i][1]) * -e, d = path.i[i][0] + (r[0] - path.i[i][0]) * -e, m = path.i[i][1] + (r[1] - path.i[i][1]) * -e, f.setTripleAt(o, h, l, c, d, m, i);
                    return f
                }, PuckerAndBloatModifier.prototype.processShapes = function (t) {
                    var e, i, r, n, o, h, l = this.shapes.length,
                        c = this.amount.v;
                    if (0 !== c)
                        for (i = 0; i < l; i += 1) {
                            if (h = (o = this.shapes[i]).localShapeCollection, o.shape._mdf || this._mdf || t)
                                for (h.releaseShapes(), o.shape._mdf = !0, e = o.shape.paths.shapes, n = o.shape.paths._length, r = 0; r < n; r += 1) h.addShape(this.processPath(e[r], c));
                            o.shape.paths = o.localShapeCollection
                        }
                    this.dynamicProperties.length || (this._mdf = !1)
                }, ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function (t, data) {
                    this.getValue = this.processKeys, this.c = PropertyFactory.getProp(t, data.c, 0, null, this), this.o = PropertyFactory.getProp(t, data.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(t, data.tr, this), this.so = PropertyFactory.getProp(t, data.tr.so, 0, .01, this), this.eo = PropertyFactory.getProp(t, data.tr.eo, 0, .01, this), this.data = data, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix, this.rMatrix = new Matrix, this.sMatrix = new Matrix, this.tMatrix = new Matrix, this.matrix = new Matrix
                }, RepeaterModifier.prototype.applyTransforms = function (t, e, r, n, o, h) {
                    var l = h ? -1 : 1,
                        c = n.s.v[0] + (1 - n.s.v[0]) * (1 - o),
                        d = n.s.v[1] + (1 - n.s.v[1]) * (1 - o);
                    t.translate(n.p.v[0] * l * o, n.p.v[1] * l * o, n.p.v[2]), e.translate(-n.a.v[0], -n.a.v[1], n.a.v[2]), e.rotate(-n.r.v * l * o), e.translate(n.a.v[0], n.a.v[1], n.a.v[2]), r.translate(-n.a.v[0], -n.a.v[1], n.a.v[2]), r.scale(h ? 1 / c : c, h ? 1 / d : d), r.translate(n.a.v[0], n.a.v[1], n.a.v[2])
                }, RepeaterModifier.prototype.init = function (t, e, r, n) {
                    for (this.elem = t, this.arr = e, this.pos = r, this.elemsData = n, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(t), this.initModifierProperties(t, e[r]); r > 0;) r -= 1, this._elements.unshift(e[r]);
                    this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
                }, RepeaterModifier.prototype.resetElements = function (t) {
                    var i, e = t.length;
                    for (i = 0; i < e; i += 1) t[i]._processed = !1, "gr" === t[i].ty && this.resetElements(t[i].it)
                }, RepeaterModifier.prototype.cloneElements = function (t) {
                    var e = JSON.parse(JSON.stringify(t));
                    return this.resetElements(e), e
                }, RepeaterModifier.prototype.changeGroupRender = function (t, e) {
                    var i, r = t.length;
                    for (i = 0; i < r; i += 1) t[i]._render = e, "gr" === t[i].ty && this.changeGroupRender(t[i].it, e)
                }, RepeaterModifier.prototype.processShapes = function (t) {
                    var e, r, i, n, o, h = !1;
                    if (this._mdf || t) {
                        var l, c = Math.ceil(this.c.v);
                        if (this._groups.length < c) {
                            for (; this._groups.length < c;) {
                                var d = {
                                    it: this.cloneElements(this._elements),
                                    ty: "gr"
                                };
                                d.it.push({
                                    a: {
                                        a: 0,
                                        ix: 1,
                                        k: [0, 0]
                                    },
                                    nm: "Transform",
                                    o: {
                                        a: 0,
                                        ix: 7,
                                        k: 100
                                    },
                                    p: {
                                        a: 0,
                                        ix: 2,
                                        k: [0, 0]
                                    },
                                    r: {
                                        a: 1,
                                        ix: 6,
                                        k: [{
                                            s: 0,
                                            e: 0,
                                            t: 0
                                        }, {
                                            s: 0,
                                            e: 0,
                                            t: 1
                                        }]
                                    },
                                    s: {
                                        a: 0,
                                        ix: 3,
                                        k: [100, 100]
                                    },
                                    sa: {
                                        a: 0,
                                        ix: 5,
                                        k: 0
                                    },
                                    sk: {
                                        a: 0,
                                        ix: 4,
                                        k: 0
                                    },
                                    ty: "tr"
                                }), this.arr.splice(0, 0, d), this._groups.splice(0, 0, d), this._currentCopies += 1
                            }
                            this.elem.reloadShapes(), h = !0
                        }
                        for (o = 0, i = 0; i <= this._groups.length - 1; i += 1) {
                            if (l = o < c, this._groups[i]._render = l, this.changeGroupRender(this._groups[i].it, l), !l) {
                                var m = this.elemsData[i].it,
                                    f = m[m.length - 1];
                                0 !== f.transform.op.v ? (f.transform.op._mdf = !0, f.transform.op.v = 0) : f.transform.op._mdf = !1
                            }
                            o += 1
                        }
                        this._currentCopies = c;
                        var y = this.o.v,
                            v = y % 1,
                            x = y > 0 ? Math.floor(y) : Math.ceil(y),
                            _ = this.pMatrix.props,
                            M = this.rMatrix.props,
                            S = this.sMatrix.props;
                        this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset();
                        var w, E, T = 0;
                        if (y > 0) {
                            for (; T < x;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), T += 1;
                            v && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, v, !1), T += v)
                        } else if (y < 0) {
                            for (; T > x;) this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), T -= 1;
                            v && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -v, !0), T -= v)
                        }
                        for (i = 1 === this.data.m ? 0 : this._currentCopies - 1, n = 1 === this.data.m ? 1 : -1, o = this._currentCopies; o;) {
                            if (E = (r = (e = this.elemsData[i].it)[e.length - 1].transform.mProps.v.props).length, e[e.length - 1].transform.mProps._mdf = !0, e[e.length - 1].transform.op._mdf = !0, e[e.length - 1].transform.op.v = 1 === this._currentCopies ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1)), 0 !== T) {
                                for ((0 !== i && 1 === n || i !== this._currentCopies - 1 && -1 === n) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(M[0], M[1], M[2], M[3], M[4], M[5], M[6], M[7], M[8], M[9], M[10], M[11], M[12], M[13], M[14], M[15]), this.matrix.transform(S[0], S[1], S[2], S[3], S[4], S[5], S[6], S[7], S[8], S[9], S[10], S[11], S[12], S[13], S[14], S[15]), this.matrix.transform(_[0], _[1], _[2], _[3], _[4], _[5], _[6], _[7], _[8], _[9], _[10], _[11], _[12], _[13], _[14], _[15]), w = 0; w < E; w += 1) r[w] = this.matrix.props[w];
                                this.matrix.reset()
                            } else
                                for (this.matrix.reset(), w = 0; w < E; w += 1) r[w] = this.matrix.props[w];
                            T += 1, o -= 1, i += n
                        }
                    } else
                        for (o = this._currentCopies, i = 0, n = 1; o;) r = (e = this.elemsData[i].it)[e.length - 1].transform.mProps.v.props, e[e.length - 1].transform.mProps._mdf = !1, e[e.length - 1].transform.op._mdf = !1, o -= 1, i += n;
                    return h
                }, RepeaterModifier.prototype.addShape = function () {}, ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeCollection.prototype.addShape = function (t) {
                    this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = t, this._length += 1
                }, ShapeCollection.prototype.releaseShapes = function () {
                    var i;
                    for (i = 0; i < this._length; i += 1) shapePool.release(this.shapes[i]);
                    this._length = 0
                }, DashProperty.prototype.getValue = function (t) {
                    if ((this.elem.globalData.frameId !== this.frameId || t) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || t, this._mdf)) {
                        var i = 0,
                            e = this.dataProps.length;
                        for ("svg" === this.renderer && (this.dashStr = ""), i = 0; i < e; i += 1) "o" !== this.dataProps[i].n ? "svg" === this.renderer ? this.dashStr += " " + this.dataProps[i].p.v : this.dashArray[i] = this.dataProps[i].p.v : this.dashoffset[0] = this.dataProps[i].p.v
                    }
                }, extendPrototype([DynamicPropertyContainer], DashProperty), GradientProperty.prototype.comparePoints = function (t, e) {
                    for (var i = 0, r = this.o.length / 2; i < r;) {
                        if (Math.abs(t[4 * i] - t[4 * e + 2 * i]) > .01) return !1;
                        i += 1
                    }
                    return !0
                }, GradientProperty.prototype.checkCollapsable = function () {
                    if (this.o.length / 2 != this.c.length / 4) return !1;
                    if (this.data.k.k[0].s)
                        for (var i = 0, t = this.data.k.k.length; i < t;) {
                            if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) return !1;
                            i += 1
                        } else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1;
                    return !0
                }, GradientProperty.prototype.getValue = function (t) {
                    if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || t) {
                        var i, e, r, n = 4 * this.data.p;
                        for (i = 0; i < n; i += 1) e = i % 4 == 0 ? 100 : 255, r = Math.round(this.prop.v[i] * e), this.c[i] !== r && (this.c[i] = r, this._cmdf = !t);
                        if (this.o.length)
                            for (n = this.prop.v.length, i = 4 * this.data.p; i < n; i += 1) e = i % 2 == 0 ? 100 : 1, r = i % 2 == 0 ? Math.round(100 * this.prop.v[i]) : this.prop.v[i], this.o[i - 4 * this.data.p] !== r && (this.o[i - 4 * this.data.p] = r, this._omdf = !t);
                        this._mdf = !t
                    }
                }, extendPrototype([DynamicPropertyContainer], GradientProperty);
                var buildShapeString = function (t, e, r, n) {
                        if (0 === e) return "";
                        var i, o = t.o,
                            h = t.i,
                            l = t.v,
                            c = " M" + n.applyToPointStringified(l[0][0], l[0][1]);
                        for (i = 1; i < e; i += 1) c += " C" + n.applyToPointStringified(o[i - 1][0], o[i - 1][1]) + " " + n.applyToPointStringified(h[i][0], h[i][1]) + " " + n.applyToPointStringified(l[i][0], l[i][1]);
                        return r && e && (c += " C" + n.applyToPointStringified(o[i - 1][0], o[i - 1][1]) + " " + n.applyToPointStringified(h[0][0], h[0][1]) + " " + n.applyToPointStringified(l[0][0], l[0][1]), c += "z"), c
                    },
                    audioControllerFactory = function () {
                        function t(t) {
                            this.audios = [], this.audioFactory = t, this._volume = 1, this._isMuted = !1
                        }
                        return t.prototype = {
                                addAudio: function (audio) {
                                    this.audios.push(audio)
                                },
                                pause: function () {
                                    var i, t = this.audios.length;
                                    for (i = 0; i < t; i += 1) this.audios[i].pause()
                                },
                                resume: function () {
                                    var i, t = this.audios.length;
                                    for (i = 0; i < t; i += 1) this.audios[i].resume()
                                },
                                setRate: function (t) {
                                    var i, e = this.audios.length;
                                    for (i = 0; i < e; i += 1) this.audios[i].setRate(t)
                                },
                                createAudio: function (t) {
                                    return this.audioFactory ? this.audioFactory(t) : Howl ? new Howl({
                                        src: [t]
                                    }) : {
                                        isPlaying: !1,
                                        play: function () {
                                            this.isPlaying = !0
                                        },
                                        seek: function () {
                                            this.isPlaying = !1
                                        },
                                        playing: function () {},
                                        rate: function () {},
                                        setVolume: function () {}
                                    }
                                },
                                setAudioFactory: function (t) {
                                    this.audioFactory = t
                                },
                                setVolume: function (t) {
                                    this._volume = t, this._updateVolume()
                                },
                                mute: function () {
                                    this._isMuted = !0, this._updateVolume()
                                },
                                unmute: function () {
                                    this._isMuted = !1, this._updateVolume()
                                },
                                getVolume: function () {
                                    return this._volume
                                },
                                _updateVolume: function () {
                                    var i, t = this.audios.length;
                                    for (i = 0; i < t; i += 1) this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1))
                                }
                            },
                            function () {
                                return new t
                            }
                    }(),
                    ImagePreloader = function () {
                        var t = function () {
                            var canvas = createTag("canvas");
                            canvas.width = 1, canvas.height = 1;
                            var t = canvas.getContext("2d");
                            return t.fillStyle = "rgba(0,0,0,0)", t.fillRect(0, 0, 1, 1), canvas
                        }();

                        function e() {
                            this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
                        }

                        function r() {
                            this.loadedFootagesCount += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
                        }

                        function n(t, e, r) {
                            var path = "";
                            if (t.e) path = t.p;
                            else if (e) {
                                var n = t.p; - 1 !== n.indexOf("images/") && (n = n.split("/")[1]), path = e + n
                            } else path = r, path += t.u ? t.u : "", path += t.p;
                            return path
                        }

                        function o(img) {
                            var t = 0,
                                e = setInterval(function () {
                                    (img.getBBox().width || t > 500) && (this._imageLoaded(), clearInterval(e)), t += 1
                                }.bind(this), 50)
                        }

                        function h(data) {
                            var t = {
                                    assetData: data
                                },
                                path = n(data, this.assetsPath, this.path);
                            return assetLoader.load(path, function (e) {
                                t.img = e, this._footageLoaded()
                            }.bind(this), function () {
                                t.img = {}, this._footageLoaded()
                            }.bind(this)), t
                        }

                        function l() {
                            this._imageLoaded = e.bind(this), this._footageLoaded = r.bind(this), this.testImageLoaded = o.bind(this), this.createFootageData = h.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.totalFootages = 0, this.loadedAssets = 0, this.loadedFootagesCount = 0, this.imagesLoadedCb = null, this.images = []
                        }
                        return l.prototype = {
                            loadAssets: function (t, e) {
                                var i;
                                this.imagesLoadedCb = e;
                                var r = t.length;
                                for (i = 0; i < r; i += 1) t[i].layers || (t[i].t && "seq" !== t[i].t ? 3 === t[i].t && (this.totalFootages += 1, this.images.push(this.createFootageData(t[i]))) : (this.totalImages += 1, this.images.push(this._createImageData(t[i]))))
                            },
                            setAssetsPath: function (path) {
                                this.assetsPath = path || ""
                            },
                            setPath: function (path) {
                                this.path = path || ""
                            },
                            loadedImages: function () {
                                return this.totalImages === this.loadedAssets
                            },
                            loadedFootages: function () {
                                return this.totalFootages === this.loadedFootagesCount
                            },
                            destroy: function () {
                                this.imagesLoadedCb = null, this.images.length = 0
                            },
                            getAsset: function (t) {
                                for (var i = 0, e = this.images.length; i < e;) {
                                    if (this.images[i].assetData === t) return this.images[i].img;
                                    i += 1
                                }
                                return null
                            },
                            createImgData: function (e) {
                                var path = n(e, this.assetsPath, this.path),
                                    img = createTag("img");
                                img.crossOrigin = "anonymous", img.addEventListener("load", this._imageLoaded, !1), img.addEventListener("error", function () {
                                    r.img = t, this._imageLoaded()
                                }.bind(this), !1), img.src = path;
                                var r = {
                                    img: img,
                                    assetData: e
                                };
                                return r
                            },
                            createImageData: function (e) {
                                var path = n(e, this.assetsPath, this.path),
                                    img = createNS("image");
                                isSafari ? this.testImageLoaded(img) : img.addEventListener("load", this._imageLoaded, !1), img.addEventListener("error", function () {
                                    r.img = t, this._imageLoaded()
                                }.bind(this), !1), img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path), this._elementHelper.append ? this._elementHelper.append(img) : this._elementHelper.appendChild(img);
                                var r = {
                                    img: img,
                                    assetData: e
                                };
                                return r
                            },
                            imageLoaded: e,
                            footageLoaded: r,
                            setCacheType: function (t, e) {
                                "svg" === t ? (this._elementHelper = e, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this)
                            }
                        }, l
                    }(),
                    featureSupport = function () {
                        var t = {
                            maskType: !0
                        };
                        return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (t.maskType = !1), t
                    }(),
                    filtersFactory = function () {
                        var t = {
                            createFilter: function (t, e) {
                                var r = createNS("filter");
                                return r.setAttribute("id", t), !0 !== e && (r.setAttribute("filterUnits", "objectBoundingBox"), r.setAttribute("x", "0%"), r.setAttribute("y", "0%"), r.setAttribute("width", "100%"), r.setAttribute("height", "100%")), r
                            },
                            createAlphaToLuminanceFilter: function () {
                                var t = createNS("feColorMatrix");
                                return t.setAttribute("type", "matrix"), t.setAttribute("color-interpolation-filters", "sRGB"), t.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), t
                            }
                        };
                        return t
                    }(),
                    assetLoader = function () {
                        function t(t) {
                            return t.response && "object" == typeof t.response ? t.response : t.response && "string" == typeof t.response ? JSON.parse(t.response) : t.responseText ? JSON.parse(t.responseText) : null
                        }
                        return {
                            load: function (path, e, r) {
                                var n, o = new XMLHttpRequest;
                                try {
                                    o.responseType = "json"
                                } catch (t) {}
                                o.onreadystatechange = function () {
                                    if (4 === o.readyState)
                                        if (200 === o.status) n = t(o), e(n);
                                        else try {
                                            n = t(o), e(n)
                                        } catch (t) {
                                            r && r(t)
                                        }
                                }, o.open("GET", path, !0), o.send()
                            }
                        }
                    }();

                function TextAnimatorProperty(t, e, r) {
                    this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = t, this._renderType = e, this._elem = r, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = {
                        alignment: {}
                    }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(r)
                }

                function TextAnimatorDataProperty(t, e, r) {
                    var n = {
                            propType: !1
                        },
                        o = PropertyFactory.getProp,
                        h = e.a;
                    this.a = {
                        r: h.r ? o(t, h.r, 0, degToRads, r) : n,
                        rx: h.rx ? o(t, h.rx, 0, degToRads, r) : n,
                        ry: h.ry ? o(t, h.ry, 0, degToRads, r) : n,
                        sk: h.sk ? o(t, h.sk, 0, degToRads, r) : n,
                        sa: h.sa ? o(t, h.sa, 0, degToRads, r) : n,
                        s: h.s ? o(t, h.s, 1, .01, r) : n,
                        a: h.a ? o(t, h.a, 1, 0, r) : n,
                        o: h.o ? o(t, h.o, 0, .01, r) : n,
                        p: h.p ? o(t, h.p, 1, 0, r) : n,
                        sw: h.sw ? o(t, h.sw, 0, 0, r) : n,
                        sc: h.sc ? o(t, h.sc, 1, 0, r) : n,
                        fc: h.fc ? o(t, h.fc, 1, 0, r) : n,
                        fh: h.fh ? o(t, h.fh, 0, 0, r) : n,
                        fs: h.fs ? o(t, h.fs, 0, .01, r) : n,
                        fb: h.fb ? o(t, h.fb, 0, .01, r) : n,
                        t: h.t ? o(t, h.t, 0, 0, r) : n
                    }, this.s = TextSelectorProp.getTextSelectorProp(t, e.s, r), this.s.t = e.s.t
                }

                function LetterProps(t, e, r, n, o, p) {
                    this.o = t, this.sw = e, this.sc = r, this.fc = n, this.m = o, this.p = p, this._mdf = {
                        o: !0,
                        sw: !!e,
                        sc: !!r,
                        fc: !!n,
                        m: !0,
                        p: !0
                    }
                }

                function TextProperty(t, data) {
                    this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, this.data = data, this.elem = t, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = {
                        ascent: 0,
                        boxWidth: this.defaultBoxWidth,
                        f: "",
                        fStyle: "",
                        fWeight: "",
                        fc: "",
                        j: "",
                        justifyOffset: "",
                        l: [],
                        lh: 0,
                        lineWidths: [],
                        ls: "",
                        of: "",
                        s: "",
                        sc: "",
                        sw: 0,
                        t: 0,
                        tr: 0,
                        sz: 0,
                        ps: null,
                        fillColorAnim: !1,
                        strokeColorAnim: !1,
                        strokeWidthAnim: !1,
                        yOffset: 0,
                        finalSize: 0,
                        finalText: [],
                        finalLineHeight: 0,
                        __complete: !1
                    }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData)
                }
                TextAnimatorProperty.prototype.searchProperties = function () {
                    var i, t, e = this._textData.a.length,
                        r = PropertyFactory.getProp;
                    for (i = 0; i < e; i += 1) t = this._textData.a[i], this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, t, this);
                    this._textData.p && "m" in this._textData.p ? (this._pathData = {
                        f: r(this._elem, this._textData.p.f, 0, 0, this),
                        l: r(this._elem, this._textData.p.l, 0, 0, this),
                        r: this._textData.p.r,
                        m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
                    }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = r(this._elem, this._textData.m.a, 1, 0, this)
                }, TextAnimatorProperty.prototype.getMeasures = function (t, e) {
                    if (this.lettersChangedFlag = e, this._mdf || this._isFirstFrame || e || this._hasMaskedPath && this._pathData.m._mdf) {
                        this._isFirstFrame = !1;
                        var r, n, i, o, h, l, c, d, m, f, y, v, x, _, M, S, w, E, mask, T = this._moreOptions.alignment.v,
                            A = this._animatorsData,
                            P = this._textData,
                            C = this.mHelper,
                            L = this._renderType,
                            D = this.renderedLetters.length,
                            R = t.l;
                        if (this._hasMaskedPath) {
                            if (mask = this._pathData.m, !this._pathData.n || this._pathData._mdf) {
                                var I, F = mask.v;
                                for (this._pathData.r && (F = F.reverse()), h = {
                                        tLength: 0,
                                        segments: []
                                    }, o = F._length - 1, S = 0, i = 0; i < o; i += 1) I = bez.buildBezierData(F.v[i], F.v[i + 1], [F.o[i][0] - F.v[i][0], F.o[i][1] - F.v[i][1]], [F.i[i + 1][0] - F.v[i + 1][0], F.i[i + 1][1] - F.v[i + 1][1]]), h.tLength += I.segmentLength, h.segments.push(I), S += I.segmentLength;
                                i = o, mask.v.c && (I = bez.buildBezierData(F.v[i], F.v[0], [F.o[i][0] - F.v[i][0], F.o[i][1] - F.v[i][1]], [F.i[0][0] - F.v[0][0], F.i[0][1] - F.v[0][1]]), h.tLength += I.segmentLength, h.segments.push(I), S += I.segmentLength), this._pathData.pi = h
                            }
                            if (h = this._pathData.pi, l = this._pathData.f.v, y = 0, f = 1, d = 0, m = !0, _ = h.segments, l < 0 && mask.v.c)
                                for (h.tLength < Math.abs(l) && (l = -Math.abs(l) % h.tLength), f = (x = _[y = _.length - 1].points).length - 1; l < 0;) l += x[f].partialLength, (f -= 1) < 0 && (f = (x = _[y -= 1].points).length - 1);
                            v = (x = _[y].points)[f - 1], M = (c = x[f]).partialLength
                        }
                        o = R.length, r = 0, n = 0;
                        var k, N, B, z, V, O = 1.2 * t.finalSize * .714,
                            G = !0;
                        B = A.length;
                        var H, U, W, j, X, Y, J, Z, K, Q, $, tt, et = -1,
                            it = l,
                            nt = y,
                            st = f,
                            at = -1,
                            ot = "",
                            ht = this.defaultPropsArray;
                        if (2 === t.j || 1 === t.j) {
                            var lt = 0,
                                ct = 0,
                                pt = 2 === t.j ? -.5 : -1,
                                ut = 0,
                                mt = !0;
                            for (i = 0; i < o; i += 1)
                                if (R[i].n) {
                                    for (lt && (lt += ct); ut < i;) R[ut].animatorJustifyOffset = lt, ut += 1;
                                    lt = 0, mt = !0
                                } else {
                                    for (N = 0; N < B; N += 1)(k = A[N].a).t.propType && (mt && 2 === t.j && (ct += k.t.v * pt), (V = A[N].s.getMult(R[i].anIndexes[N], P.a[N].s.totalChars)).length ? lt += k.t.v * V[0] * pt : lt += k.t.v * V * pt);
                                    mt = !1
                                } for (lt && (lt += ct); ut < i;) R[ut].animatorJustifyOffset = lt, ut += 1
                        }
                        for (i = 0; i < o; i += 1) {
                            if (C.reset(), j = 1, R[i].n) r = 0, n += t.yOffset, n += G ? 1 : 0, l = it, G = !1, this._hasMaskedPath && (f = st, v = (x = _[y = nt].points)[f - 1], M = (c = x[f]).partialLength, d = 0), ot = "", $ = "", K = "", tt = "", ht = this.defaultPropsArray;
                            else {
                                if (this._hasMaskedPath) {
                                    if (at !== R[i].line) {
                                        switch (t.j) {
                                            case 1:
                                                l += S - t.lineWidths[R[i].line];
                                                break;
                                            case 2:
                                                l += (S - t.lineWidths[R[i].line]) / 2
                                        }
                                        at = R[i].line
                                    }
                                    et !== R[i].ind && (R[et] && (l += R[et].extra), l += R[i].an / 2, et = R[i].ind), l += T[0] * R[i].an * .005;
                                    var ft = 0;
                                    for (N = 0; N < B; N += 1)(k = A[N].a).p.propType && ((V = A[N].s.getMult(R[i].anIndexes[N], P.a[N].s.totalChars)).length ? ft += k.p.v[0] * V[0] : ft += k.p.v[0] * V), k.a.propType && ((V = A[N].s.getMult(R[i].anIndexes[N], P.a[N].s.totalChars)).length ? ft += k.a.v[0] * V[0] : ft += k.a.v[0] * V);
                                    for (m = !0; m;) d + M >= l + ft || !x ? (w = (l + ft - d) / c.partialLength, U = v.point[0] + (c.point[0] - v.point[0]) * w, W = v.point[1] + (c.point[1] - v.point[1]) * w, C.translate(-T[0] * R[i].an * .005, -T[1] * O * .01), m = !1) : x && (d += c.partialLength, (f += 1) >= x.length && (f = 0, _[y += 1] ? x = _[y].points : mask.v.c ? (f = 0, x = _[y = 0].points) : (d -= c.partialLength, x = null)), x && (v = c, M = (c = x[f]).partialLength));
                                    H = R[i].an / 2 - R[i].add, C.translate(-H, 0, 0)
                                } else H = R[i].an / 2 - R[i].add, C.translate(-H, 0, 0), C.translate(-T[0] * R[i].an * .005, -T[1] * O * .01, 0);
                                for (N = 0; N < B; N += 1)(k = A[N].a).t.propType && (V = A[N].s.getMult(R[i].anIndexes[N], P.a[N].s.totalChars), 0 === r && 0 === t.j || (this._hasMaskedPath ? V.length ? l += k.t.v * V[0] : l += k.t.v * V : V.length ? r += k.t.v * V[0] : r += k.t.v * V));
                                for (t.strokeWidthAnim && (Y = t.sw || 0), t.strokeColorAnim && (X = t.sc ? [t.sc[0], t.sc[1], t.sc[2]] : [0, 0, 0]), t.fillColorAnim && t.fc && (J = [t.fc[0], t.fc[1], t.fc[2]]), N = 0; N < B; N += 1)(k = A[N].a).a.propType && ((V = A[N].s.getMult(R[i].anIndexes[N], P.a[N].s.totalChars)).length ? C.translate(-k.a.v[0] * V[0], -k.a.v[1] * V[1], k.a.v[2] * V[2]) : C.translate(-k.a.v[0] * V, -k.a.v[1] * V, k.a.v[2] * V));
                                for (N = 0; N < B; N += 1)(k = A[N].a).s.propType && ((V = A[N].s.getMult(R[i].anIndexes[N], P.a[N].s.totalChars)).length ? C.scale(1 + (k.s.v[0] - 1) * V[0], 1 + (k.s.v[1] - 1) * V[1], 1) : C.scale(1 + (k.s.v[0] - 1) * V, 1 + (k.s.v[1] - 1) * V, 1));
                                for (N = 0; N < B; N += 1) {
                                    if (k = A[N].a, V = A[N].s.getMult(R[i].anIndexes[N], P.a[N].s.totalChars), k.sk.propType && (V.length ? C.skewFromAxis(-k.sk.v * V[0], k.sa.v * V[1]) : C.skewFromAxis(-k.sk.v * V, k.sa.v * V)), k.r.propType && (V.length ? C.rotateZ(-k.r.v * V[2]) : C.rotateZ(-k.r.v * V)), k.ry.propType && (V.length ? C.rotateY(k.ry.v * V[1]) : C.rotateY(k.ry.v * V)), k.rx.propType && (V.length ? C.rotateX(k.rx.v * V[0]) : C.rotateX(k.rx.v * V)), k.o.propType && (V.length ? j += (k.o.v * V[0] - j) * V[0] : j += (k.o.v * V - j) * V), t.strokeWidthAnim && k.sw.propType && (V.length ? Y += k.sw.v * V[0] : Y += k.sw.v * V), t.strokeColorAnim && k.sc.propType)
                                        for (Z = 0; Z < 3; Z += 1) V.length ? X[Z] += (k.sc.v[Z] - X[Z]) * V[0] : X[Z] += (k.sc.v[Z] - X[Z]) * V;
                                    if (t.fillColorAnim && t.fc) {
                                        if (k.fc.propType)
                                            for (Z = 0; Z < 3; Z += 1) V.length ? J[Z] += (k.fc.v[Z] - J[Z]) * V[0] : J[Z] += (k.fc.v[Z] - J[Z]) * V;
                                        k.fh.propType && (J = V.length ? addHueToRGB(J, k.fh.v * V[0]) : addHueToRGB(J, k.fh.v * V)), k.fs.propType && (J = V.length ? addSaturationToRGB(J, k.fs.v * V[0]) : addSaturationToRGB(J, k.fs.v * V)), k.fb.propType && (J = V.length ? addBrightnessToRGB(J, k.fb.v * V[0]) : addBrightnessToRGB(J, k.fb.v * V))
                                    }
                                }
                                for (N = 0; N < B; N += 1)(k = A[N].a).p.propType && (V = A[N].s.getMult(R[i].anIndexes[N], P.a[N].s.totalChars), this._hasMaskedPath ? V.length ? C.translate(0, k.p.v[1] * V[0], -k.p.v[2] * V[1]) : C.translate(0, k.p.v[1] * V, -k.p.v[2] * V) : V.length ? C.translate(k.p.v[0] * V[0], k.p.v[1] * V[1], -k.p.v[2] * V[2]) : C.translate(k.p.v[0] * V, k.p.v[1] * V, -k.p.v[2] * V));
                                if (t.strokeWidthAnim && (K = Y < 0 ? 0 : Y), t.strokeColorAnim && (Q = "rgb(" + Math.round(255 * X[0]) + "," + Math.round(255 * X[1]) + "," + Math.round(255 * X[2]) + ")"), t.fillColorAnim && t.fc && ($ = "rgb(" + Math.round(255 * J[0]) + "," + Math.round(255 * J[1]) + "," + Math.round(255 * J[2]) + ")"), this._hasMaskedPath) {
                                    if (C.translate(0, -t.ls), C.translate(0, T[1] * O * .01 + n, 0), P.p.p) {
                                        E = (c.point[1] - v.point[1]) / (c.point[0] - v.point[0]);
                                        var gt = 180 * Math.atan(E) / Math.PI;
                                        c.point[0] < v.point[0] && (gt += 180), C.rotate(-gt * Math.PI / 180)
                                    }
                                    C.translate(U, W, 0), l -= T[0] * R[i].an * .005, R[i + 1] && et !== R[i + 1].ind && (l += R[i].an / 2, l += .001 * t.tr * t.finalSize)
                                } else {
                                    switch (C.translate(r, n, 0), t.ps && C.translate(t.ps[0], t.ps[1] + t.ascent, 0), t.j) {
                                        case 1:
                                            C.translate(R[i].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[R[i].line]), 0, 0);
                                            break;
                                        case 2:
                                            C.translate(R[i].animatorJustifyOffset + t.justifyOffset + (t.boxWidth - t.lineWidths[R[i].line]) / 2, 0, 0)
                                    }
                                    C.translate(0, -t.ls), C.translate(H, 0, 0), C.translate(T[0] * R[i].an * .005, T[1] * O * .01, 0), r += R[i].l + .001 * t.tr * t.finalSize
                                }
                                "html" === L ? ot = C.toCSS() : "svg" === L ? ot = C.to2dCSS() : ht = [C.props[0], C.props[1], C.props[2], C.props[3], C.props[4], C.props[5], C.props[6], C.props[7], C.props[8], C.props[9], C.props[10], C.props[11], C.props[12], C.props[13], C.props[14], C.props[15]], tt = j
                            }
                            D <= i ? (z = new LetterProps(tt, K, Q, $, ot, ht), this.renderedLetters.push(z), D += 1, this.lettersChangedFlag = !0) : (z = this.renderedLetters[i], this.lettersChangedFlag = z.update(tt, K, Q, $, ot, ht) || this.lettersChangedFlag)
                        }
                    }
                }, TextAnimatorProperty.prototype.getValue = function () {
                    this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties())
                }, TextAnimatorProperty.prototype.mHelper = new Matrix, TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty), LetterProps.prototype.update = function (t, e, r, n, o, p) {
                    this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1;
                    var h = !1;
                    return this.o !== t && (this.o = t, this._mdf.o = !0, h = !0), this.sw !== e && (this.sw = e, this._mdf.sw = !0, h = !0), this.sc !== r && (this.sc = r, this._mdf.sc = !0, h = !0), this.fc !== n && (this.fc = n, this._mdf.fc = !0, h = !0), this.m !== o && (this.m = o, this._mdf.m = !0, h = !0), !p.length || this.p[0] === p[0] && this.p[1] === p[1] && this.p[4] === p[4] && this.p[5] === p[5] && this.p[12] === p[12] && this.p[13] === p[13] || (this.p = p, this._mdf.p = !0, h = !0), h
                }, TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function (t, data) {
                    for (var s in data) Object.prototype.hasOwnProperty.call(data, s) && (t[s] = data[s]);
                    return t
                }, TextProperty.prototype.setCurrentData = function (data) {
                    data.__complete || this.completeTextData(data), this.currentData = data, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0
                }, TextProperty.prototype.searchProperty = function () {
                    return this.searchKeyframes()
                }, TextProperty.prototype.searchKeyframes = function () {
                    return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf
                }, TextProperty.prototype.addEffect = function (t) {
                    this.effectsSequence.push(t), this.elem.addDynamicProperty(this)
                }, TextProperty.prototype.getValue = function (t) {
                    if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length || t) {
                        this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                        var e = this.currentData,
                            r = this.keysIndex;
                        if (this.lock) this.setCurrentData(this.currentData);
                        else {
                            var i;
                            this.lock = !0, this._mdf = !1;
                            var n = this.effectsSequence.length,
                                o = t || this.data.d.k[this.keysIndex].s;
                            for (i = 0; i < n; i += 1) o = r !== this.keysIndex ? this.effectsSequence[i](o, o.t) : this.effectsSequence[i](this.currentData, o.t);
                            e !== o && this.setCurrentData(o), this.v = this.currentData, this.pv = this.v, this.lock = !1, this.frameId = this.elem.globalData.frameId
                        }
                    }
                }, TextProperty.prototype.getKeyframeValue = function () {
                    for (var t = this.data.d.k, e = this.elem.comp.renderedFrame, i = 0, r = t.length; i <= r - 1 && !(i === r - 1 || t[i + 1].t > e);) i += 1;
                    return this.keysIndex !== i && (this.keysIndex = i), this.data.d.k[this.keysIndex].s
                }, TextProperty.prototype.buildFinalText = function (text) {
                    for (var t, e, r = [], i = 0, n = text.length, o = !1; i < n;) t = text.charCodeAt(i), FontManager.isCombinedCharacter(t) ? r[r.length - 1] += text.charAt(i) : t >= 55296 && t <= 56319 ? (e = text.charCodeAt(i + 1)) >= 56320 && e <= 57343 ? (o || FontManager.isModifier(t, e) ? (r[r.length - 1] += text.substr(i, 2), o = !1) : r.push(text.substr(i, 2)), i += 1) : r.push(text.charAt(i)) : t > 56319 ? (e = text.charCodeAt(i + 1), FontManager.isZeroWidthJoiner(t, e) ? (o = !0, r[r.length - 1] += text.substr(i, 2), i += 1) : r.push(text.charAt(i))) : FontManager.isZeroWidthJoiner(t) ? (r[r.length - 1] += text.charAt(i), o = !0) : r.push(text.charAt(i)), i += 1;
                    return r
                }, TextProperty.prototype.completeTextData = function (t) {
                    t.__complete = !0;
                    var i, e, r, n, o, h, l, c = this.elem.globalData.fontManager,
                        data = this.data,
                        d = [],
                        m = 0,
                        f = data.m.g,
                        y = 0,
                        v = 0,
                        x = 0,
                        _ = [],
                        M = 0,
                        S = 0,
                        w = c.getFontByName(t.f),
                        E = 0,
                        T = getFontProperties(w);
                    t.fWeight = T.weight, t.fStyle = T.style, t.finalSize = t.s, t.finalText = this.buildFinalText(t.t), e = t.finalText.length, t.finalLineHeight = t.lh;
                    var A, P = t.tr / 1e3 * t.finalSize;
                    if (t.sz)
                        for (var C, L, D = !0, R = t.sz[0], I = t.sz[1]; D;) {
                            C = 0, M = 0, e = (L = this.buildFinalText(t.t)).length, P = t.tr / 1e3 * t.finalSize;
                            var F = -1;
                            for (i = 0; i < e; i += 1) A = L[i].charCodeAt(0), r = !1, " " === L[i] ? F = i : 13 !== A && 3 !== A || (M = 0, r = !0, C += t.finalLineHeight || 1.2 * t.finalSize), c.chars ? (l = c.getCharData(L[i], w.fStyle, w.fFamily), E = r ? 0 : l.w * t.finalSize / 100) : E = c.measureText(L[i], t.f, t.finalSize), M + E > R && " " !== L[i] ? (-1 === F ? e += 1 : i = F, C += t.finalLineHeight || 1.2 * t.finalSize, L.splice(i, F === i ? 1 : 0, "\r"), F = -1, M = 0) : (M += E, M += P);
                            C += w.ascent * t.finalSize / 100, this.canResize && t.finalSize > this.minimumFontSize && I < C ? (t.finalSize -= 1, t.finalLineHeight = t.finalSize * t.lh / t.s) : (t.finalText = L, e = t.finalText.length, D = !1)
                        }
                    M = -P, E = 0;
                    var k, N = 0;
                    for (i = 0; i < e; i += 1)
                        if (r = !1, 13 === (A = (k = t.finalText[i]).charCodeAt(0)) || 3 === A ? (N = 0, _.push(M), S = M > S ? M : S, M = -2 * P, n = "", r = !0, x += 1) : n = k, c.chars ? (l = c.getCharData(k, w.fStyle, c.getFontByName(t.f).fFamily), E = r ? 0 : l.w * t.finalSize / 100) : E = c.measureText(n, t.f, t.finalSize), " " === k ? N += E + P : (M += E + P + N, N = 0), d.push({
                                l: E,
                                an: E,
                                add: y,
                                n: r,
                                anIndexes: [],
                                val: n,
                                line: x,
                                animatorJustifyOffset: 0
                            }), 2 == f) {
                            if (y += E, "" === n || " " === n || i === e - 1) {
                                for ("" !== n && " " !== n || (y -= E); v <= i;) d[v].an = y, d[v].ind = m, d[v].extra = E, v += 1;
                                m += 1, y = 0
                            }
                        } else if (3 == f) {
                        if (y += E, "" === n || i === e - 1) {
                            for ("" === n && (y -= E); v <= i;) d[v].an = y, d[v].ind = m, d[v].extra = E, v += 1;
                            y = 0, m += 1
                        }
                    } else d[m].ind = m, d[m].extra = 0, m += 1;
                    if (t.l = d, S = M > S ? M : S, _.push(M), t.sz) t.boxWidth = t.sz[0], t.justifyOffset = 0;
                    else switch (t.boxWidth = S, t.j) {
                        case 1:
                            t.justifyOffset = -t.boxWidth;
                            break;
                        case 2:
                            t.justifyOffset = -t.boxWidth / 2;
                            break;
                        default:
                            t.justifyOffset = 0
                    }
                    t.lineWidths = _;
                    var B, z, V, O, G = data.a;
                    h = G.length;
                    var H = [];
                    for (o = 0; o < h; o += 1) {
                        for ((B = G[o]).a.sc && (t.strokeColorAnim = !0), B.a.sw && (t.strokeWidthAnim = !0), (B.a.fc || B.a.fh || B.a.fs || B.a.fb) && (t.fillColorAnim = !0), O = 0, V = B.s.b, i = 0; i < e; i += 1)(z = d[i]).anIndexes[o] = O, (1 == V && "" !== z.val || 2 == V && "" !== z.val && " " !== z.val || 3 == V && (z.n || " " == z.val || i == e - 1) || 4 == V && (z.n || i == e - 1)) && (1 === B.s.rn && H.push(O), O += 1);
                        data.a[o].s.totalChars = O;
                        var U, W = -1;
                        if (1 === B.s.rn)
                            for (i = 0; i < e; i += 1) W != (z = d[i]).anIndexes[o] && (W = z.anIndexes[o], U = H.splice(Math.floor(Math.random() * H.length), 1)[0]), z.anIndexes[o] = U
                    }
                    t.yOffset = t.finalLineHeight || 1.2 * t.finalSize, t.ls = t.ls || 0, t.ascent = w.ascent * t.finalSize / 100
                }, TextProperty.prototype.updateDocumentData = function (t, e) {
                    e = void 0 === e ? this.keysIndex : e;
                    var r = this.copyData({}, this.data.d.k[e].s);
                    r = this.copyData(r, t), this.data.d.k[e].s = r, this.recalculate(e), this.elem.addDynamicProperty(this)
                }, TextProperty.prototype.recalculate = function (t) {
                    var e = this.data.d.k[t].s;
                    e.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(e)
                }, TextProperty.prototype.canResizeFont = function (t) {
                    this.canResize = t, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
                }, TextProperty.prototype.setMinimumFontSize = function (t) {
                    this.minimumFontSize = Math.floor(t) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this)
                };
                var TextSelectorProp = function () {
                        var t = Math.max,
                            e = Math.min,
                            r = Math.floor;

                        function n(t, data) {
                            this._currentTextLength = -1, this.k = !1, this.data = data, this.elem = t, this.comp = t.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(t), this.s = PropertyFactory.getProp(t, data.s || {
                                k: 0
                            }, 0, 0, this), this.e = "e" in data ? PropertyFactory.getProp(t, data.e, 0, 0, this) : {
                                v: 100
                            }, this.o = PropertyFactory.getProp(t, data.o || {
                                k: 0
                            }, 0, 0, this), this.xe = PropertyFactory.getProp(t, data.xe || {
                                k: 0
                            }, 0, 0, this), this.ne = PropertyFactory.getProp(t, data.ne || {
                                k: 0
                            }, 0, 0, this), this.a = PropertyFactory.getProp(t, data.a, 0, .01, this), this.dynamicProperties.length || this.getValue()
                        }
                        return n.prototype = {
                            getMult: function (n) {
                                this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
                                var o = 0,
                                    h = 0,
                                    l = 1,
                                    c = 1;
                                this.ne.v > 0 ? o = this.ne.v / 100 : h = -this.ne.v / 100, this.xe.v > 0 ? l = 1 - this.xe.v / 100 : c = 1 + this.xe.v / 100;
                                var d = BezierFactory.getBezierEasing(o, h, l, c).get,
                                    m = 0,
                                    s = this.finalS,
                                    f = this.finalE,
                                    y = this.data.sh;
                                if (2 === y) m = d(m = f === s ? n >= f ? 1 : 0 : t(0, e(.5 / (f - s) + (n - s) / (f - s), 1)));
                                else if (3 === y) m = d(m = f === s ? n >= f ? 0 : 1 : 1 - t(0, e(.5 / (f - s) + (n - s) / (f - s), 1)));
                                else if (4 === y) f === s ? m = 0 : (m = t(0, e(.5 / (f - s) + (n - s) / (f - s), 1))) < .5 ? m *= 2 : m = 1 - 2 * (m - .5), m = d(m);
                                else if (5 === y) {
                                    if (f === s) m = 0;
                                    else {
                                        var v = f - s,
                                            x = -v / 2 + (n = e(t(0, n + .5 - s), f - s)),
                                            a = v / 2;
                                        m = Math.sqrt(1 - x * x / (a * a))
                                    }
                                    m = d(m)
                                } else 6 === y ? (f === s ? m = 0 : (n = e(t(0, n + .5 - s), f - s), m = (1 + Math.cos(Math.PI + 2 * Math.PI * n / (f - s))) / 2), m = d(m)) : (n >= r(s) && (m = t(0, e(n - s < 0 ? e(f, 1) - (s - n) : f - n, 1))), m = d(m));
                                return m * this.a.v
                            },
                            getValue: function (t) {
                                this.iterateDynamicProperties(), this._mdf = t || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, t && 2 === this.data.r && (this.e.v = this._currentTextLength);
                                var e = 2 === this.data.r ? 1 : 100 / this.data.totalChars,
                                    r = this.o.v / e,
                                    s = this.s.v / e + r,
                                    n = this.e.v / e + r;
                                if (s > n) {
                                    var o = s;
                                    s = n, n = o
                                }
                                this.finalS = s, this.finalE = n
                            }
                        }, extendPrototype([DynamicPropertyContainer], n), {
                            getTextSelectorProp: function (t, data, e) {
                                return new n(t, data, e)
                            }
                        }
                    }(),
                    poolFactory = function (t, e, r) {
                        var n = 0,
                            o = t,
                            h = createSizedArray(o);
                        return {
                            newElement: function () {
                                return n ? h[n -= 1] : e()
                            },
                            release: function (element) {
                                n === o && (h = pooling.double(h), o *= 2), r && r(element), h[n] = element, n += 1
                            }
                        }
                    },
                    pooling = {
                        double: function (t) {
                            return t.concat(createSizedArray(t.length))
                        }
                    },
                    pointPool = poolFactory(8, (function () {
                        return createTypedArray("float32", 2)
                    })),
                    shapePool = (factory = poolFactory(4, (function () {
                        return new ShapePath
                    }), (function (t) {
                        var i, e = t._length;
                        for (i = 0; i < e; i += 1) pointPool.release(t.v[i]), pointPool.release(t.i[i]), pointPool.release(t.o[i]), t.v[i] = null, t.i[i] = null, t.o[i] = null;
                        t._length = 0, t.c = !1
                    })), factory.clone = function (t) {
                        var i, e = factory.newElement(),
                            r = void 0 === t._length ? t.v.length : t._length;
                        for (e.setLength(r), e.c = t.c, i = 0; i < r; i += 1) e.setTripleAt(t.v[i][0], t.v[i][1], t.o[i][0], t.o[i][1], t.i[i][0], t.i[i][1], i);
                        return e
                    }, factory),
                    factory, shapeCollectionPool = function () {
                        var t = {
                                newShapeCollection: function () {
                                    return e ? n[e -= 1] : new ShapeCollection
                                },
                                release: function (t) {
                                    var i, o = t._length;
                                    for (i = 0; i < o; i += 1) shapePool.release(t.shapes[i]);
                                    t._length = 0, e === r && (n = pooling.double(n), r *= 2), n[e] = t, e += 1
                                }
                            },
                            e = 0,
                            r = 4,
                            n = createSizedArray(r);
                        return t
                    }(),
                    segmentsLengthPool = poolFactory(8, (function () {
                        return {
                            lengths: [],
                            totalLength: 0
                        }
                    }), (function (element) {
                        var i, t = element.lengths.length;
                        for (i = 0; i < t; i += 1) bezierLengthPool.release(element.lengths[i]);
                        element.lengths.length = 0
                    })),
                    bezierLengthPool = poolFactory(8, (function () {
                        return {
                            addedLength: 0,
                            percents: createTypedArray("float32", defaultCurveSegments),
                            lengths: createTypedArray("float32", defaultCurveSegments)
                        }
                    })),
                    markerParser = function () {
                        function t(t) {
                            for (var line, e = t.split("\r\n"), r = {}, n = 0, i = 0; i < e.length; i += 1) 2 === (line = e[i].split(":")).length && (r[line[0]] = line[1].trim(), n += 1);
                            if (0 === n) throw new Error;
                            return r
                        }
                        return function (e) {
                            for (var r = [], i = 0; i < e.length; i += 1) {
                                var n = e[i],
                                    o = {
                                        time: n.tm,
                                        duration: n.dr
                                    };
                                try {
                                    o.payload = JSON.parse(e[i].cm)
                                } catch (r) {
                                    try {
                                        o.payload = t(e[i].cm)
                                    } catch (t) {
                                        o.payload = {
                                            name: e[i]
                                        }
                                    }
                                }
                                r.push(o)
                            }
                            return r
                        }
                    }();

                function BaseRenderer() {}

                function SVGRenderer(t, e) {
                    this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg");
                    var r = "";
                    if (e && e.title) {
                        var n = createNS("title"),
                            o = createElementID();
                        n.setAttribute("id", o), n.textContent = e.title, this.svgElement.appendChild(n), r += o
                    }
                    if (e && e.description) {
                        var h = createNS("desc"),
                            l = createElementID();
                        h.setAttribute("id", l), h.textContent = e.description, this.svgElement.appendChild(h), r += " " + l
                    }
                    r && this.svgElement.setAttribute("aria-labelledby", r);
                    var defs = createNS("defs");
                    this.svgElement.appendChild(defs);
                    var c = createNS("g");
                    this.svgElement.appendChild(c), this.layerElement = c, this.renderConfig = {
                        preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet",
                        imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                        progressiveLoad: e && e.progressiveLoad || !1,
                        hideOnTransparent: !(e && !1 === e.hideOnTransparent),
                        viewBoxOnly: e && e.viewBoxOnly || !1,
                        viewBoxSize: e && e.viewBoxSize || !1,
                        className: e && e.className || "",
                        id: e && e.id || "",
                        focusable: e && e.focusable,
                        filterSize: {
                            width: e && e.filterSize && e.filterSize.width || "100%",
                            height: e && e.filterSize && e.filterSize.height || "100%",
                            x: e && e.filterSize && e.filterSize.x || "0%",
                            y: e && e.filterSize && e.filterSize.y || "0%"
                        }
                    }, this.globalData = {
                        _mdf: !1,
                        frameNum: -1,
                        defs: defs,
                        renderConfig: this.renderConfig
                    }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg"
                }

                function CanvasRenderer(t, e) {
                    this.animationItem = t, this.renderConfig = {
                        clearCanvas: !e || void 0 === e.clearCanvas || e.clearCanvas,
                        context: e && e.context || null,
                        progressiveLoad: e && e.progressiveLoad || !1,
                        preserveAspectRatio: e && e.preserveAspectRatio || "xMidYMid meet",
                        imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                        className: e && e.className || "",
                        id: e && e.id || ""
                    }, this.renderConfig.dpr = e && e.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = e && e.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = {
                        frameNum: -1,
                        _mdf: !1,
                        renderConfig: this.renderConfig,
                        currentGlobalAlpha: -1
                    }, this.contextData = new CVContextData, this.elements = [], this.pendingElements = [], this.transformMat = new Matrix, this.completeLayers = !1, this.rendererType = "canvas"
                }

                function HybridRenderer(t, e) {
                    this.animationItem = t, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
                        className: e && e.className || "",
                        imagePreserveAspectRatio: e && e.imagePreserveAspectRatio || "xMidYMid slice",
                        hideOnTransparent: !(e && !1 === e.hideOnTransparent),
                        filterSize: {
                            width: e && e.filterSize && e.filterSize.width || "400%",
                            height: e && e.filterSize && e.filterSize.height || "400%",
                            x: e && e.filterSize && e.filterSize.x || "-100%",
                            y: e && e.filterSize && e.filterSize.y || "-100%"
                        }
                    }, this.globalData = {
                        _mdf: !1,
                        frameNum: -1,
                        renderConfig: this.renderConfig
                    }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html"
                }

                function MaskElement(data, element, t) {
                    this.data = data, this.element = element, this.globalData = t, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null;
                    var i, path, defs = this.globalData.defs,
                        e = this.masksProperties ? this.masksProperties.length : 0;
                    this.viewData = createSizedArray(e), this.solidPath = "";
                    var r, n, rect, o, h, l, c = this.masksProperties,
                        d = 0,
                        m = [],
                        f = createElementID(),
                        y = "clipPath",
                        v = "clip-path";
                    for (i = 0; i < e; i += 1)
                        if (("a" !== c[i].mode && "n" !== c[i].mode || c[i].inv || 100 !== c[i].o.k || c[i].o.x) && (y = "mask", v = "mask"), "s" !== c[i].mode && "i" !== c[i].mode || 0 !== d ? rect = null : ((rect = createNS("rect")).setAttribute("fill", "#ffffff"), rect.setAttribute("width", this.element.comp.data.w || 0), rect.setAttribute("height", this.element.comp.data.h || 0), m.push(rect)), path = createNS("path"), "n" === c[i].mode) this.viewData[i] = {
                            op: PropertyFactory.getProp(this.element, c[i].o, 0, .01, this.element),
                            prop: ShapePropertyFactory.getShapeProp(this.element, c[i], 3),
                            elem: path,
                            lastPath: ""
                        }, defs.appendChild(path);
                        else {
                            var x;
                            if (d += 1, path.setAttribute("fill", "s" === c[i].mode ? "#000000" : "#ffffff"), path.setAttribute("clip-rule", "nonzero"), 0 !== c[i].x.k ? (y = "mask", v = "mask", l = PropertyFactory.getProp(this.element, c[i].x, 0, null, this.element), x = createElementID(), (o = createNS("filter")).setAttribute("id", x), (h = createNS("feMorphology")).setAttribute("operator", "erode"), h.setAttribute("in", "SourceGraphic"), h.setAttribute("radius", "0"), o.appendChild(h), defs.appendChild(o), path.setAttribute("stroke", "s" === c[i].mode ? "#000000" : "#ffffff")) : (h = null, l = null), this.storedData[i] = {
                                    elem: path,
                                    x: l,
                                    expan: h,
                                    lastPath: "",
                                    lastOperator: "",
                                    filterId: x,
                                    lastRadius: 0
                                }, "i" === c[i].mode) {
                                n = m.length;
                                var g = createNS("g");
                                for (r = 0; r < n; r += 1) g.appendChild(m[r]);
                                var mask = createNS("mask");
                                mask.setAttribute("mask-type", "alpha"), mask.setAttribute("id", f + "_" + d), mask.appendChild(path), defs.appendChild(mask), g.setAttribute("mask", "url(" + locationHref + "#" + f + "_" + d + ")"), m.length = 0, m.push(g)
                            } else m.push(path);
                            c[i].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[i] = {
                                elem: path,
                                lastPath: "",
                                op: PropertyFactory.getProp(this.element, c[i].o, 0, .01, this.element),
                                prop: ShapePropertyFactory.getShapeProp(this.element, c[i], 3),
                                invRect: rect
                            }, this.viewData[i].prop.k || this.drawPath(c[i], this.viewData[i].prop.v, this.viewData[i])
                        } for (this.maskElement = createNS(y), e = m.length, i = 0; i < e; i += 1) this.maskElement.appendChild(m[i]);
                    d > 0 && (this.maskElement.setAttribute("id", f), this.element.maskedElement.setAttribute(v, "url(" + locationHref + "#" + f + ")"), defs.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this)
                }

                function HierarchyElement() {}

                function FrameElement() {}

                function TransformElement() {}

                function RenderableElement() {}

                function RenderableDOMElement() {}

                function ProcessedElement(element, t) {
                    this.elem = element, this.pos = t
                }

                function SVGStyleData(data, t) {
                    this.data = data, this.type = data.ty, this.d = "", this.lvl = t, this._mdf = !1, this.closed = !0 === data.hd, this.pElem = createNS("path"), this.msElem = null
                }

                function SVGShapeData(t, e, r) {
                    this.caches = [], this.styles = [], this.transformers = t, this.lStr = "", this.sh = r, this.lvl = e, this._isAnimated = !!r.k;
                    for (var i = 0, n = t.length; i < n;) {
                        if (t[i].mProps.dynamicProperties.length) {
                            this._isAnimated = !0;
                            break
                        }
                        i += 1
                    }
                }

                function SVGTransformData(t, e, r) {
                    this.transform = {
                        mProps: t,
                        op: e,
                        container: r
                    }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
                }

                function SVGStrokeStyleData(t, data, e) {
                    this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, data.o, 0, .01, this), this.w = PropertyFactory.getProp(t, data.w, 0, null, this), this.d = new DashProperty(t, data.d || {}, "svg", this), this.c = PropertyFactory.getProp(t, data.c, 1, 255, this), this.style = e, this._isAnimated = !!this._isAnimated
                }

                function SVGFillStyleData(t, data, e) {
                    this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(t, data.o, 0, .01, this), this.c = PropertyFactory.getProp(t, data.c, 1, 255, this), this.style = e
                }

                function SVGGradientFillStyleData(t, data, e) {
                    this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.initGradientData(t, data, e)
                }

                function SVGGradientStrokeStyleData(t, data, e) {
                    this.initDynamicPropertyContainer(t), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(t, data.w, 0, null, this), this.d = new DashProperty(t, data.d || {}, "svg", this), this.initGradientData(t, data, e), this._isAnimated = !!this._isAnimated
                }

                function ShapeGroupData() {
                    this.it = [], this.prevViewData = [], this.gr = createNS("g")
                }
                BaseRenderer.prototype.checkLayers = function (t) {
                    var i, data, e = this.layers.length;
                    for (this.completeLayers = !0, i = e - 1; i >= 0; i -= 1) this.elements[i] || (data = this.layers[i]).ip - data.st <= t - this.layers[i].st && data.op - data.st > t - this.layers[i].st && this.buildItem(i), this.completeLayers = !!this.elements[i] && this.completeLayers;
                    this.checkPendingElements()
                }, BaseRenderer.prototype.createItem = function (t) {
                    switch (t.ty) {
                        case 2:
                            return this.createImage(t);
                        case 0:
                            return this.createComp(t);
                        case 1:
                            return this.createSolid(t);
                        case 3:
                            return this.createNull(t);
                        case 4:
                            return this.createShape(t);
                        case 5:
                            return this.createText(t);
                        case 6:
                            return this.createAudio(t);
                        case 13:
                            return this.createCamera(t);
                        case 15:
                            return this.createFootage(t);
                        default:
                            return this.createNull(t)
                    }
                }, BaseRenderer.prototype.createCamera = function () {
                    throw new Error("You're using a 3d camera. Try the html renderer.")
                }, BaseRenderer.prototype.createAudio = function (data) {
                    return new AudioElement(data, this.globalData, this)
                }, BaseRenderer.prototype.createFootage = function (data) {
                    return new FootageElement(data, this.globalData, this)
                }, BaseRenderer.prototype.buildAllItems = function () {
                    var i, t = this.layers.length;
                    for (i = 0; i < t; i += 1) this.buildItem(i);
                    this.checkPendingElements()
                }, BaseRenderer.prototype.includeLayers = function (t) {
                    var i;
                    this.completeLayers = !1;
                    var e, r = t.length,
                        n = this.layers.length;
                    for (i = 0; i < r; i += 1)
                        for (e = 0; e < n;) {
                            if (this.layers[e].id === t[i].id) {
                                this.layers[e] = t[i];
                                break
                            }
                            e += 1
                        }
                }, BaseRenderer.prototype.setProjectInterface = function (t) {
                    this.globalData.projectInterface = t
                }, BaseRenderer.prototype.initItems = function () {
                    this.globalData.progressiveLoad || this.buildAllItems()
                }, BaseRenderer.prototype.buildElementParenting = function (element, t, e) {
                    for (var r = this.elements, n = this.layers, i = 0, o = n.length; i < o;) n[i].ind == t && (r[i] && !0 !== r[i] ? (e.push(r[i]), r[i].setAsParent(), void 0 !== n[i].parent ? this.buildElementParenting(element, n[i].parent, e) : element.setHierarchy(e)) : (this.buildItem(i), this.addPendingElement(element))), i += 1
                }, BaseRenderer.prototype.addPendingElement = function (element) {
                    this.pendingElements.push(element)
                }, BaseRenderer.prototype.searchExtraCompositions = function (t) {
                    var i, e = t.length;
                    for (i = 0; i < e; i += 1)
                        if (t[i].xt) {
                            var r = this.createComp(t[i]);
                            r.initExpressions(), this.globalData.projectInterface.registerComposition(r)
                        }
                }, BaseRenderer.prototype.setupGlobalData = function (t, e) {
                    this.globalData.fontManager = new FontManager, this.globalData.fontManager.addChars(t.chars), this.globalData.fontManager.addFonts(t.fonts, e), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = t.fr, this.globalData.nm = t.nm, this.globalData.compSize = {
                        w: t.w,
                        h: t.h
                    }
                }, extendPrototype([BaseRenderer], SVGRenderer), SVGRenderer.prototype.createNull = function (data) {
                    return new NullElement(data, this.globalData, this)
                }, SVGRenderer.prototype.createShape = function (data) {
                    return new SVGShapeElement(data, this.globalData, this)
                }, SVGRenderer.prototype.createText = function (data) {
                    return new SVGTextLottieElement(data, this.globalData, this)
                }, SVGRenderer.prototype.createImage = function (data) {
                    return new IImageElement(data, this.globalData, this)
                }, SVGRenderer.prototype.createComp = function (data) {
                    return new SVGCompElement(data, this.globalData, this)
                }, SVGRenderer.prototype.createSolid = function (data) {
                    return new ISolidElement(data, this.globalData, this)
                }, SVGRenderer.prototype.configAnimation = function (t) {
                    this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + t.w + " " + t.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", t.w), this.svgElement.setAttribute("height", t.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)"), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), void 0 !== this.renderConfig.focusable && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement);
                    var defs = this.globalData.defs;
                    this.setupGlobalData(t, defs), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = t;
                    var e = createNS("clipPath"),
                        rect = createNS("rect");
                    rect.setAttribute("width", t.w), rect.setAttribute("height", t.h), rect.setAttribute("x", 0), rect.setAttribute("y", 0);
                    var r = createElementID();
                    e.setAttribute("id", r), e.appendChild(rect), this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + r + ")"), defs.appendChild(e), this.layers = t.layers, this.elements = createSizedArray(t.layers.length)
                }, SVGRenderer.prototype.destroy = function () {
                    var i;
                    this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null;
                    var t = this.layers ? this.layers.length : 0;
                    for (i = 0; i < t; i += 1) this.elements[i] && this.elements[i].destroy();
                    this.elements.length = 0, this.destroyed = !0, this.animationItem = null
                }, SVGRenderer.prototype.updateContainerSize = function () {}, SVGRenderer.prototype.buildItem = function (t) {
                    var e = this.elements;
                    if (!e[t] && 99 !== this.layers[t].ty) {
                        e[t] = !0;
                        var element = this.createItem(this.layers[t]);
                        e[t] = element, expressionsPlugin && (0 === this.layers[t].ty && this.globalData.projectInterface.registerComposition(element), element.initExpressions()), this.appendElementInPos(element, t), this.layers[t].tt && (this.elements[t - 1] && !0 !== this.elements[t - 1] ? element.setMatte(e[t - 1].layerId) : (this.buildItem(t - 1), this.addPendingElement(element)))
                    }
                }, SVGRenderer.prototype.checkPendingElements = function () {
                    for (; this.pendingElements.length;) {
                        var element = this.pendingElements.pop();
                        if (element.checkParenting(), element.data.tt)
                            for (var i = 0, t = this.elements.length; i < t;) {
                                if (this.elements[i] === element) {
                                    element.setMatte(this.elements[i - 1].layerId);
                                    break
                                }
                                i += 1
                            }
                    }
                }, SVGRenderer.prototype.renderFrame = function (t) {
                    if (this.renderedFrame !== t && !this.destroyed) {
                        var i;
                        null === t ? t = this.renderedFrame : this.renderedFrame = t, this.globalData.frameNum = t, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = t, this.globalData._mdf = !1;
                        var e = this.layers.length;
                        for (this.completeLayers || this.checkLayers(t), i = e - 1; i >= 0; i -= 1)(this.completeLayers || this.elements[i]) && this.elements[i].prepareFrame(t - this.layers[i].st);
                        if (this.globalData._mdf)
                            for (i = 0; i < e; i += 1)(this.completeLayers || this.elements[i]) && this.elements[i].renderFrame()
                    }
                }, SVGRenderer.prototype.appendElementInPos = function (element, t) {
                    var e = element.getBaseElement();
                    if (e) {
                        for (var r, i = 0; i < t;) this.elements[i] && !0 !== this.elements[i] && this.elements[i].getBaseElement() && (r = this.elements[i].getBaseElement()), i += 1;
                        r ? this.layerElement.insertBefore(e, r) : this.layerElement.appendChild(e)
                    }
                }, SVGRenderer.prototype.hide = function () {
                    this.layerElement.style.display = "none"
                }, SVGRenderer.prototype.show = function () {
                    this.layerElement.style.display = "block"
                }, extendPrototype([BaseRenderer], CanvasRenderer), CanvasRenderer.prototype.createShape = function (data) {
                    return new CVShapeElement(data, this.globalData, this)
                }, CanvasRenderer.prototype.createText = function (data) {
                    return new CVTextElement(data, this.globalData, this)
                }, CanvasRenderer.prototype.createImage = function (data) {
                    return new CVImageElement(data, this.globalData, this)
                }, CanvasRenderer.prototype.createComp = function (data) {
                    return new CVCompElement(data, this.globalData, this)
                }, CanvasRenderer.prototype.createSolid = function (data) {
                    return new CVSolidElement(data, this.globalData, this)
                }, CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRenderer.prototype.ctxTransform = function (t) {
                    if (1 !== t[0] || 0 !== t[1] || 0 !== t[4] || 1 !== t[5] || 0 !== t[12] || 0 !== t[13])
                        if (this.renderConfig.clearCanvas) {
                            this.transformMat.cloneFromProps(t);
                            var e = this.contextData.cTr.props;
                            this.transformMat.transform(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]), this.contextData.cTr.cloneFromProps(this.transformMat.props);
                            var r = this.contextData.cTr.props;
                            this.canvasContext.setTransform(r[0], r[1], r[4], r[5], r[12], r[13])
                        } else this.canvasContext.transform(t[0], t[1], t[4], t[5], t[12], t[13])
                }, CanvasRenderer.prototype.ctxOpacity = function (t) {
                    if (!this.renderConfig.clearCanvas) return this.canvasContext.globalAlpha *= t < 0 ? 0 : t, void(this.globalData.currentGlobalAlpha = this.contextData.cO);
                    this.contextData.cO *= t < 0 ? 0 : t, this.globalData.currentGlobalAlpha !== this.contextData.cO && (this.canvasContext.globalAlpha = this.contextData.cO, this.globalData.currentGlobalAlpha = this.contextData.cO)
                }, CanvasRenderer.prototype.reset = function () {
                    this.renderConfig.clearCanvas ? this.contextData.reset() : this.canvasContext.restore()
                }, CanvasRenderer.prototype.save = function (t) {
                    if (this.renderConfig.clearCanvas) {
                        t && this.canvasContext.save();
                        var i, e = this.contextData.cTr.props;
                        this.contextData._length <= this.contextData.cArrPos && this.contextData.duplicate();
                        var r = this.contextData.saved[this.contextData.cArrPos];
                        for (i = 0; i < 16; i += 1) r[i] = e[i];
                        this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO, this.contextData.cArrPos += 1
                    } else this.canvasContext.save()
                }, CanvasRenderer.prototype.restore = function (t) {
                    if (this.renderConfig.clearCanvas) {
                        t && (this.canvasContext.restore(), this.globalData.blendMode = "source-over"), this.contextData.cArrPos -= 1;
                        var i, e = this.contextData.saved[this.contextData.cArrPos],
                            r = this.contextData.cTr.props;
                        for (i = 0; i < 16; i += 1) r[i] = e[i];
                        this.canvasContext.setTransform(e[0], e[1], e[4], e[5], e[12], e[13]), e = this.contextData.savedOp[this.contextData.cArrPos], this.contextData.cO = e, this.globalData.currentGlobalAlpha !== e && (this.canvasContext.globalAlpha = e, this.globalData.currentGlobalAlpha = e)
                    } else this.canvasContext.restore()
                }, CanvasRenderer.prototype.configAnimation = function (t) {
                    if (this.animationItem.wrapper) {
                        this.animationItem.container = createTag("canvas");
                        var e = this.animationItem.container.style;
                        e.width = "100%", e.height = "100%";
                        var r = "0px 0px 0px";
                        e.transformOrigin = r, e.mozTransformOrigin = r, e.webkitTransformOrigin = r, e["-webkit-transform"] = r, this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)
                    } else this.canvasContext = this.renderConfig.context;
                    this.data = t, this.layers = t.layers, this.transformCanvas = {
                        w: t.w,
                        h: t.h,
                        sx: 0,
                        sy: 0,
                        tx: 0,
                        ty: 0
                    }, this.setupGlobalData(t, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(t.layers.length), this.updateContainerSize()
                }, CanvasRenderer.prototype.updateContainerSize = function () {
                    var t, e, r, n;
                    if (this.reset(), this.animationItem.wrapper && this.animationItem.container ? (t = this.animationItem.wrapper.offsetWidth, e = this.animationItem.wrapper.offsetHeight, this.animationItem.container.setAttribute("width", t * this.renderConfig.dpr), this.animationItem.container.setAttribute("height", e * this.renderConfig.dpr)) : (t = this.canvasContext.canvas.width * this.renderConfig.dpr, e = this.canvasContext.canvas.height * this.renderConfig.dpr), -1 !== this.renderConfig.preserveAspectRatio.indexOf("meet") || -1 !== this.renderConfig.preserveAspectRatio.indexOf("slice")) {
                        var o = this.renderConfig.preserveAspectRatio.split(" "),
                            h = o[1] || "meet",
                            l = o[0] || "xMidYMid",
                            c = l.substr(0, 4),
                            d = l.substr(4);
                        r = t / e, (n = this.transformCanvas.w / this.transformCanvas.h) > r && "meet" === h || n < r && "slice" === h ? (this.transformCanvas.sx = t / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = t / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = e / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = e / (this.transformCanvas.h / this.renderConfig.dpr)), this.transformCanvas.tx = "xMid" === c && (n < r && "meet" === h || n > r && "slice" === h) ? (t - this.transformCanvas.w * (e / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : "xMax" === c && (n < r && "meet" === h || n > r && "slice" === h) ? (t - this.transformCanvas.w * (e / this.transformCanvas.h)) * this.renderConfig.dpr : 0, this.transformCanvas.ty = "YMid" === d && (n > r && "meet" === h || n < r && "slice" === h) ? (e - this.transformCanvas.h * (t / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : "YMax" === d && (n > r && "meet" === h || n < r && "slice" === h) ? (e - this.transformCanvas.h * (t / this.transformCanvas.w)) * this.renderConfig.dpr : 0
                    } else "none" === this.renderConfig.preserveAspectRatio ? (this.transformCanvas.sx = t / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = e / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0);
                    this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0)
                }, CanvasRenderer.prototype.destroy = function () {
                    var i;
                    for (this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), i = (this.layers ? this.layers.length : 0) - 1; i >= 0; i -= 1) this.elements[i] && this.elements[i].destroy();
                    this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0
                }, CanvasRenderer.prototype.renderFrame = function (t, e) {
                    if ((this.renderedFrame !== t || !0 !== this.renderConfig.clearCanvas || e) && !this.destroyed && -1 !== t) {
                        var i;
                        this.renderedFrame = t, this.globalData.frameNum = t - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || e, this.globalData.projectInterface.currentFrame = t;
                        var r = this.layers.length;
                        for (this.completeLayers || this.checkLayers(t), i = 0; i < r; i += 1)(this.completeLayers || this.elements[i]) && this.elements[i].prepareFrame(t - this.layers[i].st);
                        if (this.globalData._mdf) {
                            for (!0 === this.renderConfig.clearCanvas ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), i = r - 1; i >= 0; i -= 1)(this.completeLayers || this.elements[i]) && this.elements[i].renderFrame();
                            !0 !== this.renderConfig.clearCanvas && this.restore()
                        }
                    }
                }, CanvasRenderer.prototype.buildItem = function (t) {
                    var e = this.elements;
                    if (!e[t] && 99 !== this.layers[t].ty) {
                        var element = this.createItem(this.layers[t], this, this.globalData);
                        e[t] = element, element.initExpressions()
                    }
                }, CanvasRenderer.prototype.checkPendingElements = function () {
                    for (; this.pendingElements.length;) this.pendingElements.pop().checkParenting()
                }, CanvasRenderer.prototype.hide = function () {
                    this.animationItem.container.style.display = "none"
                }, CanvasRenderer.prototype.show = function () {
                    this.animationItem.container.style.display = "block"
                }, extendPrototype([BaseRenderer], HybridRenderer), HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRenderer.prototype.checkPendingElements = function () {
                    for (; this.pendingElements.length;) this.pendingElements.pop().checkParenting()
                }, HybridRenderer.prototype.appendElementInPos = function (element, t) {
                    var e = element.getBaseElement();
                    if (e) {
                        var r = this.layers[t];
                        if (r.ddd && this.supports3d) this.addTo3dContainer(e, t);
                        else if (this.threeDElements) this.addTo3dContainer(e, t);
                        else {
                            for (var n, o, i = 0; i < t;) this.elements[i] && !0 !== this.elements[i] && this.elements[i].getBaseElement && (o = this.elements[i], n = (this.layers[i].ddd ? this.getThreeDContainerByPos(i) : o.getBaseElement()) || n), i += 1;
                            n ? r.ddd && this.supports3d || this.layerElement.insertBefore(e, n) : r.ddd && this.supports3d || this.layerElement.appendChild(e)
                        }
                    }
                }, HybridRenderer.prototype.createShape = function (data) {
                    return this.supports3d ? new HShapeElement(data, this.globalData, this) : new SVGShapeElement(data, this.globalData, this)
                }, HybridRenderer.prototype.createText = function (data) {
                    return this.supports3d ? new HTextElement(data, this.globalData, this) : new SVGTextLottieElement(data, this.globalData, this)
                }, HybridRenderer.prototype.createCamera = function (data) {
                    return this.camera = new HCameraElement(data, this.globalData, this), this.camera
                }, HybridRenderer.prototype.createImage = function (data) {
                    return this.supports3d ? new HImageElement(data, this.globalData, this) : new IImageElement(data, this.globalData, this)
                }, HybridRenderer.prototype.createComp = function (data) {
                    return this.supports3d ? new HCompElement(data, this.globalData, this) : new SVGCompElement(data, this.globalData, this)
                }, HybridRenderer.prototype.createSolid = function (data) {
                    return this.supports3d ? new HSolidElement(data, this.globalData, this) : new ISolidElement(data, this.globalData, this)
                }, HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull, HybridRenderer.prototype.getThreeDContainerByPos = function (t) {
                    for (var i = 0, e = this.threeDElements.length; i < e;) {
                        if (this.threeDElements[i].startPos <= t && this.threeDElements[i].endPos >= t) return this.threeDElements[i].perspectiveElem;
                        i += 1
                    }
                    return null
                }, HybridRenderer.prototype.createThreeDContainer = function (t, e) {
                    var style, r, n = createTag("div");
                    styleDiv(n);
                    var o = createTag("div");
                    if (styleDiv(o), "3d" === e) {
                        (style = n.style).width = this.globalData.compSize.w + "px", style.height = this.globalData.compSize.h + "px";
                        var h = "50% 50%";
                        style.webkitTransformOrigin = h, style.mozTransformOrigin = h, style.transformOrigin = h;
                        var l = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                        (r = o.style).transform = l, r.webkitTransform = l
                    }
                    n.appendChild(o);
                    var c = {
                        container: o,
                        perspectiveElem: n,
                        startPos: t,
                        endPos: t,
                        type: e
                    };
                    return this.threeDElements.push(c), c
                }, HybridRenderer.prototype.build3dContainers = function () {
                    var i, t, e = this.layers.length,
                        r = "";
                    for (i = 0; i < e; i += 1) this.layers[i].ddd && 3 !== this.layers[i].ty ? ("3d" !== r && (r = "3d", t = this.createThreeDContainer(i, "3d")), t.endPos = Math.max(t.endPos, i)) : ("2d" !== r && (r = "2d", t = this.createThreeDContainer(i, "2d")), t.endPos = Math.max(t.endPos, i));
                    for (i = (e = this.threeDElements.length) - 1; i >= 0; i -= 1) this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem)
                }, HybridRenderer.prototype.addTo3dContainer = function (t, e) {
                    for (var i = 0, r = this.threeDElements.length; i < r;) {
                        if (e <= this.threeDElements[i].endPos) {
                            for (var n, o = this.threeDElements[i].startPos; o < e;) this.elements[o] && this.elements[o].getBaseElement && (n = this.elements[o].getBaseElement()), o += 1;
                            n ? this.threeDElements[i].container.insertBefore(t, n) : this.threeDElements[i].container.appendChild(t);
                            break
                        }
                        i += 1
                    }
                }, HybridRenderer.prototype.configAnimation = function (t) {
                    var e = createTag("div"),
                        r = this.animationItem.wrapper,
                        style = e.style;
                    style.width = t.w + "px", style.height = t.h + "px", this.resizerElem = e, styleDiv(e), style.transformStyle = "flat", style.mozTransformStyle = "flat", style.webkitTransformStyle = "flat", this.renderConfig.className && e.setAttribute("class", this.renderConfig.className), r.appendChild(e), style.overflow = "hidden";
                    var svg = createNS("svg");
                    svg.setAttribute("width", "1"), svg.setAttribute("height", "1"), styleDiv(svg), this.resizerElem.appendChild(svg);
                    var defs = createNS("defs");
                    svg.appendChild(defs), this.data = t, this.setupGlobalData(t, svg), this.globalData.defs = defs, this.layers = t.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize()
                }, HybridRenderer.prototype.destroy = function () {
                    var i;
                    this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null;
                    var t = this.layers ? this.layers.length : 0;
                    for (i = 0; i < t; i += 1) this.elements[i].destroy();
                    this.elements.length = 0, this.destroyed = !0, this.animationItem = null
                }, HybridRenderer.prototype.updateContainerSize = function () {
                    var t, e, r, n, o = this.animationItem.wrapper.offsetWidth,
                        h = this.animationItem.wrapper.offsetHeight,
                        l = o / h;
                    this.globalData.compSize.w / this.globalData.compSize.h > l ? (t = o / this.globalData.compSize.w, e = o / this.globalData.compSize.w, r = 0, n = (h - this.globalData.compSize.h * (o / this.globalData.compSize.w)) / 2) : (t = h / this.globalData.compSize.h, e = h / this.globalData.compSize.h, r = (o - this.globalData.compSize.w * (h / this.globalData.compSize.h)) / 2, n = 0);
                    var style = this.resizerElem.style;
                    style.webkitTransform = "matrix3d(" + t + ",0,0,0,0," + e + ",0,0,0,0,1,0," + r + "," + n + ",0,1)", style.transform = style.webkitTransform
                }, HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRenderer.prototype.hide = function () {
                    this.resizerElem.style.display = "none"
                }, HybridRenderer.prototype.show = function () {
                    this.resizerElem.style.display = "block"
                }, HybridRenderer.prototype.initItems = function () {
                    if (this.buildAllItems(), this.camera) this.camera.setup();
                    else {
                        var i, t = this.globalData.compSize.w,
                            e = this.globalData.compSize.h,
                            r = this.threeDElements.length;
                        for (i = 0; i < r; i += 1) {
                            var style = this.threeDElements[i].perspectiveElem.style;
                            style.webkitPerspective = Math.sqrt(Math.pow(t, 2) + Math.pow(e, 2)) + "px", style.perspective = style.webkitPerspective
                        }
                    }
                }, HybridRenderer.prototype.searchExtraCompositions = function (t) {
                    var i, e = t.length,
                        r = createTag("div");
                    for (i = 0; i < e; i += 1)
                        if (t[i].xt) {
                            var n = this.createComp(t[i], r, this.globalData.comp, null);
                            n.initExpressions(), this.globalData.projectInterface.registerComposition(n)
                        }
                }, MaskElement.prototype.getMaskProperty = function (t) {
                    return this.viewData[t].prop
                }, MaskElement.prototype.renderFrame = function (t) {
                    var i, e = this.element.finalTransform.mat,
                        r = this.masksProperties.length;
                    for (i = 0; i < r; i += 1)
                        if ((this.viewData[i].prop._mdf || t) && this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]), (this.viewData[i].op._mdf || t) && this.viewData[i].elem.setAttribute("fill-opacity", this.viewData[i].op.v), "n" !== this.masksProperties[i].mode && (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || t) && this.viewData[i].invRect.setAttribute("transform", e.getInverseMatrix().to2dCSS()), this.storedData[i].x && (this.storedData[i].x._mdf || t))) {
                            var n = this.storedData[i].expan;
                            this.storedData[i].x.v < 0 ? ("erode" !== this.storedData[i].lastOperator && (this.storedData[i].lastOperator = "erode", this.storedData[i].elem.setAttribute("filter", "url(" + locationHref + "#" + this.storedData[i].filterId + ")")), n.setAttribute("radius", -this.storedData[i].x.v)) : ("dilate" !== this.storedData[i].lastOperator && (this.storedData[i].lastOperator = "dilate", this.storedData[i].elem.setAttribute("filter", null)), this.storedData[i].elem.setAttribute("stroke-width", 2 * this.storedData[i].x.v))
                        }
                }, MaskElement.prototype.getMaskelement = function () {
                    return this.maskElement
                }, MaskElement.prototype.createLayerSolidPath = function () {
                    var path = "M0,0 ";
                    return path += " h" + this.globalData.compSize.w, path += " v" + this.globalData.compSize.h, path += " h-" + this.globalData.compSize.w, path += " v-" + this.globalData.compSize.h + " "
                }, MaskElement.prototype.drawPath = function (t, e, r) {
                    var i, n, o = " M" + e.v[0][0] + "," + e.v[0][1];
                    for (n = e._length, i = 1; i < n; i += 1) o += " C" + e.o[i - 1][0] + "," + e.o[i - 1][1] + " " + e.i[i][0] + "," + e.i[i][1] + " " + e.v[i][0] + "," + e.v[i][1];
                    if (e.c && n > 1 && (o += " C" + e.o[i - 1][0] + "," + e.o[i - 1][1] + " " + e.i[0][0] + "," + e.i[0][1] + " " + e.v[0][0] + "," + e.v[0][1]), r.lastPath !== o) {
                        var h = "";
                        r.elem && (e.c && (h = t.inv ? this.solidPath + o : o), r.elem.setAttribute("d", h)), r.lastPath = o
                    }
                }, MaskElement.prototype.destroy = function () {
                    this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null
                }, HierarchyElement.prototype = {
                    initHierarchy: function () {
                        this.hierarchy = [], this._isParent = !1, this.checkParenting()
                    },
                    setHierarchy: function (t) {
                        this.hierarchy = t
                    },
                    setAsParent: function () {
                        this._isParent = !0
                    },
                    checkParenting: function () {
                        void 0 !== this.data.parent && this.comp.buildElementParenting(this, this.data.parent, [])
                    }
                }, FrameElement.prototype = {
                    initFrame: function () {
                        this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1
                    },
                    prepareProperties: function (t, e) {
                        var i, r = this.dynamicProperties.length;
                        for (i = 0; i < r; i += 1)(e || this._isParent && "transform" === this.dynamicProperties[i].propType) && (this.dynamicProperties[i].getValue(), this.dynamicProperties[i]._mdf && (this.globalData._mdf = !0, this._mdf = !0))
                    },
                    addDynamicProperty: function (t) {
                        -1 === this.dynamicProperties.indexOf(t) && this.dynamicProperties.push(t)
                    }
                }, TransformElement.prototype = {
                    initTransform: function () {
                        this.finalTransform = {
                            mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                                o: 0
                            },
                            _matMdf: !1,
                            _opMdf: !1,
                            mat: new Matrix
                        }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty
                    },
                    renderTransform: function () {
                        if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) {
                            var t, e = this.finalTransform.mat,
                                i = 0,
                                r = this.hierarchy.length;
                            if (!this.finalTransform._matMdf)
                                for (; i < r;) {
                                    if (this.hierarchy[i].finalTransform.mProp._mdf) {
                                        this.finalTransform._matMdf = !0;
                                        break
                                    }
                                    i += 1
                                }
                            if (this.finalTransform._matMdf)
                                for (t = this.finalTransform.mProp.v.props, e.cloneFromProps(t), i = 0; i < r; i += 1) t = this.hierarchy[i].finalTransform.mProp.v.props, e.transform(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15])
                        }
                    },
                    globalToLocal: function (t) {
                        var e = [];
                        e.push(this.finalTransform);
                        for (var i, r = !0, n = this.comp; r;) n.finalTransform ? (n.data.hasMask && e.splice(0, 0, n.finalTransform), n = n.comp) : r = !1;
                        var o, h = e.length;
                        for (i = 0; i < h; i += 1) o = e[i].mat.applyToPointArray(0, 0, 0), t = [t[0] - o[0], t[1] - o[1], 0];
                        return t
                    },
                    mHelper: new Matrix
                }, RenderableElement.prototype = {
                    initRenderable: function () {
                        this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = []
                    },
                    addRenderableComponent: function (component) {
                        -1 === this.renderableComponents.indexOf(component) && this.renderableComponents.push(component)
                    },
                    removeRenderableComponent: function (component) {
                        -1 !== this.renderableComponents.indexOf(component) && this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1)
                    },
                    prepareRenderableFrame: function (t) {
                        this.checkLayerLimits(t)
                    },
                    checkTransparency: function () {
                        this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show())
                    },
                    checkLayerLimits: function (t) {
                        this.data.ip - this.data.st <= t && this.data.op - this.data.st > t ? !0 !== this.isInRange && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : !1 !== this.isInRange && (this.globalData._mdf = !0, this.isInRange = !1, this.hide())
                    },
                    renderRenderable: function () {
                        var i, t = this.renderableComponents.length;
                        for (i = 0; i < t; i += 1) this.renderableComponents[i].renderFrame(this._isFirstFrame)
                    },
                    sourceRectAtTime: function () {
                        return {
                            top: 0,
                            left: 0,
                            width: 100,
                            height: 100
                        }
                    },
                    getLayerSize: function () {
                        return 5 === this.data.ty ? {
                            w: this.data.textData.width,
                            h: this.data.textData.height
                        } : {
                            w: this.data.width,
                            h: this.data.height
                        }
                    }
                }, extendPrototype([RenderableElement, createProxyFunction({
                    initElement: function (data, t, e) {
                        this.initFrame(), this.initBaseData(data, t, e), this.initTransform(data, t, e), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide()
                    },
                    hide: function () {
                        this.hidden || this.isInRange && !this.isTransparent || ((this.baseElement || this.layerElement).style.display = "none", this.hidden = !0)
                    },
                    show: function () {
                        this.isInRange && !this.isTransparent && (this.data.hd || ((this.baseElement || this.layerElement).style.display = "block"), this.hidden = !1, this._isFirstFrame = !0)
                    },
                    renderFrame: function () {
                        this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
                    },
                    renderInnerContent: function () {},
                    prepareFrame: function (t) {
                        this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.checkTransparency()
                    },
                    destroy: function () {
                        this.innerElem = null, this.destroyBaseElement()
                    }
                })], RenderableDOMElement), SVGStyleData.prototype.reset = function () {
                    this.d = "", this._mdf = !1
                }, SVGShapeData.prototype.setAsAnimated = function () {
                    this._isAnimated = !0
                }, extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData), extendPrototype([DynamicPropertyContainer], SVGFillStyleData), SVGGradientFillStyleData.prototype.initGradientData = function (t, data, e) {
                    this.o = PropertyFactory.getProp(t, data.o, 0, .01, this), this.s = PropertyFactory.getProp(t, data.s, 1, null, this), this.e = PropertyFactory.getProp(t, data.e, 1, null, this), this.h = PropertyFactory.getProp(t, data.h || {
                        k: 0
                    }, 0, .01, this), this.a = PropertyFactory.getProp(t, data.a || {
                        k: 0
                    }, 0, degToRads, this), this.g = new GradientProperty(t, data.g, this), this.style = e, this.stops = [], this.setGradientData(e.pElem, data), this.setGradientOpacity(data, e), this._isAnimated = !!this._isAnimated
                }, SVGGradientFillStyleData.prototype.setGradientData = function (t, data) {
                    var e = createElementID(),
                        r = createNS(1 === data.t ? "linearGradient" : "radialGradient");
                    r.setAttribute("id", e), r.setAttribute("spreadMethod", "pad"), r.setAttribute("gradientUnits", "userSpaceOnUse");
                    var n, o, h, l = [];
                    for (h = 4 * data.g.p, o = 0; o < h; o += 4) n = createNS("stop"), r.appendChild(n), l.push(n);
                    t.setAttribute("gf" === data.ty ? "fill" : "stroke", "url(" + locationHref + "#" + e + ")"), this.gf = r, this.cst = l
                }, SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, t) {
                    if (this.g._hasOpacity && !this.g._collapsable) {
                        var e, r, n, mask = createNS("mask"),
                            o = createNS("path");
                        mask.appendChild(o);
                        var h = createElementID(),
                            l = createElementID();
                        mask.setAttribute("id", l);
                        var c = createNS(1 === data.t ? "linearGradient" : "radialGradient");
                        c.setAttribute("id", h), c.setAttribute("spreadMethod", "pad"), c.setAttribute("gradientUnits", "userSpaceOnUse"), n = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
                        var d = this.stops;
                        for (r = 4 * data.g.p; r < n; r += 2)(e = createNS("stop")).setAttribute("stop-color", "rgb(255,255,255)"), c.appendChild(e), d.push(e);
                        o.setAttribute("gf" === data.ty ? "fill" : "stroke", "url(" + locationHref + "#" + h + ")"), "gs" === data.ty && (o.setAttribute("stroke-linecap", lineCapEnum[data.lc || 2]), o.setAttribute("stroke-linejoin", lineJoinEnum[data.lj || 2]), 1 === data.lj && o.setAttribute("stroke-miterlimit", data.ml)), this.of = c, this.ms = mask, this.ost = d, this.maskId = l, t.msElem = o
                    }
                }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData), extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
                var SVGElementsRenderer = function () {
                    var t = new Matrix,
                        e = new Matrix;

                    function r(t, e, r) {
                        (r || e.transform.op._mdf) && e.transform.container.setAttribute("opacity", e.transform.op.v), (r || e.transform.mProps._mdf) && e.transform.container.setAttribute("transform", e.transform.mProps.v.to2dCSS())
                    }

                    function n(r, n, o) {
                        var h, l, c, d, m, f, y, v, x, _, M, S = n.styles.length,
                            w = n.lvl;
                        for (f = 0; f < S; f += 1) {
                            if (d = n.sh._mdf || o, n.styles[f].lvl < w) {
                                for (v = e.reset(), _ = w - n.styles[f].lvl, M = n.transformers.length - 1; !d && _ > 0;) d = n.transformers[M].mProps._mdf || d, _ -= 1, M -= 1;
                                if (d)
                                    for (_ = w - n.styles[f].lvl, M = n.transformers.length - 1; _ > 0;) x = n.transformers[M].mProps.v.props, v.transform(x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14], x[15]), _ -= 1, M -= 1
                            } else v = t;
                            if (l = (y = n.sh.paths)._length, d) {
                                for (c = "", h = 0; h < l; h += 1)(m = y.shapes[h]) && m._length && (c += buildShapeString(m, m._length, m.c, v));
                                n.caches[f] = c
                            } else c = n.caches[f];
                            n.styles[f].d += !0 === r.hd ? "" : c, n.styles[f]._mdf = d || n.styles[f]._mdf
                        }
                    }

                    function o(t, e, r) {
                        var n = e.style;
                        (e.c._mdf || r) && n.pElem.setAttribute("fill", "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || r) && n.pElem.setAttribute("fill-opacity", e.o.v)
                    }

                    function h(t, e, r) {
                        l(t, e, r), c(0, e, r)
                    }

                    function l(t, e, r) {
                        var n, i, o, h, l, c = e.gf,
                            d = e.g._hasOpacity,
                            m = e.s.v,
                            f = e.e.v;
                        if (e.o._mdf || r) {
                            var y = "gf" === t.ty ? "fill-opacity" : "stroke-opacity";
                            e.style.pElem.setAttribute(y, e.o.v)
                        }
                        if (e.s._mdf || r) {
                            var v = 1 === t.t ? "x1" : "cx",
                                x = "x1" === v ? "y1" : "cy";
                            c.setAttribute(v, m[0]), c.setAttribute(x, m[1]), d && !e.g._collapsable && (e.of.setAttribute(v, m[0]), e.of.setAttribute(x, m[1]))
                        }
                        if (e.g._cmdf || r) {
                            n = e.cst;
                            var _ = e.g.c;
                            for (o = n.length, i = 0; i < o; i += 1)(h = n[i]).setAttribute("offset", _[4 * i] + "%"), h.setAttribute("stop-color", "rgb(" + _[4 * i + 1] + "," + _[4 * i + 2] + "," + _[4 * i + 3] + ")")
                        }
                        if (d && (e.g._omdf || r)) {
                            var M = e.g.o;
                            for (o = (n = e.g._collapsable ? e.cst : e.ost).length, i = 0; i < o; i += 1) h = n[i], e.g._collapsable || h.setAttribute("offset", M[2 * i] + "%"), h.setAttribute("stop-opacity", M[2 * i + 1])
                        }
                        if (1 === t.t)(e.e._mdf || r) && (c.setAttribute("x2", f[0]), c.setAttribute("y2", f[1]), d && !e.g._collapsable && (e.of.setAttribute("x2", f[0]), e.of.setAttribute("y2", f[1])));
                        else if ((e.s._mdf || e.e._mdf || r) && (l = Math.sqrt(Math.pow(m[0] - f[0], 2) + Math.pow(m[1] - f[1], 2)), c.setAttribute("r", l), d && !e.g._collapsable && e.of.setAttribute("r", l)), e.e._mdf || e.h._mdf || e.a._mdf || r) {
                            l || (l = Math.sqrt(Math.pow(m[0] - f[0], 2) + Math.pow(m[1] - f[1], 2)));
                            var S = Math.atan2(f[1] - m[1], f[0] - m[0]),
                                w = e.h.v;
                            w >= 1 ? w = .99 : w <= -1 && (w = -.99);
                            var E = l * w,
                                T = Math.cos(S + e.a.v) * E + m[0],
                                A = Math.sin(S + e.a.v) * E + m[1];
                            c.setAttribute("fx", T), c.setAttribute("fy", A), d && !e.g._collapsable && (e.of.setAttribute("fx", T), e.of.setAttribute("fy", A))
                        }
                    }

                    function c(t, e, r) {
                        var n = e.style,
                            o = e.d;
                        o && (o._mdf || r) && o.dashStr && (n.pElem.setAttribute("stroke-dasharray", o.dashStr), n.pElem.setAttribute("stroke-dashoffset", o.dashoffset[0])), e.c && (e.c._mdf || r) && n.pElem.setAttribute("stroke", "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || r) && n.pElem.setAttribute("stroke-opacity", e.o.v), (e.w._mdf || r) && (n.pElem.setAttribute("stroke-width", e.w.v), n.msElem && n.msElem.setAttribute("stroke-width", e.w.v))
                    }
                    return {
                        createRenderFunction: function (data) {
                            switch (data.ty) {
                                case "fl":
                                    return o;
                                case "gf":
                                    return l;
                                case "gs":
                                    return h;
                                case "st":
                                    return c;
                                case "sh":
                                case "el":
                                case "rc":
                                case "sr":
                                    return n;
                                case "tr":
                                    return r;
                                default:
                                    return null
                            }
                        }
                    }
                }();

                function ShapeTransformManager() {
                    this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0
                }

                function CVShapeData(element, data, t, e) {
                    this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0];
                    var i, r = 4;
                    "rc" === data.ty ? r = 5 : "el" === data.ty ? r = 6 : "sr" === data.ty && (r = 7), this.sh = ShapePropertyFactory.getShapeProp(element, data, r, element);
                    var n, o = t.length;
                    for (i = 0; i < o; i += 1) t[i].closed || (n = {
                        transforms: e.addTransformSequence(t[i].transforms),
                        trNodes: []
                    }, this.styledShapes.push(n), t[i].elements.push(n))
                }

                function BaseElement() {}

                function NullElement(data, t, e) {
                    this.initFrame(), this.initBaseData(data, t, e), this.initFrame(), this.initTransform(data, t, e), this.initHierarchy()
                }

                function SVGBaseElement() {}

                function IShapeElement() {}

                function ITextElement() {}

                function ICompElement() {}

                function IImageElement(data, t, e) {
                    this.assetData = t.getAssetData(data.refId), this.initElement(data, t, e), this.sourceRect = {
                        top: 0,
                        left: 0,
                        width: this.assetData.w,
                        height: this.assetData.h
                    }
                }

                function ISolidElement(data, t, e) {
                    this.initElement(data, t, e)
                }

                function AudioElement(data, t, e) {
                    this.initFrame(), this.initRenderable(), this.assetData = t.getAssetData(data.refId), this.initBaseData(data, t, e), this._isPlaying = !1, this._canPlay = !1;
                    var r = this.globalData.getAssetsPath(this.assetData);
                    this.audio = this.globalData.audioController.createAudio(r), this._currentTime = 0, this.globalData.audioController.addAudio(this), this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, t.frameRate, this) : {
                        _placeholder: !0
                    }
                }

                function FootageElement(data, t, e) {
                    this.initFrame(), this.initRenderable(), this.assetData = t.getAssetData(data.refId), this.footageData = t.imageLoader.getAsset(this.assetData), this.initBaseData(data, t, e)
                }

                function SVGCompElement(data, t, e) {
                    this.layers = data.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(data, t, e), this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, t.frameRate, this) : {
                        _placeholder: !0
                    }
                }

                function SVGTextLottieElement(data, t, e) {
                    this.textSpans = [], this.renderType = "svg", this.initElement(data, t, e)
                }

                function SVGShapeElement(data, t, e) {
                    this.shapes = [], this.shapesData = data.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(data, t, e), this.prevViewData = []
                }

                function SVGTintFilter(filter, t) {
                    this.filterManager = t;
                    var e = createNS("feColorMatrix");
                    if (e.setAttribute("type", "matrix"), e.setAttribute("color-interpolation-filters", "linearRGB"), e.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), e.setAttribute("result", "f1"), filter.appendChild(e), (e = createNS("feColorMatrix")).setAttribute("type", "matrix"), e.setAttribute("color-interpolation-filters", "sRGB"), e.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), e.setAttribute("result", "f2"), filter.appendChild(e), this.matrixFilter = e, 100 !== t.effectElements[2].p.v || t.effectElements[2].p.k) {
                        var r, n = createNS("feMerge");
                        filter.appendChild(n), (r = createNS("feMergeNode")).setAttribute("in", "SourceGraphic"), n.appendChild(r), (r = createNS("feMergeNode")).setAttribute("in", "f2"), n.appendChild(r)
                    }
                }

                function SVGFillFilter(filter, t) {
                    this.filterManager = t;
                    var e = createNS("feColorMatrix");
                    e.setAttribute("type", "matrix"), e.setAttribute("color-interpolation-filters", "sRGB"), e.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), filter.appendChild(e), this.matrixFilter = e
                }

                function SVGGaussianBlurEffect(filter, t) {
                    filter.setAttribute("x", "-100%"), filter.setAttribute("y", "-100%"), filter.setAttribute("width", "300%"), filter.setAttribute("height", "300%"), this.filterManager = t;
                    var e = createNS("feGaussianBlur");
                    filter.appendChild(e), this.feGaussianBlur = e
                }

                function SVGStrokeEffect(t, e) {
                    this.initialized = !1, this.filterManager = e, this.elem = t, this.paths = []
                }

                function SVGTritoneFilter(filter, t) {
                    this.filterManager = t;
                    var e = createNS("feColorMatrix");
                    e.setAttribute("type", "matrix"), e.setAttribute("color-interpolation-filters", "linearRGB"), e.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), e.setAttribute("result", "f1"), filter.appendChild(e);
                    var r = createNS("feComponentTransfer");
                    r.setAttribute("color-interpolation-filters", "sRGB"), filter.appendChild(r), this.matrixFilter = r;
                    var n = createNS("feFuncR");
                    n.setAttribute("type", "table"), r.appendChild(n), this.feFuncR = n;
                    var o = createNS("feFuncG");
                    o.setAttribute("type", "table"), r.appendChild(o), this.feFuncG = o;
                    var h = createNS("feFuncB");
                    h.setAttribute("type", "table"), r.appendChild(h), this.feFuncB = h
                }

                function SVGProLevelsFilter(filter, t) {
                    this.filterManager = t;
                    var e = this.filterManager.effectElements,
                        r = createNS("feComponentTransfer");
                    (e[10].p.k || 0 !== e[10].p.v || e[11].p.k || 1 !== e[11].p.v || e[12].p.k || 1 !== e[12].p.v || e[13].p.k || 0 !== e[13].p.v || e[14].p.k || 1 !== e[14].p.v) && (this.feFuncR = this.createFeFunc("feFuncR", r)), (e[17].p.k || 0 !== e[17].p.v || e[18].p.k || 1 !== e[18].p.v || e[19].p.k || 1 !== e[19].p.v || e[20].p.k || 0 !== e[20].p.v || e[21].p.k || 1 !== e[21].p.v) && (this.feFuncG = this.createFeFunc("feFuncG", r)), (e[24].p.k || 0 !== e[24].p.v || e[25].p.k || 1 !== e[25].p.v || e[26].p.k || 1 !== e[26].p.v || e[27].p.k || 0 !== e[27].p.v || e[28].p.k || 1 !== e[28].p.v) && (this.feFuncB = this.createFeFunc("feFuncB", r)), (e[31].p.k || 0 !== e[31].p.v || e[32].p.k || 1 !== e[32].p.v || e[33].p.k || 1 !== e[33].p.v || e[34].p.k || 0 !== e[34].p.v || e[35].p.k || 1 !== e[35].p.v) && (this.feFuncA = this.createFeFunc("feFuncA", r)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (r.setAttribute("color-interpolation-filters", "sRGB"), filter.appendChild(r), r = createNS("feComponentTransfer")), (e[3].p.k || 0 !== e[3].p.v || e[4].p.k || 1 !== e[4].p.v || e[5].p.k || 1 !== e[5].p.v || e[6].p.k || 0 !== e[6].p.v || e[7].p.k || 1 !== e[7].p.v) && (r.setAttribute("color-interpolation-filters", "sRGB"), filter.appendChild(r), this.feFuncRComposed = this.createFeFunc("feFuncR", r), this.feFuncGComposed = this.createFeFunc("feFuncG", r), this.feFuncBComposed = this.createFeFunc("feFuncB", r))
                }

                function SVGDropShadowEffect(filter, t) {
                    var e = t.container.globalData.renderConfig.filterSize;
                    filter.setAttribute("x", e.x), filter.setAttribute("y", e.y), filter.setAttribute("width", e.width), filter.setAttribute("height", e.height), this.filterManager = t;
                    var r = createNS("feGaussianBlur");
                    r.setAttribute("in", "SourceAlpha"), r.setAttribute("result", "drop_shadow_1"), r.setAttribute("stdDeviation", "0"), this.feGaussianBlur = r, filter.appendChild(r);
                    var n = createNS("feOffset");
                    n.setAttribute("dx", "25"), n.setAttribute("dy", "0"), n.setAttribute("in", "drop_shadow_1"), n.setAttribute("result", "drop_shadow_2"), this.feOffset = n, filter.appendChild(n);
                    var o = createNS("feFlood");
                    o.setAttribute("flood-color", "#00ff00"), o.setAttribute("flood-opacity", "1"), o.setAttribute("result", "drop_shadow_3"), this.feFlood = o, filter.appendChild(o);
                    var h = createNS("feComposite");
                    h.setAttribute("in", "drop_shadow_3"), h.setAttribute("in2", "drop_shadow_2"), h.setAttribute("operator", "in"), h.setAttribute("result", "drop_shadow_4"), filter.appendChild(h);
                    var l, c = createNS("feMerge");
                    filter.appendChild(c), l = createNS("feMergeNode"), c.appendChild(l), (l = createNS("feMergeNode")).setAttribute("in", "SourceGraphic"), this.feMergeNode = l, this.feMerge = c, this.originalNodeAdded = !1, c.appendChild(l)
                }
                ShapeTransformManager.prototype = {
                    addTransformSequence: function (t) {
                        var i, e = t.length,
                            r = "_";
                        for (i = 0; i < e; i += 1) r += t[i].transform.key + "_";
                        var n = this.sequences[r];
                        return n || (n = {
                            transforms: [].concat(t),
                            finalTransform: new Matrix,
                            _mdf: !1
                        }, this.sequences[r] = n, this.sequenceList.push(n)), n
                    },
                    processSequence: function (t, e) {
                        for (var r, i = 0, n = t.transforms.length, o = e; i < n && !e;) {
                            if (t.transforms[i].transform.mProps._mdf) {
                                o = !0;
                                break
                            }
                            i += 1
                        }
                        if (o)
                            for (t.finalTransform.reset(), i = n - 1; i >= 0; i -= 1) r = t.transforms[i].transform.mProps.v.props, t.finalTransform.transform(r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15]);
                        t._mdf = o
                    },
                    processSequences: function (t) {
                        var i, e = this.sequenceList.length;
                        for (i = 0; i < e; i += 1) this.processSequence(this.sequenceList[i], t)
                    },
                    getNewKey: function () {
                        return this.transform_key_count += 1, "_" + this.transform_key_count
                    }
                }, CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated, BaseElement.prototype = {
                    checkMasks: function () {
                        if (!this.data.hasMask) return !1;
                        for (var i = 0, t = this.data.masksProperties.length; i < t;) {
                            if ("n" !== this.data.masksProperties[i].mode && !1 !== this.data.masksProperties[i].cl) return !0;
                            i += 1
                        }
                        return !1
                    },
                    initExpressions: function () {
                        this.layerInterface = LayerExpressionInterface(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
                        var t = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
                        this.layerInterface.registerEffectsInterface(t), 0 === this.data.ty || this.data.xt ? this.compInterface = CompExpressionInterface(this) : 4 === this.data.ty ? (this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : 5 === this.data.ty && (this.layerInterface.textInterface = TextExpressionInterface(this), this.layerInterface.text = this.layerInterface.textInterface)
                    },
                    setBlendMode: function () {
                        var t = getBlendMode(this.data.bm);
                        (this.baseElement || this.layerElement).style["mix-blend-mode"] = t
                    },
                    initBaseData: function (data, t, e) {
                        this.globalData = t, this.comp = e, this.data = data, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties)
                    },
                    getType: function () {
                        return this.type
                    },
                    sourceRectAtTime: function () {}
                }, NullElement.prototype.prepareFrame = function (t) {
                    this.prepareProperties(t, !0)
                }, NullElement.prototype.renderFrame = function () {}, NullElement.prototype.getBaseElement = function () {
                    return null
                }, NullElement.prototype.destroy = function () {}, NullElement.prototype.sourceRectAtTime = function () {}, NullElement.prototype.hide = function () {}, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement), SVGBaseElement.prototype = {
                    initRendererElement: function () {
                        this.layerElement = createNS("g")
                    },
                    createContainerElements: function () {
                        this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1;
                        var t, e, r, n = null;
                        if (this.data.td) {
                            if (3 == this.data.td || 1 == this.data.td) {
                                var o = createNS("mask");
                                o.setAttribute("id", this.layerId), o.setAttribute("mask-type", 3 == this.data.td ? "luminance" : "alpha"), o.appendChild(this.layerElement), n = o, this.globalData.defs.appendChild(o), featureSupport.maskType || 1 != this.data.td || (o.setAttribute("mask-type", "luminance"), t = createElementID(), e = filtersFactory.createFilter(t), this.globalData.defs.appendChild(e), e.appendChild(filtersFactory.createAlphaToLuminanceFilter()), (r = createNS("g")).appendChild(this.layerElement), n = r, o.appendChild(r), r.setAttribute("filter", "url(" + locationHref + "#" + t + ")"))
                            } else if (2 == this.data.td) {
                                var h = createNS("mask");
                                h.setAttribute("id", this.layerId), h.setAttribute("mask-type", "alpha");
                                var l = createNS("g");
                                h.appendChild(l), t = createElementID(), e = filtersFactory.createFilter(t);
                                var c = createNS("feComponentTransfer");
                                c.setAttribute("in", "SourceGraphic"), e.appendChild(c);
                                var d = createNS("feFuncA");
                                d.setAttribute("type", "table"), d.setAttribute("tableValues", "1.0 0.0"), c.appendChild(d), this.globalData.defs.appendChild(e);
                                var m = createNS("rect");
                                m.setAttribute("width", this.comp.data.w), m.setAttribute("height", this.comp.data.h), m.setAttribute("x", "0"), m.setAttribute("y", "0"), m.setAttribute("fill", "#ffffff"), m.setAttribute("opacity", "0"), l.setAttribute("filter", "url(" + locationHref + "#" + t + ")"), l.appendChild(m), l.appendChild(this.layerElement), n = l, featureSupport.maskType || (h.setAttribute("mask-type", "luminance"), e.appendChild(filtersFactory.createAlphaToLuminanceFilter()), r = createNS("g"), l.appendChild(m), r.appendChild(this.layerElement), n = r, l.appendChild(r)), this.globalData.defs.appendChild(h)
                            }
                        } else this.data.tt ? (this.matteElement.appendChild(this.layerElement), n = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
                        if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 === this.data.ty && !this.data.hd) {
                            var f = createNS("clipPath"),
                                y = createNS("path");
                            y.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                            var v = createElementID();
                            if (f.setAttribute("id", v), f.appendChild(y), this.globalData.defs.appendChild(f), this.checkMasks()) {
                                var x = createNS("g");
                                x.setAttribute("clip-path", "url(" + locationHref + "#" + v + ")"), x.appendChild(this.layerElement), this.transformedElement = x, n ? n.appendChild(this.transformedElement) : this.baseElement = this.transformedElement
                            } else this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + v + ")")
                        }
                        0 !== this.data.bm && this.setBlendMode()
                    },
                    renderElement: function () {
                        this.finalTransform._matMdf && this.transformedElement.setAttribute("transform", this.finalTransform.mat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.mProp.o.v)
                    },
                    destroyBaseElement: function () {
                        this.layerElement = null, this.matteElement = null, this.maskManager.destroy()
                    },
                    getBaseElement: function () {
                        return this.data.hd ? null : this.baseElement
                    },
                    createRenderableComponents: function () {
                        this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this)
                    },
                    setMatte: function (t) {
                        this.matteElement && this.matteElement.setAttribute("mask", "url(" + locationHref + "#" + t + ")")
                    }
                }, IShapeElement.prototype = {
                    addShapeToModifiers: function (data) {
                        var i, t = this.shapeModifiers.length;
                        for (i = 0; i < t; i += 1) this.shapeModifiers[i].addShape(data)
                    },
                    isShapeInAnimatedModifiers: function (data) {
                        for (var t = this.shapeModifiers.length; 0 < t;)
                            if (this.shapeModifiers[0].isAnimatedWithShape(data)) return !0;
                        return !1
                    },
                    renderModifiers: function () {
                        if (this.shapeModifiers.length) {
                            var i, t = this.shapes.length;
                            for (i = 0; i < t; i += 1) this.shapes[i].sh.reset();
                            for (i = (t = this.shapeModifiers.length) - 1; i >= 0 && !this.shapeModifiers[i].processShapes(this._isFirstFrame); i -= 1);
                        }
                    },
                    searchProcessedElement: function (t) {
                        for (var e = this.processedElements, i = 0, r = e.length; i < r;) {
                            if (e[i].elem === t) return e[i].pos;
                            i += 1
                        }
                        return 0
                    },
                    addProcessedElement: function (t, e) {
                        for (var r = this.processedElements, i = r.length; i;)
                            if (r[i -= 1].elem === t) return void(r[i].pos = e);
                        r.push(new ProcessedElement(t, e))
                    },
                    prepareFrame: function (t) {
                        this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange)
                    }
                }, ITextElement.prototype.initElement = function (data, t, e) {
                    this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(data, t, e), this.textProperty = new TextProperty(this, data.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this), this.initTransform(data, t, e), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties)
                }, ITextElement.prototype.prepareFrame = function (t) {
                    this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1)
                }, ITextElement.prototype.createPathShape = function (t, e) {
                    var r, n, o = e.length,
                        h = "";
                    for (r = 0; r < o; r += 1) n = e[r].ks.k, h += buildShapeString(n, n.i.length, !0, t);
                    return h
                }, ITextElement.prototype.updateDocumentData = function (t, e) {
                    this.textProperty.updateDocumentData(t, e)
                }, ITextElement.prototype.canResizeFont = function (t) {
                    this.textProperty.canResizeFont(t)
                }, ITextElement.prototype.setMinimumFontSize = function (t) {
                    this.textProperty.setMinimumFontSize(t)
                }, ITextElement.prototype.applyTextPropertiesToMatrix = function (t, e, r, n, o) {
                    switch (t.ps && e.translate(t.ps[0], t.ps[1] + t.ascent, 0), e.translate(0, -t.ls, 0), t.j) {
                        case 1:
                            e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[r]), 0, 0);
                            break;
                        case 2:
                            e.translate(t.justifyOffset + (t.boxWidth - t.lineWidths[r]) / 2, 0, 0)
                    }
                    e.translate(n, o, 0)
                }, ITextElement.prototype.buildColor = function (t) {
                    return "rgb(" + Math.round(255 * t[0]) + "," + Math.round(255 * t[1]) + "," + Math.round(255 * t[2]) + ")"
                }, ITextElement.prototype.emptyProp = new LetterProps, ITextElement.prototype.destroy = function () {}, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function (data, t, e) {
                    this.initFrame(), this.initBaseData(data, t, e), this.initTransform(data, t, e), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), !this.data.xt && t.progressiveLoad || this.buildAllItems(), this.hide()
                }, ICompElement.prototype.prepareFrame = function (t) {
                    if (this._mdf = !1, this.prepareRenderableFrame(t), this.prepareProperties(t, this.isInRange), this.isInRange || this.data.xt) {
                        if (this.tm._placeholder) this.renderedFrame = t / this.data.sr;
                        else {
                            var e = this.tm.v;
                            e === this.data.op && (e = this.data.op - 1), this.renderedFrame = e
                        }
                        var i, r = this.elements.length;
                        for (this.completeLayers || this.checkLayers(this.renderedFrame), i = r - 1; i >= 0; i -= 1)(this.completeLayers || this.elements[i]) && (this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st), this.elements[i]._mdf && (this._mdf = !0))
                    }
                }, ICompElement.prototype.renderInnerContent = function () {
                    var i, t = this.layers.length;
                    for (i = 0; i < t; i += 1)(this.completeLayers || this.elements[i]) && this.elements[i].renderFrame()
                }, ICompElement.prototype.setElements = function (t) {
                    this.elements = t
                }, ICompElement.prototype.getElements = function () {
                    return this.elements
                }, ICompElement.prototype.destroyElements = function () {
                    var i, t = this.layers.length;
                    for (i = 0; i < t; i += 1) this.elements[i] && this.elements[i].destroy()
                }, ICompElement.prototype.destroy = function () {
                    this.destroyElements(), this.destroyBaseElement()
                }, extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function () {
                    var t = this.globalData.getAssetsPath(this.assetData);
                    this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", t), this.layerElement.appendChild(this.innerElem)
                }, IImageElement.prototype.sourceRectAtTime = function () {
                    return this.sourceRect
                }, extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function () {
                    var rect = createNS("rect");
                    rect.setAttribute("width", this.data.sw), rect.setAttribute("height", this.data.sh), rect.setAttribute("fill", this.data.sc), this.layerElement.appendChild(rect)
                }, AudioElement.prototype.prepareFrame = function (t) {
                    if (this.prepareRenderableFrame(t, !0), this.prepareProperties(t, !0), this.tm._placeholder) this._currentTime = t / this.data.sr;
                    else {
                        var e = this.tm.v;
                        this._currentTime = e
                    }
                }, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function () {
                    this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0))
                }, AudioElement.prototype.show = function () {}, AudioElement.prototype.hide = function () {
                    this.audio.pause(), this._isPlaying = !1
                }, AudioElement.prototype.pause = function () {
                    this.audio.pause(), this._isPlaying = !1, this._canPlay = !1
                }, AudioElement.prototype.resume = function () {
                    this._canPlay = !0
                }, AudioElement.prototype.setRate = function (t) {
                    this.audio.rate(t)
                }, AudioElement.prototype.volume = function (t) {
                    this.audio.volume(t)
                }, AudioElement.prototype.getBaseElement = function () {
                    return null
                }, AudioElement.prototype.destroy = function () {}, AudioElement.prototype.sourceRectAtTime = function () {}, AudioElement.prototype.initExpressions = function () {}, FootageElement.prototype.prepareFrame = function () {}, extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement), FootageElement.prototype.getBaseElement = function () {
                    return null
                }, FootageElement.prototype.renderFrame = function () {}, FootageElement.prototype.destroy = function () {}, FootageElement.prototype.initExpressions = function () {
                    this.layerInterface = FootageInterface(this)
                }, FootageElement.prototype.getFootageData = function () {
                    return this.footageData
                }, extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement), extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement), SVGTextLottieElement.prototype.createContent = function () {
                    this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
                }, SVGTextLottieElement.prototype.buildTextContents = function (t) {
                    for (var i = 0, e = t.length, r = [], n = ""; i < e;) t[i] === String.fromCharCode(13) || t[i] === String.fromCharCode(3) ? (r.push(n), n = "") : n += t[i], i += 1;
                    return r.push(n), r
                }, SVGTextLottieElement.prototype.buildNewText = function () {
                    var i, t, e = this.textProperty.currentData;
                    this.renderedLetters = createSizedArray(e ? e.l.length : 0), e.fc ? this.layerElement.setAttribute("fill", this.buildColor(e.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), e.sc && (this.layerElement.setAttribute("stroke", this.buildColor(e.sc)), this.layerElement.setAttribute("stroke-width", e.sw)), this.layerElement.setAttribute("font-size", e.finalSize);
                    var r = this.globalData.fontManager.getFontByName(e.f);
                    if (r.fClass) this.layerElement.setAttribute("class", r.fClass);
                    else {
                        this.layerElement.setAttribute("font-family", r.fFamily);
                        var n = e.fWeight,
                            o = e.fStyle;
                        this.layerElement.setAttribute("font-style", o), this.layerElement.setAttribute("font-weight", n)
                    }
                    this.layerElement.setAttribute("aria-label", e.t);
                    var h, l = e.l || [],
                        c = !!this.globalData.fontManager.chars;
                    t = l.length;
                    var d, m = this.mHelper,
                        f = "",
                        y = this.data.singleShape,
                        v = 0,
                        x = 0,
                        _ = !0,
                        M = .001 * e.tr * e.finalSize;
                    if (!y || c || e.sz) {
                        var S, w, E = this.textSpans.length;
                        for (i = 0; i < t; i += 1) c && y && 0 !== i || (h = E > i ? this.textSpans[i] : createNS(c ? "path" : "text"), E <= i && (h.setAttribute("stroke-linecap", "butt"), h.setAttribute("stroke-linejoin", "round"), h.setAttribute("stroke-miterlimit", "4"), this.textSpans[i] = h, this.layerElement.appendChild(h)), h.style.display = "inherit"), m.reset(), m.scale(e.finalSize / 100, e.finalSize / 100), y && (l[i].n && (v = -M, x += e.yOffset, x += _ ? 1 : 0, _ = !1), this.applyTextPropertiesToMatrix(e, m, l[i].line, v, x), v += l[i].l || 0, v += M), c ? (d = (S = (w = this.globalData.fontManager.getCharData(e.finalText[i], r.fStyle, this.globalData.fontManager.getFontByName(e.f).fFamily)) && w.data || {}).shapes ? S.shapes[0].it : [], y ? f += this.createPathShape(m, d) : h.setAttribute("d", this.createPathShape(m, d))) : (y && h.setAttribute("transform", "translate(" + m.props[12] + "," + m.props[13] + ")"), h.textContent = l[i].val, h.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"));
                        y && h && h.setAttribute("d", f)
                    } else {
                        var T = this.textContainer,
                            A = "start";
                        switch (e.j) {
                            case 1:
                                A = "end";
                                break;
                            case 2:
                                A = "middle";
                                break;
                            default:
                                A = "start"
                        }
                        T.setAttribute("text-anchor", A), T.setAttribute("letter-spacing", M);
                        var P = this.buildTextContents(e.finalText);
                        for (t = P.length, x = e.ps ? e.ps[1] + e.ascent : 0, i = 0; i < t; i += 1)(h = this.textSpans[i] || createNS("tspan")).textContent = P[i], h.setAttribute("x", 0), h.setAttribute("y", x), h.style.display = "inherit", T.appendChild(h), this.textSpans[i] = h, x += e.finalLineHeight;
                        this.layerElement.appendChild(T)
                    }
                    for (; i < this.textSpans.length;) this.textSpans[i].style.display = "none", i += 1;
                    this._sizeChanged = !0
                }, SVGTextLottieElement.prototype.sourceRectAtTime = function () {
                    if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) {
                        this._sizeChanged = !1;
                        var t = this.layerElement.getBBox();
                        this.bbox = {
                            top: t.y,
                            left: t.x,
                            width: t.width,
                            height: t.height
                        }
                    }
                    return this.bbox
                }, SVGTextLottieElement.prototype.renderInnerContent = function () {
                    if (!this.data.singleShape && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
                        var i, t;
                        this._sizeChanged = !0;
                        var e, r, n = this.textAnimator.renderedLetters,
                            o = this.textProperty.currentData.l;
                        for (t = o.length, i = 0; i < t; i += 1) o[i].n || (e = n[i], r = this.textSpans[i], e._mdf.m && r.setAttribute("transform", e.m), e._mdf.o && r.setAttribute("opacity", e.o), e._mdf.sw && r.setAttribute("stroke-width", e.sw), e._mdf.sc && r.setAttribute("stroke", e.sc), e._mdf.fc && r.setAttribute("fill", e.fc))
                    }
                }, extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function () {}, SVGShapeElement.prototype.identityMatrix = new Matrix, SVGShapeElement.prototype.buildExpressionInterface = function () {}, SVGShapeElement.prototype.createContent = function () {
                    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes()
                }, SVGShapeElement.prototype.filterUniqueShapes = function () {
                    var i, t, e, style, r = this.shapes.length,
                        n = this.stylesList.length,
                        o = [],
                        h = !1;
                    for (e = 0; e < n; e += 1) {
                        for (style = this.stylesList[e], h = !1, o.length = 0, i = 0; i < r; i += 1) - 1 !== (t = this.shapes[i]).styles.indexOf(style) && (o.push(t), h = t._isAnimated || h);
                        o.length > 1 && h && this.setShapesAsAnimated(o)
                    }
                }, SVGShapeElement.prototype.setShapesAsAnimated = function (t) {
                    var i, e = t.length;
                    for (i = 0; i < e; i += 1) t[i].setAsAnimated()
                }, SVGShapeElement.prototype.createStyleElement = function (data, t) {
                    var e, r = new SVGStyleData(data, t),
                        n = r.pElem;
                    return "st" === data.ty ? e = new SVGStrokeStyleData(this, data, r) : "fl" === data.ty ? e = new SVGFillStyleData(this, data, r) : "gf" !== data.ty && "gs" !== data.ty || (e = new("gf" === data.ty ? SVGGradientFillStyleData : SVGGradientStrokeStyleData)(this, data, r), this.globalData.defs.appendChild(e.gf), e.maskId && (this.globalData.defs.appendChild(e.ms), this.globalData.defs.appendChild(e.of), n.setAttribute("mask", "url(" + locationHref + "#" + e.maskId + ")"))), "st" !== data.ty && "gs" !== data.ty || (n.setAttribute("stroke-linecap", lineCapEnum[data.lc || 2]), n.setAttribute("stroke-linejoin", lineJoinEnum[data.lj || 2]), n.setAttribute("fill-opacity", "0"), 1 === data.lj && n.setAttribute("stroke-miterlimit", data.ml)), 2 === data.r && n.setAttribute("fill-rule", "evenodd"), data.ln && n.setAttribute("id", data.ln), data.cl && n.setAttribute("class", data.cl), data.bm && (n.style["mix-blend-mode"] = getBlendMode(data.bm)), this.stylesList.push(r), this.addToAnimatedContents(data, e), e
                }, SVGShapeElement.prototype.createGroupElement = function (data) {
                    var t = new ShapeGroupData;
                    return data.ln && t.gr.setAttribute("id", data.ln), data.cl && t.gr.setAttribute("class", data.cl), data.bm && (t.gr.style["mix-blend-mode"] = getBlendMode(data.bm)), t
                }, SVGShapeElement.prototype.createTransformElement = function (data, t) {
                    var e = TransformPropertyFactory.getTransformProperty(this, data, this),
                        r = new SVGTransformData(e, e.o, t);
                    return this.addToAnimatedContents(data, r), r
                }, SVGShapeElement.prototype.createShapeElement = function (data, t, e) {
                    var r = 4;
                    "rc" === data.ty ? r = 5 : "el" === data.ty ? r = 6 : "sr" === data.ty && (r = 7);
                    var n = new SVGShapeData(t, e, ShapePropertyFactory.getShapeProp(this, data, r, this));
                    return this.shapes.push(n), this.addShapeToModifiers(n), this.addToAnimatedContents(data, n), n
                }, SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {
                    for (var i = 0, t = this.animatedContents.length; i < t;) {
                        if (this.animatedContents[i].element === element) return;
                        i += 1
                    }
                    this.animatedContents.push({
                        fn: SVGElementsRenderer.createRenderFunction(data),
                        element: element,
                        data: data
                    })
                }, SVGShapeElement.prototype.setElementStyles = function (t) {
                    var e, r = t.styles,
                        n = this.stylesList.length;
                    for (e = 0; e < n; e += 1) this.stylesList[e].closed || r.push(this.stylesList[e])
                }, SVGShapeElement.prototype.reloadShapes = function () {
                    var i;
                    this._isFirstFrame = !0;
                    var t = this.itemsData.length;
                    for (i = 0; i < t; i += 1) this.prevViewData[i] = this.itemsData[i];
                    for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), t = this.dynamicProperties.length, i = 0; i < t; i += 1) this.dynamicProperties[i].getValue();
                    this.renderModifiers()
                }, SVGShapeElement.prototype.searchShapes = function (t, e, r, n, o, h, l) {
                    var i, c, d, m, f, y, v = [].concat(h),
                        x = t.length - 1,
                        _ = [],
                        M = [];
                    for (i = x; i >= 0; i -= 1) {
                        if ((y = this.searchProcessedElement(t[i])) ? e[i] = r[y - 1] : t[i]._render = l, "fl" === t[i].ty || "st" === t[i].ty || "gf" === t[i].ty || "gs" === t[i].ty) y ? e[i].style.closed = !1 : e[i] = this.createStyleElement(t[i], o), t[i]._render && n.appendChild(e[i].style.pElem), _.push(e[i].style);
                        else if ("gr" === t[i].ty) {
                            if (y)
                                for (d = e[i].it.length, c = 0; c < d; c += 1) e[i].prevViewData[c] = e[i].it[c];
                            else e[i] = this.createGroupElement(t[i]);
                            this.searchShapes(t[i].it, e[i].it, e[i].prevViewData, e[i].gr, o + 1, v, l), t[i]._render && n.appendChild(e[i].gr)
                        } else "tr" === t[i].ty ? (y || (e[i] = this.createTransformElement(t[i], n)), m = e[i].transform, v.push(m)) : "sh" === t[i].ty || "rc" === t[i].ty || "el" === t[i].ty || "sr" === t[i].ty ? (y || (e[i] = this.createShapeElement(t[i], v, o)), this.setElementStyles(e[i])) : "tm" === t[i].ty || "rd" === t[i].ty || "ms" === t[i].ty || "pb" === t[i].ty ? (y ? (f = e[i]).closed = !1 : ((f = ShapeModifiers.getModifier(t[i].ty)).init(this, t[i]), e[i] = f, this.shapeModifiers.push(f)), M.push(f)) : "rp" === t[i].ty && (y ? (f = e[i]).closed = !0 : (f = ShapeModifiers.getModifier(t[i].ty), e[i] = f, f.init(this, t, i, e), this.shapeModifiers.push(f), l = !1), M.push(f));
                        this.addProcessedElement(t[i], i + 1)
                    }
                    for (x = _.length, i = 0; i < x; i += 1) _[i].closed = !0;
                    for (x = M.length, i = 0; i < x; i += 1) M[i].closed = !0
                }, SVGShapeElement.prototype.renderInnerContent = function () {
                    var i;
                    this.renderModifiers();
                    var t = this.stylesList.length;
                    for (i = 0; i < t; i += 1) this.stylesList[i].reset();
                    for (this.renderShape(), i = 0; i < t; i += 1)(this.stylesList[i]._mdf || this._isFirstFrame) && (this.stylesList[i].msElem && (this.stylesList[i].msElem.setAttribute("d", this.stylesList[i].d), this.stylesList[i].d = "M0 0" + this.stylesList[i].d), this.stylesList[i].pElem.setAttribute("d", this.stylesList[i].d || "M0 0"))
                }, SVGShapeElement.prototype.renderShape = function () {
                    var i, t, e = this.animatedContents.length;
                    for (i = 0; i < e; i += 1) t = this.animatedContents[i], (this._isFirstFrame || t.element._isAnimated) && !0 !== t.data && t.fn(t.data, t.element, this._isFirstFrame)
                }, SVGShapeElement.prototype.destroy = function () {
                    this.destroyBaseElement(), this.shapesData = null, this.itemsData = null
                }, SVGTintFilter.prototype.renderFrame = function (t) {
                    if (t || this.filterManager._mdf) {
                        var e = this.filterManager.effectElements[0].p.v,
                            r = this.filterManager.effectElements[1].p.v,
                            n = this.filterManager.effectElements[2].p.v / 100;
                        this.matrixFilter.setAttribute("values", r[0] - e[0] + " 0 0 0 " + e[0] + " " + (r[1] - e[1]) + " 0 0 0 " + e[1] + " " + (r[2] - e[2]) + " 0 0 0 " + e[2] + " 0 0 0 " + n + " 0")
                    }
                }, SVGFillFilter.prototype.renderFrame = function (t) {
                    if (t || this.filterManager._mdf) {
                        var e = this.filterManager.effectElements[2].p.v,
                            r = this.filterManager.effectElements[6].p.v;
                        this.matrixFilter.setAttribute("values", "0 0 0 0 " + e[0] + " 0 0 0 0 " + e[1] + " 0 0 0 0 " + e[2] + " 0 0 0 " + r + " 0")
                    }
                }, SVGGaussianBlurEffect.prototype.renderFrame = function (t) {
                    if (t || this.filterManager._mdf) {
                        var e = .3 * this.filterManager.effectElements[0].p.v,
                            r = this.filterManager.effectElements[1].p.v,
                            n = 3 == r ? 0 : e,
                            o = 2 == r ? 0 : e;
                        this.feGaussianBlur.setAttribute("stdDeviation", n + " " + o);
                        var h = 1 == this.filterManager.effectElements[2].p.v ? "wrap" : "duplicate";
                        this.feGaussianBlur.setAttribute("edgeMode", h)
                    }
                }, SVGStrokeEffect.prototype.initialize = function () {
                    var path, t, i, e, r = this.elem.layerElement.children || this.elem.layerElement.childNodes;
                    for (1 === this.filterManager.effectElements[1].p.v ? (e = this.elem.maskManager.masksProperties.length, i = 0) : e = 1 + (i = this.filterManager.effectElements[0].p.v - 1), (t = createNS("g")).setAttribute("fill", "none"), t.setAttribute("stroke-linecap", "round"), t.setAttribute("stroke-dashoffset", 1); i < e; i += 1) path = createNS("path"), t.appendChild(path), this.paths.push({
                        p: path,
                        m: i
                    });
                    if (3 === this.filterManager.effectElements[10].p.v) {
                        var mask = createNS("mask"),
                            n = createElementID();
                        mask.setAttribute("id", n), mask.setAttribute("mask-type", "alpha"), mask.appendChild(t), this.elem.globalData.defs.appendChild(mask);
                        var g = createNS("g");
                        for (g.setAttribute("mask", "url(" + locationHref + "#" + n + ")"); r[0];) g.appendChild(r[0]);
                        this.elem.layerElement.appendChild(g), this.masker = mask, t.setAttribute("stroke", "#fff")
                    } else if (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) {
                        if (2 === this.filterManager.effectElements[10].p.v)
                            for (r = this.elem.layerElement.children || this.elem.layerElement.childNodes; r.length;) this.elem.layerElement.removeChild(r[0]);
                        this.elem.layerElement.appendChild(t), this.elem.layerElement.removeAttribute("mask"), t.setAttribute("stroke", "#fff")
                    }
                    this.initialized = !0, this.pathMasker = t
                }, SVGStrokeEffect.prototype.renderFrame = function (t) {
                    var i;
                    this.initialized || this.initialize();
                    var mask, path, e = this.paths.length;
                    for (i = 0; i < e; i += 1)
                        if (-1 !== this.paths[i].m && (mask = this.elem.maskManager.viewData[this.paths[i].m], path = this.paths[i].p, (t || this.filterManager._mdf || mask.prop._mdf) && path.setAttribute("d", mask.lastPath), t || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf)) {
                            var r;
                            if (0 !== this.filterManager.effectElements[7].p.v || 100 !== this.filterManager.effectElements[8].p.v) {
                                var s = .01 * Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v),
                                    n = .01 * Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v),
                                    o = path.getTotalLength();
                                r = "0 0 0 " + o * s + " ";
                                var h, l = o * (n - s),
                                    c = 1 + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01,
                                    d = Math.floor(l / c);
                                for (h = 0; h < d; h += 1) r += "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01 + " ";
                                r += "0 " + 10 * o + " 0 0"
                            } else r = "1 " + 2 * this.filterManager.effectElements[4].p.v * this.filterManager.effectElements[9].p.v * .01;
                            path.setAttribute("stroke-dasharray", r)
                        } if ((t || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", 2 * this.filterManager.effectElements[4].p.v), (t || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (1 === this.filterManager.effectElements[10].p.v || 2 === this.filterManager.effectElements[10].p.v) && (t || this.filterManager.effectElements[3].p._mdf)) {
                        var m = this.filterManager.effectElements[3].p.v;
                        this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(255 * m[0]) + "," + bmFloor(255 * m[1]) + "," + bmFloor(255 * m[2]) + ")")
                    }
                }, SVGTritoneFilter.prototype.renderFrame = function (t) {
                    if (t || this.filterManager._mdf) {
                        var e = this.filterManager.effectElements[0].p.v,
                            r = this.filterManager.effectElements[1].p.v,
                            n = this.filterManager.effectElements[2].p.v,
                            o = n[0] + " " + r[0] + " " + e[0],
                            h = n[1] + " " + r[1] + " " + e[1],
                            l = n[2] + " " + r[2] + " " + e[2];
                        this.feFuncR.setAttribute("tableValues", o), this.feFuncG.setAttribute("tableValues", h), this.feFuncB.setAttribute("tableValues", l)
                    }
                }, SVGProLevelsFilter.prototype.createFeFunc = function (t, e) {
                    var r = createNS(t);
                    return r.setAttribute("type", "table"), e.appendChild(r), r
                }, SVGProLevelsFilter.prototype.getTableValue = function (t, e, r, n, o) {
                    for (var h, l, c = 0, d = Math.min(t, e), m = Math.max(t, e), table = Array.call(null, {
                            length: 256
                        }), f = 0, y = o - n, v = e - t; c <= 256;) l = (h = c / 256) <= d ? v < 0 ? o : n : h >= m ? v < 0 ? n : o : n + y * Math.pow((h - t) / v, 1 / r), table[f] = l, f += 1, c += 256 / 255;
                    return table.join(" ")
                }, SVGProLevelsFilter.prototype.renderFrame = function (t) {
                    if (t || this.filterManager._mdf) {
                        var e, r = this.filterManager.effectElements;
                        this.feFuncRComposed && (t || r[3].p._mdf || r[4].p._mdf || r[5].p._mdf || r[6].p._mdf || r[7].p._mdf) && (e = this.getTableValue(r[3].p.v, r[4].p.v, r[5].p.v, r[6].p.v, r[7].p.v), this.feFuncRComposed.setAttribute("tableValues", e), this.feFuncGComposed.setAttribute("tableValues", e), this.feFuncBComposed.setAttribute("tableValues", e)), this.feFuncR && (t || r[10].p._mdf || r[11].p._mdf || r[12].p._mdf || r[13].p._mdf || r[14].p._mdf) && (e = this.getTableValue(r[10].p.v, r[11].p.v, r[12].p.v, r[13].p.v, r[14].p.v), this.feFuncR.setAttribute("tableValues", e)), this.feFuncG && (t || r[17].p._mdf || r[18].p._mdf || r[19].p._mdf || r[20].p._mdf || r[21].p._mdf) && (e = this.getTableValue(r[17].p.v, r[18].p.v, r[19].p.v, r[20].p.v, r[21].p.v), this.feFuncG.setAttribute("tableValues", e)), this.feFuncB && (t || r[24].p._mdf || r[25].p._mdf || r[26].p._mdf || r[27].p._mdf || r[28].p._mdf) && (e = this.getTableValue(r[24].p.v, r[25].p.v, r[26].p.v, r[27].p.v, r[28].p.v), this.feFuncB.setAttribute("tableValues", e)), this.feFuncA && (t || r[31].p._mdf || r[32].p._mdf || r[33].p._mdf || r[34].p._mdf || r[35].p._mdf) && (e = this.getTableValue(r[31].p.v, r[32].p.v, r[33].p.v, r[34].p.v, r[35].p.v), this.feFuncA.setAttribute("tableValues", e))
                    }
                }, SVGDropShadowEffect.prototype.renderFrame = function (t) {
                    if (t || this.filterManager._mdf) {
                        if ((t || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), t || this.filterManager.effectElements[0].p._mdf) {
                            var col = this.filterManager.effectElements[0].p.v;
                            this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(255 * col[0]), Math.round(255 * col[1]), Math.round(255 * col[2])))
                        }
                        if ((t || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), t || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                            var e = this.filterManager.effectElements[3].p.v,
                                r = (this.filterManager.effectElements[2].p.v - 90) * degToRads,
                                n = e * Math.cos(r),
                                o = e * Math.sin(r);
                            this.feOffset.setAttribute("dx", n), this.feOffset.setAttribute("dy", o)
                        }
                    }
                };
                var _svgMatteSymbols = [];

                function SVGMatte3Effect(t, e, r) {
                    this.initialized = !1, this.filterManager = e, this.filterElem = t, this.elem = r, r.matteElement = createNS("g"), r.matteElement.appendChild(r.layerElement), r.matteElement.appendChild(r.transformedElement), r.baseElement = r.matteElement
                }

                function SVGEffects(t) {
                    var i, e, r = t.data.ef ? t.data.ef.length : 0,
                        n = createElementID(),
                        o = filtersFactory.createFilter(n, !0),
                        h = 0;
                    for (this.filters = [], i = 0; i < r; i += 1) e = null, 20 === t.data.ef[i].ty ? (h += 1, e = new SVGTintFilter(o, t.effectsManager.effectElements[i])) : 21 === t.data.ef[i].ty ? (h += 1, e = new SVGFillFilter(o, t.effectsManager.effectElements[i])) : 22 === t.data.ef[i].ty ? e = new SVGStrokeEffect(t, t.effectsManager.effectElements[i]) : 23 === t.data.ef[i].ty ? (h += 1, e = new SVGTritoneFilter(o, t.effectsManager.effectElements[i])) : 24 === t.data.ef[i].ty ? (h += 1, e = new SVGProLevelsFilter(o, t.effectsManager.effectElements[i])) : 25 === t.data.ef[i].ty ? (h += 1, e = new SVGDropShadowEffect(o, t.effectsManager.effectElements[i])) : 28 === t.data.ef[i].ty ? e = new SVGMatte3Effect(o, t.effectsManager.effectElements[i], t) : 29 === t.data.ef[i].ty && (h += 1, e = new SVGGaussianBlurEffect(o, t.effectsManager.effectElements[i])), e && this.filters.push(e);
                    h && (t.globalData.defs.appendChild(o), t.layerElement.setAttribute("filter", "url(" + locationHref + "#" + n + ")")), this.filters.length && t.addRenderableComponent(this)
                }

                function CVContextData() {
                    var i;
                    for (this.saved = [], this.cArrPos = 0, this.cTr = new Matrix, this.cO = 1, this.savedOp = createTypedArray("float32", 15), i = 0; i < 15; i += 1) this.saved[i] = createTypedArray("float32", 16);
                    this._length = 15
                }

                function CVBaseElement() {}

                function CVImageElement(data, t, e) {
                    this.assetData = t.getAssetData(data.refId), this.img = t.imageLoader.getAsset(this.assetData), this.initElement(data, t, e)
                }

                function CVCompElement(data, t, e) {
                    this.completeLayers = !1, this.layers = data.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(data, t, e), this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, t.frameRate, this) : {
                        _placeholder: !0
                    }
                }

                function CVMaskElement(data, element) {
                    var i;
                    this.data = data, this.element = element, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length);
                    var t = this.masksProperties.length,
                        e = !1;
                    for (i = 0; i < t; i += 1) "n" !== this.masksProperties[i].mode && (e = !0), this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
                    this.hasMasks = e, e && this.element.addRenderableComponent(this)
                }

                function CVShapeElement(data, t, e) {
                    this.shapes = [], this.shapesData = data.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager, this.initElement(data, t, e)
                }

                function CVSolidElement(data, t, e) {
                    this.initElement(data, t, e)
                }

                function CVTextElement(data, t, e) {
                    this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = {
                        fill: "rgba(0,0,0,0)",
                        stroke: "rgba(0,0,0,0)",
                        sWidth: 0,
                        fValue: ""
                    }, this.initElement(data, t, e)
                }

                function CVEffects() {}

                function HBaseElement() {}

                function HSolidElement(data, t, e) {
                    this.initElement(data, t, e)
                }

                function HCompElement(data, t, e) {
                    this.layers = data.layers, this.supports3d = !data.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(data, t, e), this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, t.frameRate, this) : {
                        _placeholder: !0
                    }
                }

                function HShapeElement(data, t, e) {
                    this.shapes = [], this.shapesData = data.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(data, t, e), this.prevViewData = [], this.currentBBox = {
                        x: 999999,
                        y: -999999,
                        h: 0,
                        w: 0
                    }
                }

                function HTextElement(data, t, e) {
                    this.textSpans = [], this.textPaths = [], this.currentBBox = {
                        x: 999999,
                        y: -999999,
                        h: 0,
                        w: 0
                    }, this.renderType = "svg", this.isMasked = !1, this.initElement(data, t, e)
                }

                function HImageElement(data, t, e) {
                    this.assetData = t.getAssetData(data.refId), this.initElement(data, t, e)
                }

                function HCameraElement(data, t, e) {
                    this.initFrame(), this.initBaseData(data, t, e), this.initHierarchy();
                    var r = PropertyFactory.getProp;
                    if (this.pe = r(this, data.pe, 0, 0, this), data.ks.p.s ? (this.px = r(this, data.ks.p.x, 1, 0, this), this.py = r(this, data.ks.p.y, 1, 0, this), this.pz = r(this, data.ks.p.z, 1, 0, this)) : this.p = r(this, data.ks.p, 1, 0, this), data.ks.a && (this.a = r(this, data.ks.a, 1, 0, this)), data.ks.or.k.length && data.ks.or.k[0].to) {
                        var i, n = data.ks.or.k.length;
                        for (i = 0; i < n; i += 1) data.ks.or.k[i].to = null, data.ks.or.k[i].ti = null
                    }
                    this.or = r(this, data.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = r(this, data.ks.rx, 0, degToRads, this), this.ry = r(this, data.ks.ry, 0, degToRads, this), this.rz = r(this, data.ks.rz, 0, degToRads, this), this.mat = new Matrix, this._prevMat = new Matrix, this._isFirstFrame = !0, this.finalTransform = {
                        mProp: this
                    }
                }

                function HEffects() {}
                SVGMatte3Effect.prototype.findSymbol = function (mask) {
                    for (var i = 0, t = _svgMatteSymbols.length; i < t;) {
                        if (_svgMatteSymbols[i] === mask) return _svgMatteSymbols[i];
                        i += 1
                    }
                    return null
                }, SVGMatte3Effect.prototype.replaceInParent = function (mask, t) {
                    var e = mask.layerElement.parentNode;
                    if (e) {
                        for (var r, n = e.children, i = 0, o = n.length; i < o && n[i] !== mask.layerElement;) i += 1;
                        i <= o - 2 && (r = n[i + 1]);
                        var h = createNS("use");
                        h.setAttribute("href", "#" + t), r ? e.insertBefore(h, r) : e.appendChild(h)
                    }
                }, SVGMatte3Effect.prototype.setElementAsMask = function (t, mask) {
                    if (!this.findSymbol(mask)) {
                        var e = createElementID(),
                            r = createNS("mask");
                        r.setAttribute("id", mask.layerId), r.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(mask);
                        var defs = t.globalData.defs;
                        defs.appendChild(r);
                        var symbol = createNS("symbol");
                        symbol.setAttribute("id", e), this.replaceInParent(mask, e), symbol.appendChild(mask.layerElement), defs.appendChild(symbol);
                        var n = createNS("use");
                        n.setAttribute("href", "#" + e), r.appendChild(n), mask.data.hd = !1, mask.show()
                    }
                    t.setMatte(mask.layerId)
                }, SVGMatte3Effect.prototype.initialize = function () {
                    for (var t = this.filterManager.effectElements[0].p.v, e = this.elem.comp.elements, i = 0, r = e.length; i < r;) e[i] && e[i].data.ind === t && this.setElementAsMask(this.elem, e[i]), i += 1;
                    this.initialized = !0
                }, SVGMatte3Effect.prototype.renderFrame = function () {
                    this.initialized || this.initialize()
                }, SVGEffects.prototype.renderFrame = function (t) {
                    var i, e = this.filters.length;
                    for (i = 0; i < e; i += 1) this.filters[i].renderFrame(t)
                }, CVContextData.prototype.duplicate = function () {
                    var t = 2 * this._length,
                        e = this.savedOp;
                    this.savedOp = createTypedArray("float32", t), this.savedOp.set(e);
                    var i = 0;
                    for (i = this._length; i < t; i += 1) this.saved[i] = createTypedArray("float32", 16);
                    this._length = t
                }, CVContextData.prototype.reset = function () {
                    this.cArrPos = 0, this.cTr.reset(), this.cO = 1
                }, CVBaseElement.prototype = {
                    createElements: function () {},
                    initRendererElement: function () {},
                    createContainerElements: function () {
                        this.canvasContext = this.globalData.canvasContext, this.renderableEffectsManager = new CVEffects(this)
                    },
                    createContent: function () {},
                    setBlendMode: function () {
                        var t = this.globalData;
                        if (t.blendMode !== this.data.bm) {
                            t.blendMode = this.data.bm;
                            var e = getBlendMode(this.data.bm);
                            t.canvasContext.globalCompositeOperation = e
                        }
                    },
                    createRenderableComponents: function () {
                        this.maskManager = new CVMaskElement(this.data, this)
                    },
                    hideElement: function () {
                        this.hidden || this.isInRange && !this.isTransparent || (this.hidden = !0)
                    },
                    showElement: function () {
                        this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0)
                    },
                    renderFrame: function () {
                        if (!this.hidden && !this.data.hd) {
                            this.renderTransform(), this.renderRenderable(), this.setBlendMode();
                            var t = 0 === this.data.ty;
                            this.globalData.renderer.save(t), this.globalData.renderer.ctxTransform(this.finalTransform.mat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v), this.renderInnerContent(), this.globalData.renderer.restore(t), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1)
                        }
                    },
                    destroy: function () {
                        this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy()
                    },
                    mHelper: new Matrix
                }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function () {
                    if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
                        var canvas = createTag("canvas");
                        canvas.width = this.assetData.w, canvas.height = this.assetData.h;
                        var t, e, r = canvas.getContext("2d"),
                            n = this.img.width,
                            o = this.img.height,
                            h = n / o,
                            l = this.assetData.w / this.assetData.h,
                            c = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
                        h > l && "xMidYMid slice" === c || h < l && "xMidYMid slice" !== c ? t = (e = o) * l : e = (t = n) / l, r.drawImage(this.img, (n - t) / 2, (o - e) / 2, t, e, 0, 0, this.assetData.w, this.assetData.h), this.img = canvas
                    }
                }, CVImageElement.prototype.renderInnerContent = function () {
                    this.canvasContext.drawImage(this.img, 0, 0)
                }, CVImageElement.prototype.destroy = function () {
                    this.img = null
                }, extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function () {
                    var i, t = this.canvasContext;
                    for (t.beginPath(), t.moveTo(0, 0), t.lineTo(this.data.w, 0), t.lineTo(this.data.w, this.data.h), t.lineTo(0, this.data.h), t.lineTo(0, 0), t.clip(), i = this.layers.length - 1; i >= 0; i -= 1)(this.completeLayers || this.elements[i]) && this.elements[i].renderFrame()
                }, CVCompElement.prototype.destroy = function () {
                    var i;
                    for (i = this.layers.length - 1; i >= 0; i -= 1) this.elements[i] && this.elements[i].destroy();
                    this.layers = null, this.elements = null
                }, CVMaskElement.prototype.renderFrame = function () {
                    if (this.hasMasks) {
                        var i, t, e, data, r = this.element.finalTransform.mat,
                            n = this.element.canvasContext,
                            o = this.masksProperties.length;
                        for (n.beginPath(), i = 0; i < o; i += 1)
                            if ("n" !== this.masksProperties[i].mode) {
                                var h;
                                this.masksProperties[i].inv && (n.moveTo(0, 0), n.lineTo(this.element.globalData.compSize.w, 0), n.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), n.lineTo(0, this.element.globalData.compSize.h), n.lineTo(0, 0)), data = this.viewData[i].v, t = r.applyToPointArray(data.v[0][0], data.v[0][1], 0), n.moveTo(t[0], t[1]);
                                var l = data._length;
                                for (h = 1; h < l; h += 1) e = r.applyToTriplePoints(data.o[h - 1], data.i[h], data.v[h]), n.bezierCurveTo(e[0], e[1], e[2], e[3], e[4], e[5]);
                                e = r.applyToTriplePoints(data.o[h - 1], data.i[0], data.v[0]), n.bezierCurveTo(e[0], e[1], e[2], e[3], e[4], e[5])
                            } this.element.globalData.renderer.save(!0), n.clip()
                    }
                }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function () {
                    this.element = null
                }, extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = {
                    opacity: 1,
                    _opMdf: !1
                }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function () {
                    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
                }, CVShapeElement.prototype.createStyleElement = function (data, t) {
                    var e = {
                            data: data,
                            type: data.ty,
                            preTransforms: this.transformsManager.addTransformSequence(t),
                            transforms: [],
                            elements: [],
                            closed: !0 === data.hd
                        },
                        r = {};
                    if ("fl" === data.ty || "st" === data.ty ? (r.c = PropertyFactory.getProp(this, data.c, 1, 255, this), r.c.k || (e.co = "rgb(" + bmFloor(r.c.v[0]) + "," + bmFloor(r.c.v[1]) + "," + bmFloor(r.c.v[2]) + ")")) : "gf" !== data.ty && "gs" !== data.ty || (r.s = PropertyFactory.getProp(this, data.s, 1, null, this), r.e = PropertyFactory.getProp(this, data.e, 1, null, this), r.h = PropertyFactory.getProp(this, data.h || {
                            k: 0
                        }, 0, .01, this), r.a = PropertyFactory.getProp(this, data.a || {
                            k: 0
                        }, 0, degToRads, this), r.g = new GradientProperty(this, data.g, this)), r.o = PropertyFactory.getProp(this, data.o, 0, .01, this), "st" === data.ty || "gs" === data.ty) {
                        if (e.lc = lineCapEnum[data.lc || 2], e.lj = lineJoinEnum[data.lj || 2], 1 == data.lj && (e.ml = data.ml), r.w = PropertyFactory.getProp(this, data.w, 0, null, this), r.w.k || (e.wi = r.w.v), data.d) {
                            var n = new DashProperty(this, data.d, "canvas", this);
                            r.d = n, r.d.k || (e.da = r.d.dashArray, e.do = r.d.dashoffset[0])
                        }
                    } else e.r = 2 === data.r ? "evenodd" : "nonzero";
                    return this.stylesList.push(e), r.style = e, r
                }, CVShapeElement.prototype.createGroupElement = function () {
                    return {
                        it: [],
                        prevViewData: []
                    }
                }, CVShapeElement.prototype.createTransformElement = function (data) {
                    return {
                        transform: {
                            opacity: 1,
                            _opMdf: !1,
                            key: this.transformsManager.getNewKey(),
                            op: PropertyFactory.getProp(this, data.o, 0, .01, this),
                            mProps: TransformPropertyFactory.getTransformProperty(this, data, this)
                        }
                    }
                }, CVShapeElement.prototype.createShapeElement = function (data) {
                    var t = new CVShapeData(this, data, this.stylesList, this.transformsManager);
                    return this.shapes.push(t), this.addShapeToModifiers(t), t
                }, CVShapeElement.prototype.reloadShapes = function () {
                    var i;
                    this._isFirstFrame = !0;
                    var t = this.itemsData.length;
                    for (i = 0; i < t; i += 1) this.prevViewData[i] = this.itemsData[i];
                    for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), t = this.dynamicProperties.length, i = 0; i < t; i += 1) this.dynamicProperties[i].getValue();
                    this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame)
                }, CVShapeElement.prototype.addTransformToStyleList = function (t) {
                    var i, e = this.stylesList.length;
                    for (i = 0; i < e; i += 1) this.stylesList[i].closed || this.stylesList[i].transforms.push(t)
                }, CVShapeElement.prototype.removeTransformFromStyleList = function () {
                    var i, t = this.stylesList.length;
                    for (i = 0; i < t; i += 1) this.stylesList[i].closed || this.stylesList[i].transforms.pop()
                }, CVShapeElement.prototype.closeStyles = function (t) {
                    var i, e = t.length;
                    for (i = 0; i < e; i += 1) t[i].closed = !0
                }, CVShapeElement.prototype.searchShapes = function (t, e, r, n, o) {
                    var i, h, l, c, d, m, f = t.length - 1,
                        y = [],
                        v = [],
                        x = [].concat(o);
                    for (i = f; i >= 0; i -= 1) {
                        if ((c = this.searchProcessedElement(t[i])) ? e[i] = r[c - 1] : t[i]._shouldRender = n, "fl" === t[i].ty || "st" === t[i].ty || "gf" === t[i].ty || "gs" === t[i].ty) c ? e[i].style.closed = !1 : e[i] = this.createStyleElement(t[i], x), y.push(e[i].style);
                        else if ("gr" === t[i].ty) {
                            if (c)
                                for (l = e[i].it.length, h = 0; h < l; h += 1) e[i].prevViewData[h] = e[i].it[h];
                            else e[i] = this.createGroupElement(t[i]);
                            this.searchShapes(t[i].it, e[i].it, e[i].prevViewData, n, x)
                        } else "tr" === t[i].ty ? (c || (m = this.createTransformElement(t[i]), e[i] = m), x.push(e[i]), this.addTransformToStyleList(e[i])) : "sh" === t[i].ty || "rc" === t[i].ty || "el" === t[i].ty || "sr" === t[i].ty ? c || (e[i] = this.createShapeElement(t[i])) : "tm" === t[i].ty || "rd" === t[i].ty || "pb" === t[i].ty ? (c ? (d = e[i]).closed = !1 : ((d = ShapeModifiers.getModifier(t[i].ty)).init(this, t[i]), e[i] = d, this.shapeModifiers.push(d)), v.push(d)) : "rp" === t[i].ty && (c ? (d = e[i]).closed = !0 : (d = ShapeModifiers.getModifier(t[i].ty), e[i] = d, d.init(this, t, i, e), this.shapeModifiers.push(d), n = !1), v.push(d));
                        this.addProcessedElement(t[i], i + 1)
                    }
                    for (this.removeTransformFromStyleList(), this.closeStyles(y), f = v.length, i = 0; i < f; i += 1) v[i].closed = !0
                }, CVShapeElement.prototype.renderInnerContent = function () {
                    this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
                }, CVShapeElement.prototype.renderShapeTransform = function (t, e) {
                    (t._opMdf || e.op._mdf || this._isFirstFrame) && (e.opacity = t.opacity, e.opacity *= e.op.v, e._opMdf = !0)
                }, CVShapeElement.prototype.drawLayer = function () {
                    var i, t, e, r, n, o, h, l, c, d = this.stylesList.length,
                        m = this.globalData.renderer,
                        f = this.globalData.canvasContext;
                    for (i = 0; i < d; i += 1)
                        if (("st" !== (l = (c = this.stylesList[i]).type) && "gs" !== l || 0 !== c.wi) && c.data._shouldRender && 0 !== c.coOp && 0 !== this.globalData.currentGlobalAlpha) {
                            for (m.save(), o = c.elements, "st" === l || "gs" === l ? (f.strokeStyle = "st" === l ? c.co : c.grd, f.lineWidth = c.wi, f.lineCap = c.lc, f.lineJoin = c.lj, f.miterLimit = c.ml || 0) : f.fillStyle = "fl" === l ? c.co : c.grd, m.ctxOpacity(c.coOp), "st" !== l && "gs" !== l && f.beginPath(), m.ctxTransform(c.preTransforms.finalTransform.props), e = o.length, t = 0; t < e; t += 1) {
                                for ("st" !== l && "gs" !== l || (f.beginPath(), c.da && (f.setLineDash(c.da), f.lineDashOffset = c.do)), n = (h = o[t].trNodes).length, r = 0; r < n; r += 1) "m" === h[r].t ? f.moveTo(h[r].p[0], h[r].p[1]) : "c" === h[r].t ? f.bezierCurveTo(h[r].pts[0], h[r].pts[1], h[r].pts[2], h[r].pts[3], h[r].pts[4], h[r].pts[5]) : f.closePath();
                                "st" !== l && "gs" !== l || (f.stroke(), c.da && f.setLineDash(this.dashResetter))
                            }
                            "st" !== l && "gs" !== l && f.fill(c.r), m.restore()
                        }
                }, CVShapeElement.prototype.renderShape = function (t, e, data, r) {
                    var i, n;
                    for (n = t, i = e.length - 1; i >= 0; i -= 1) "tr" === e[i].ty ? (n = data[i].transform, this.renderShapeTransform(t, n)) : "sh" === e[i].ty || "el" === e[i].ty || "rc" === e[i].ty || "sr" === e[i].ty ? this.renderPath(e[i], data[i]) : "fl" === e[i].ty ? this.renderFill(e[i], data[i], n) : "st" === e[i].ty ? this.renderStroke(e[i], data[i], n) : "gf" === e[i].ty || "gs" === e[i].ty ? this.renderGradientFill(e[i], data[i], n) : "gr" === e[i].ty ? this.renderShape(n, e[i].it, data[i].it) : e[i].ty;
                    r && this.drawLayer()
                }, CVShapeElement.prototype.renderStyledShape = function (t, e) {
                    if (this._isFirstFrame || e._mdf || t.transforms._mdf) {
                        var i, r, n, o = t.trNodes,
                            h = e.paths,
                            l = h._length;
                        o.length = 0;
                        var c = t.transforms.finalTransform;
                        for (n = 0; n < l; n += 1) {
                            var d = h.shapes[n];
                            if (d && d.v) {
                                for (r = d._length, i = 1; i < r; i += 1) 1 === i && o.push({
                                    t: "m",
                                    p: c.applyToPointArray(d.v[0][0], d.v[0][1], 0)
                                }), o.push({
                                    t: "c",
                                    pts: c.applyToTriplePoints(d.o[i - 1], d.i[i], d.v[i])
                                });
                                1 === r && o.push({
                                    t: "m",
                                    p: c.applyToPointArray(d.v[0][0], d.v[0][1], 0)
                                }), d.c && r && (o.push({
                                    t: "c",
                                    pts: c.applyToTriplePoints(d.o[i - 1], d.i[0], d.v[0])
                                }), o.push({
                                    t: "z"
                                }))
                            }
                        }
                        t.trNodes = o
                    }
                }, CVShapeElement.prototype.renderPath = function (t, e) {
                    if (!0 !== t.hd && t._shouldRender) {
                        var i, r = e.styledShapes.length;
                        for (i = 0; i < r; i += 1) this.renderStyledShape(e.styledShapes[i], e.sh)
                    }
                }, CVShapeElement.prototype.renderFill = function (t, e, r) {
                    var n = e.style;
                    (e.c._mdf || this._isFirstFrame) && (n.co = "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || r._opMdf || this._isFirstFrame) && (n.coOp = e.o.v * r.opacity)
                }, CVShapeElement.prototype.renderGradientFill = function (t, e, r) {
                    var n, o = e.style;
                    if (!o.grd || e.g._mdf || e.s._mdf || e.e._mdf || 1 !== t.t && (e.h._mdf || e.a._mdf)) {
                        var i, h = this.globalData.canvasContext,
                            l = e.s.v,
                            c = e.e.v;
                        if (1 === t.t) n = h.createLinearGradient(l[0], l[1], c[0], c[1]);
                        else {
                            var d = Math.sqrt(Math.pow(l[0] - c[0], 2) + Math.pow(l[1] - c[1], 2)),
                                m = Math.atan2(c[1] - l[1], c[0] - l[0]),
                                f = e.h.v;
                            f >= 1 ? f = .99 : f <= -1 && (f = -.99);
                            var y = d * f,
                                v = Math.cos(m + e.a.v) * y + l[0],
                                x = Math.sin(m + e.a.v) * y + l[1];
                            n = h.createRadialGradient(v, x, 0, l[0], l[1], d)
                        }
                        var _ = t.g.p,
                            M = e.g.c,
                            S = 1;
                        for (i = 0; i < _; i += 1) e.g._hasOpacity && e.g._collapsable && (S = e.g.o[2 * i + 1]), n.addColorStop(M[4 * i] / 100, "rgba(" + M[4 * i + 1] + "," + M[4 * i + 2] + "," + M[4 * i + 3] + "," + S + ")");
                        o.grd = n
                    }
                    o.coOp = e.o.v * r.opacity
                }, CVShapeElement.prototype.renderStroke = function (t, e, r) {
                    var n = e.style,
                        o = e.d;
                    o && (o._mdf || this._isFirstFrame) && (n.da = o.dashArray, n.do = o.dashoffset[0]), (e.c._mdf || this._isFirstFrame) && (n.co = "rgb(" + bmFloor(e.c.v[0]) + "," + bmFloor(e.c.v[1]) + "," + bmFloor(e.c.v[2]) + ")"), (e.o._mdf || r._opMdf || this._isFirstFrame) && (n.coOp = e.o.v * r.opacity), (e.w._mdf || this._isFirstFrame) && (n.wi = e.w.v)
                }, CVShapeElement.prototype.destroy = function () {
                    this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0
                }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function () {
                    var t = this.canvasContext;
                    t.fillStyle = this.data.sc, t.fillRect(0, 0, this.data.sw, this.data.sh)
                }, extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function () {
                    var t = this.textProperty.currentData;
                    this.renderedLetters = createSizedArray(t.l ? t.l.length : 0);
                    var e = !1;
                    t.fc ? (e = !0, this.values.fill = this.buildColor(t.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = e;
                    var r = !1;
                    t.sc && (r = !0, this.values.stroke = this.buildColor(t.sc), this.values.sWidth = t.sw);
                    var i, n, o, h, l, c, d, m, f, y, v, x, _ = this.globalData.fontManager.getFontByName(t.f),
                        M = t.l,
                        S = this.mHelper;
                    this.stroke = r, this.values.fValue = t.finalSize + "px " + this.globalData.fontManager.getFontByName(t.f).fFamily, n = t.finalText.length;
                    var w = this.data.singleShape,
                        E = .001 * t.tr * t.finalSize,
                        T = 0,
                        A = 0,
                        P = !0,
                        C = 0;
                    for (i = 0; i < n; i += 1) {
                        for (h = (o = this.globalData.fontManager.getCharData(t.finalText[i], _.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily)) && o.data || {}, S.reset(), w && M[i].n && (T = -E, A += t.yOffset, A += P ? 1 : 0, P = !1), f = (d = h.shapes ? h.shapes[0].it : []).length, S.scale(t.finalSize / 100, t.finalSize / 100), w && this.applyTextPropertiesToMatrix(t, S, M[i].line, T, A), v = createSizedArray(f), m = 0; m < f; m += 1) {
                            for (c = d[m].ks.k.i.length, y = d[m].ks.k, x = [], l = 1; l < c; l += 1) 1 === l && x.push(S.applyToX(y.v[0][0], y.v[0][1], 0), S.applyToY(y.v[0][0], y.v[0][1], 0)), x.push(S.applyToX(y.o[l - 1][0], y.o[l - 1][1], 0), S.applyToY(y.o[l - 1][0], y.o[l - 1][1], 0), S.applyToX(y.i[l][0], y.i[l][1], 0), S.applyToY(y.i[l][0], y.i[l][1], 0), S.applyToX(y.v[l][0], y.v[l][1], 0), S.applyToY(y.v[l][0], y.v[l][1], 0));
                            x.push(S.applyToX(y.o[l - 1][0], y.o[l - 1][1], 0), S.applyToY(y.o[l - 1][0], y.o[l - 1][1], 0), S.applyToX(y.i[0][0], y.i[0][1], 0), S.applyToY(y.i[0][0], y.i[0][1], 0), S.applyToX(y.v[0][0], y.v[0][1], 0), S.applyToY(y.v[0][0], y.v[0][1], 0)), v[m] = x
                        }
                        w && (T += M[i].l, T += E), this.textSpans[C] ? this.textSpans[C].elem = v : this.textSpans[C] = {
                            elem: v
                        }, C += 1
                    }
                }, CVTextElement.prototype.renderInnerContent = function () {
                    var i, t, e, r, n, o, h = this.canvasContext;
                    h.font = this.values.fValue, h.lineCap = "butt", h.lineJoin = "miter", h.miterLimit = 4, this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
                    var l, c = this.textAnimator.renderedLetters,
                        d = this.textProperty.currentData.l;
                    t = d.length;
                    var m, f, y = null,
                        v = null,
                        x = null;
                    for (i = 0; i < t; i += 1)
                        if (!d[i].n) {
                            if ((l = c[i]) && (this.globalData.renderer.save(), this.globalData.renderer.ctxTransform(l.p), this.globalData.renderer.ctxOpacity(l.o)), this.fill) {
                                for (l && l.fc ? y !== l.fc && (y = l.fc, h.fillStyle = l.fc) : y !== this.values.fill && (y = this.values.fill, h.fillStyle = this.values.fill), r = (m = this.textSpans[i].elem).length, this.globalData.canvasContext.beginPath(), e = 0; e < r; e += 1)
                                    for (o = (f = m[e]).length, this.globalData.canvasContext.moveTo(f[0], f[1]), n = 2; n < o; n += 6) this.globalData.canvasContext.bezierCurveTo(f[n], f[n + 1], f[n + 2], f[n + 3], f[n + 4], f[n + 5]);
                                this.globalData.canvasContext.closePath(), this.globalData.canvasContext.fill()
                            }
                            if (this.stroke) {
                                for (l && l.sw ? x !== l.sw && (x = l.sw, h.lineWidth = l.sw) : x !== this.values.sWidth && (x = this.values.sWidth, h.lineWidth = this.values.sWidth), l && l.sc ? v !== l.sc && (v = l.sc, h.strokeStyle = l.sc) : v !== this.values.stroke && (v = this.values.stroke, h.strokeStyle = this.values.stroke), r = (m = this.textSpans[i].elem).length, this.globalData.canvasContext.beginPath(), e = 0; e < r; e += 1)
                                    for (o = (f = m[e]).length, this.globalData.canvasContext.moveTo(f[0], f[1]), n = 2; n < o; n += 6) this.globalData.canvasContext.bezierCurveTo(f[n], f[n + 1], f[n + 2], f[n + 3], f[n + 4], f[n + 5]);
                                this.globalData.canvasContext.closePath(), this.globalData.canvasContext.stroke()
                            }
                            l && this.globalData.renderer.restore()
                        }
                }, CVEffects.prototype.renderFrame = function () {}, HBaseElement.prototype = {
                    checkBlendMode: function () {},
                    initRendererElement: function () {
                        this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement)
                    },
                    createContainerElements: function () {
                        this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), 0 !== this.data.bm && this.setBlendMode()
                    },
                    renderElement: function () {
                        var t = this.transformedElement ? this.transformedElement.style : {};
                        if (this.finalTransform._matMdf) {
                            var e = this.finalTransform.mat.toCSS();
                            t.transform = e, t.webkitTransform = e
                        }
                        this.finalTransform._opMdf && (t.opacity = this.finalTransform.mProp.o.v)
                    },
                    renderFrame: function () {
                        this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1))
                    },
                    destroy: function () {
                        this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null)
                    },
                    createRenderableComponents: function () {
                        this.maskManager = new MaskElement(this.data, this, this.globalData)
                    },
                    addEffects: function () {},
                    setMatte: function () {}
                }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function () {
                    var rect;
                    this.data.hasMask ? ((rect = createNS("rect")).setAttribute("width", this.data.sw), rect.setAttribute("height", this.data.sh), rect.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : ((rect = createTag("div")).style.width = this.data.sw + "px", rect.style.height = this.data.sh + "px", rect.style.backgroundColor = this.data.sc), this.layerElement.appendChild(rect)
                }, extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function () {
                    this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
                }, HCompElement.prototype.addTo3dContainer = function (t, e) {
                    for (var r, n = 0; n < e;) this.elements[n] && this.elements[n].getBaseElement && (r = this.elements[n].getBaseElement()), n += 1;
                    r ? this.layerElement.insertBefore(t, r) : this.layerElement.appendChild(t)
                }, extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function () {
                    var t;
                    if (this.baseElement.style.fontSize = 0, this.data.hasMask) this.layerElement.appendChild(this.shapesContainer), t = this.svgElement;
                    else {
                        t = createNS("svg");
                        var e = this.comp.data ? this.comp.data : this.globalData.compSize;
                        t.setAttribute("width", e.w), t.setAttribute("height", e.h), t.appendChild(this.shapesContainer), this.layerElement.appendChild(t)
                    }
                    this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = t
                }, HShapeElement.prototype.getTransformedPoint = function (t, e) {
                    var i, r = t.length;
                    for (i = 0; i < r; i += 1) e = t[i].mProps.v.applyToPointArray(e[0], e[1], 0);
                    return e
                }, HShapeElement.prototype.calculateShapeBoundingBox = function (t, e) {
                    var i, r, n, o, h, l = t.sh.v,
                        c = t.transformers,
                        d = l._length;
                    if (!(d <= 1)) {
                        for (i = 0; i < d - 1; i += 1) r = this.getTransformedPoint(c, l.v[i]), n = this.getTransformedPoint(c, l.o[i]), o = this.getTransformedPoint(c, l.i[i + 1]), h = this.getTransformedPoint(c, l.v[i + 1]), this.checkBounds(r, n, o, h, e);
                        l.c && (r = this.getTransformedPoint(c, l.v[i]), n = this.getTransformedPoint(c, l.o[i]), o = this.getTransformedPoint(c, l.i[0]), h = this.getTransformedPoint(c, l.v[0]), this.checkBounds(r, n, o, h, e))
                    }
                }, HShapeElement.prototype.checkBounds = function (t, e, r, n, o) {
                    this.getBoundsOfCurve(t, e, r, n);
                    var h = this.shapeBoundingBox;
                    o.x = bmMin(h.left, o.x), o.xMax = bmMax(h.right, o.xMax), o.y = bmMin(h.top, o.y), o.yMax = bmMax(h.bottom, o.yMax)
                }, HShapeElement.prototype.shapeBoundingBox = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                }, HShapeElement.prototype.tempBoundingBox = {
                    x: 0,
                    xMax: 0,
                    y: 0,
                    yMax: 0,
                    width: 0,
                    height: 0
                }, HShapeElement.prototype.getBoundsOfCurve = function (t, e, r, n) {
                    for (var a, b, o, h, l, c, d, m = [
                            [t[0], n[0]],
                            [t[1], n[1]]
                        ], i = 0; i < 2; ++i) b = 6 * t[i] - 12 * e[i] + 6 * r[i], a = -3 * t[i] + 9 * e[i] - 9 * r[i] + 3 * n[i], o = 3 * e[i] - 3 * t[i], b |= 0, o |= 0, 0 == (a |= 0) && 0 === b || (0 === a ? (h = -o / b) > 0 && h < 1 && m[i].push(this.calculateF(h, t, e, r, n, i)) : (l = b * b - 4 * o * a) >= 0 && ((c = (-b + bmSqrt(l)) / (2 * a)) > 0 && c < 1 && m[i].push(this.calculateF(c, t, e, r, n, i)), (d = (-b - bmSqrt(l)) / (2 * a)) > 0 && d < 1 && m[i].push(this.calculateF(d, t, e, r, n, i))));
                    this.shapeBoundingBox.left = bmMin.apply(null, m[0]), this.shapeBoundingBox.top = bmMin.apply(null, m[1]), this.shapeBoundingBox.right = bmMax.apply(null, m[0]), this.shapeBoundingBox.bottom = bmMax.apply(null, m[1])
                }, HShapeElement.prototype.calculateF = function (t, e, r, n, o, i) {
                    return bmPow(1 - t, 3) * e[i] + 3 * bmPow(1 - t, 2) * t * r[i] + 3 * (1 - t) * bmPow(t, 2) * n[i] + bmPow(t, 3) * o[i]
                }, HShapeElement.prototype.calculateBoundingBox = function (t, e) {
                    var i, r = t.length;
                    for (i = 0; i < r; i += 1) t[i] && t[i].sh ? this.calculateShapeBoundingBox(t[i], e) : t[i] && t[i].it && this.calculateBoundingBox(t[i].it, e)
                }, HShapeElement.prototype.currentBoxContains = function (t) {
                    return this.currentBBox.x <= t.x && this.currentBBox.y <= t.y && this.currentBBox.width + this.currentBBox.x >= t.x + t.width && this.currentBBox.height + this.currentBBox.y >= t.y + t.height
                }, HShapeElement.prototype.renderInnerContent = function () {
                    if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) {
                        var t = this.tempBoundingBox,
                            e = 999999;
                        if (t.x = e, t.xMax = -e, t.y = e, t.yMax = -e, this.calculateBoundingBox(this.itemsData, t), t.width = t.xMax < t.x ? 0 : t.xMax - t.x, t.height = t.yMax < t.y ? 0 : t.yMax - t.y, this.currentBoxContains(t)) return;
                        var r = !1;
                        if (this.currentBBox.w !== t.width && (this.currentBBox.w = t.width, this.shapeCont.setAttribute("width", t.width), r = !0), this.currentBBox.h !== t.height && (this.currentBBox.h = t.height, this.shapeCont.setAttribute("height", t.height), r = !0), r || this.currentBBox.x !== t.x || this.currentBBox.y !== t.y) {
                            this.currentBBox.w = t.width, this.currentBBox.h = t.height, this.currentBBox.x = t.x, this.currentBBox.y = t.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                            var n = this.shapeCont.style,
                                o = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                            n.transform = o, n.webkitTransform = o
                        }
                    }
                }, extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function () {
                    if (this.isMasked = this.checkMasks(), this.isMasked) {
                        this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH);
                        var g = createNS("g");
                        this.maskedElement.appendChild(g), this.innerElem = g
                    } else this.renderType = "html", this.innerElem = this.layerElement;
                    this.checkParenting()
                }, HTextElement.prototype.buildNewText = function () {
                    var t = this.textProperty.currentData;
                    this.renderedLetters = createSizedArray(t.l ? t.l.length : 0);
                    var e = this.innerElem.style,
                        r = t.fc ? this.buildColor(t.fc) : "rgba(0,0,0,0)";
                    e.fill = r, e.color = r, t.sc && (e.stroke = this.buildColor(t.sc), e.strokeWidth = t.sw + "px");
                    var i, n, o = this.globalData.fontManager.getFontByName(t.f);
                    if (!this.globalData.fontManager.chars)
                        if (e.fontSize = t.finalSize + "px", e.lineHeight = t.finalSize + "px", o.fClass) this.innerElem.className = o.fClass;
                        else {
                            e.fontFamily = o.fFamily;
                            var h = t.fWeight,
                                l = t.fStyle;
                            e.fontStyle = l, e.fontWeight = h
                        } var c, d, m, f = t.l;
                    n = f.length;
                    var y, v = this.mHelper,
                        x = "",
                        _ = 0;
                    for (i = 0; i < n; i += 1) {
                        if (this.globalData.fontManager.chars ? (this.textPaths[_] ? c = this.textPaths[_] : ((c = createNS("path")).setAttribute("stroke-linecap", lineCapEnum[1]), c.setAttribute("stroke-linejoin", lineJoinEnum[2]), c.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[_] ? m = (d = this.textSpans[_]).children[0] : ((d = createTag("div")).style.lineHeight = 0, (m = createNS("svg")).appendChild(c), styleDiv(d)))) : this.isMasked ? c = this.textPaths[_] ? this.textPaths[_] : createNS("text") : this.textSpans[_] ? (d = this.textSpans[_], c = this.textPaths[_]) : (styleDiv(d = createTag("span")), styleDiv(c = createTag("span")), d.appendChild(c)), this.globalData.fontManager.chars) {
                            var M, S = this.globalData.fontManager.getCharData(t.finalText[i], o.fStyle, this.globalData.fontManager.getFontByName(t.f).fFamily);
                            if (M = S ? S.data : null, v.reset(), M && M.shapes && (y = M.shapes[0].it, v.scale(t.finalSize / 100, t.finalSize / 100), x = this.createPathShape(v, y), c.setAttribute("d", x)), this.isMasked) this.innerElem.appendChild(c);
                            else {
                                if (this.innerElem.appendChild(d), M && M.shapes) {
                                    document.body.appendChild(m);
                                    var w = m.getBBox();
                                    m.setAttribute("width", w.width + 2), m.setAttribute("height", w.height + 2), m.setAttribute("viewBox", w.x - 1 + " " + (w.y - 1) + " " + (w.width + 2) + " " + (w.height + 2));
                                    var E = m.style,
                                        T = "translate(" + (w.x - 1) + "px," + (w.y - 1) + "px)";
                                    E.transform = T, E.webkitTransform = T, f[i].yOffset = w.y - 1
                                } else m.setAttribute("width", 1), m.setAttribute("height", 1);
                                d.appendChild(m)
                            }
                        } else if (c.textContent = f[i].val, c.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked) this.innerElem.appendChild(c);
                        else {
                            this.innerElem.appendChild(d);
                            var A = c.style,
                                P = "translate3d(0," + -t.finalSize / 1.2 + "px,0)";
                            A.transform = P, A.webkitTransform = P
                        }
                        this.isMasked ? this.textSpans[_] = c : this.textSpans[_] = d, this.textSpans[_].style.display = "block", this.textPaths[_] = c, _ += 1
                    }
                    for (; _ < this.textSpans.length;) this.textSpans[_].style.display = "none", _ += 1
                }, HTextElement.prototype.renderInnerContent = function () {
                    var t;
                    if (this.data.singleShape) {
                        if (!this._isFirstFrame && !this.lettersChangedFlag) return;
                        if (this.isMasked && this.finalTransform._matMdf) {
                            this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), t = this.svgElement.style;
                            var e = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
                            t.transform = e, t.webkitTransform = e
                        }
                    }
                    if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
                        var i, r, n, o, h, l = 0,
                            c = this.textAnimator.renderedLetters,
                            d = this.textProperty.currentData.l;
                        for (r = d.length, i = 0; i < r; i += 1) d[i].n ? l += 1 : (o = this.textSpans[i], h = this.textPaths[i], n = c[l], l += 1, n._mdf.m && (this.isMasked ? o.setAttribute("transform", n.m) : (o.style.webkitTransform = n.m, o.style.transform = n.m)), o.style.opacity = n.o, n.sw && n._mdf.sw && h.setAttribute("stroke-width", n.sw), n.sc && n._mdf.sc && h.setAttribute("stroke", n.sc), n.fc && n._mdf.fc && (h.setAttribute("fill", n.fc), h.style.color = n.fc));
                        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                            var m = this.innerElem.getBBox();
                            if (this.currentBBox.w !== m.width && (this.currentBBox.w = m.width, this.svgElement.setAttribute("width", m.width)), this.currentBBox.h !== m.height && (this.currentBBox.h = m.height, this.svgElement.setAttribute("height", m.height)), this.currentBBox.w !== m.width + 2 || this.currentBBox.h !== m.height + 2 || this.currentBBox.x !== m.x - 1 || this.currentBBox.y !== m.y - 1) {
                                this.currentBBox.w = m.width + 2, this.currentBBox.h = m.height + 2, this.currentBBox.x = m.x - 1, this.currentBBox.y = m.y - 1, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), t = this.svgElement.style;
                                var f = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                                t.transform = f, t.webkitTransform = f
                            }
                        }
                    }
                }, extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function () {
                    var t = this.globalData.getAssetsPath(this.assetData),
                        img = new Image;
                    this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", t), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(img), img.crossOrigin = "anonymous", img.src = t, this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
                }, extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function () {
                    var i, t, e, r, n = this.comp.threeDElements.length;
                    for (i = 0; i < n; i += 1)
                        if ("3d" === (t = this.comp.threeDElements[i]).type) {
                            e = t.perspectiveElem.style, r = t.container.style;
                            var o = this.pe.v + "px",
                                h = "0px 0px 0px",
                                l = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                            e.perspective = o, e.webkitPerspective = o, r.transformOrigin = h, r.mozTransformOrigin = h, r.webkitTransformOrigin = h, e.transform = l, e.webkitTransform = l
                        }
                }, HCameraElement.prototype.createElements = function () {}, HCameraElement.prototype.hide = function () {}, HCameraElement.prototype.renderFrame = function () {
                    var i, t, e = this._isFirstFrame;
                    if (this.hierarchy)
                        for (t = this.hierarchy.length, i = 0; i < t; i += 1) e = this.hierarchy[i].finalTransform.mProp._mdf || e;
                    if (e || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
                        if (this.mat.reset(), this.hierarchy)
                            for (i = t = this.hierarchy.length - 1; i >= 0; i -= 1) {
                                var r = this.hierarchy[i].finalTransform.mProp;
                                this.mat.translate(-r.p.v[0], -r.p.v[1], r.p.v[2]), this.mat.rotateX(-r.or.v[0]).rotateY(-r.or.v[1]).rotateZ(r.or.v[2]), this.mat.rotateX(-r.rx.v).rotateY(-r.ry.v).rotateZ(r.rz.v), this.mat.scale(1 / r.s.v[0], 1 / r.s.v[1], 1 / r.s.v[2]), this.mat.translate(r.a.v[0], r.a.v[1], r.a.v[2])
                            }
                        if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) {
                            var n;
                            n = this.p ? [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                            var o = Math.sqrt(Math.pow(n[0], 2) + Math.pow(n[1], 2) + Math.pow(n[2], 2)),
                                h = [n[0] / o, n[1] / o, n[2] / o],
                                l = Math.sqrt(h[2] * h[2] + h[0] * h[0]),
                                c = Math.atan2(h[1], l),
                                d = Math.atan2(h[0], -h[2]);
                            this.mat.rotateY(d).rotateX(-c)
                        }
                        this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v);
                        var m = !this._prevMat.equals(this.mat);
                        if ((m || this.pe._mdf) && this.comp.threeDElements) {
                            var f, y, v;
                            for (t = this.comp.threeDElements.length, i = 0; i < t; i += 1)
                                if ("3d" === (f = this.comp.threeDElements[i]).type) {
                                    if (m) {
                                        var x = this.mat.toCSS();
                                        (v = f.container.style).transform = x, v.webkitTransform = x
                                    }
                                    this.pe._mdf && ((y = f.perspectiveElem.style).perspective = this.pe.v + "px", y.webkitPerspective = this.pe.v + "px")
                                } this.mat.clone(this._prevMat)
                        }
                    }
                    this._isFirstFrame = !1
                }, HCameraElement.prototype.prepareFrame = function (t) {
                    this.prepareProperties(t, !0)
                }, HCameraElement.prototype.destroy = function () {}, HCameraElement.prototype.getBaseElement = function () {
                    return null
                }, HEffects.prototype.renderFrame = function () {};
                var animationManager = function () {
                        var t = {},
                            e = [],
                            r = 0,
                            n = 0,
                            o = 0,
                            h = !0,
                            l = !1;

                        function c(t) {
                            for (var i = 0, r = t.target; i < n;) e[i].animation === r && (e.splice(i, 1), i -= 1, n -= 1, r.isPaused || f()), i += 1
                        }

                        function d(element, t) {
                            if (!element) return null;
                            for (var i = 0; i < n;) {
                                if (e[i].elem === element && null !== e[i].elem) return e[i].animation;
                                i += 1
                            }
                            var r = new AnimationItem;
                            return y(r, element), r.setData(element, t), r
                        }

                        function m() {
                            o += 1, _()
                        }

                        function f() {
                            o -= 1
                        }

                        function y(t, element) {
                            t.addEventListener("destroy", c), t.addEventListener("_active", m), t.addEventListener("_idle", f), e.push({
                                elem: element,
                                animation: t
                            }), n += 1
                        }

                        function v(t) {
                            var i, c = t - r;
                            for (i = 0; i < n; i += 1) e[i].animation.advanceTime(c);
                            r = t, o && !l ? window.requestAnimationFrame(v) : h = !0
                        }

                        function x(t) {
                            r = t, window.requestAnimationFrame(v)
                        }

                        function _() {
                            !l && o && h && (window.requestAnimationFrame(x), h = !1)
                        }
                        return t.registerAnimation = d, t.loadAnimation = function (t) {
                            var e = new AnimationItem;
                            return y(e, null), e.setParams(t), e
                        }, t.setSpeed = function (t, r) {
                            var i;
                            for (i = 0; i < n; i += 1) e[i].animation.setSpeed(t, r)
                        }, t.setDirection = function (t, r) {
                            var i;
                            for (i = 0; i < n; i += 1) e[i].animation.setDirection(t, r)
                        }, t.play = function (t) {
                            var i;
                            for (i = 0; i < n; i += 1) e[i].animation.play(t)
                        }, t.pause = function (t) {
                            var i;
                            for (i = 0; i < n; i += 1) e[i].animation.pause(t)
                        }, t.stop = function (t) {
                            var i;
                            for (i = 0; i < n; i += 1) e[i].animation.stop(t)
                        }, t.togglePause = function (t) {
                            var i;
                            for (i = 0; i < n; i += 1) e[i].animation.togglePause(t)
                        }, t.searchAnimations = function (t, e, r) {
                            var i, n = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))),
                                o = n.length;
                            for (i = 0; i < o; i += 1) r && n[i].setAttribute("data-bm-type", r), d(n[i], t);
                            if (e && 0 === o) {
                                r || (r = "svg");
                                var body = document.getElementsByTagName("body")[0];
                                body.innerText = "";
                                var div = createTag("div");
                                div.style.width = "100%", div.style.height = "100%", div.setAttribute("data-bm-type", r), body.appendChild(div), d(div, t)
                            }
                        }, t.resize = function () {
                            var i;
                            for (i = 0; i < n; i += 1) e[i].animation.resize()
                        }, t.goToAndStop = function (t, r, o) {
                            var i;
                            for (i = 0; i < n; i += 1) e[i].animation.goToAndStop(t, r, o)
                        }, t.destroy = function (t) {
                            var i;
                            for (i = n - 1; i >= 0; i -= 1) e[i].animation.destroy(t)
                        }, t.freeze = function () {
                            l = !0
                        }, t.unfreeze = function () {
                            l = !1, _()
                        }, t.setVolume = function (t, r) {
                            var i;
                            for (i = 0; i < n; i += 1) e[i].animation.setVolume(t, r)
                        }, t.mute = function (t) {
                            var i;
                            for (i = 0; i < n; i += 1) e[i].animation.mute(t)
                        }, t.unmute = function (t) {
                            var i;
                            for (i = 0; i < n; i += 1) e[i].animation.unmute(t)
                        }, t.getRegisteredAnimations = function () {
                            var i, t = e.length,
                                r = [];
                            for (i = 0; i < t; i += 1) r.push(e[i].animation);
                            return r
                        }, t
                    }(),
                    AnimationItem = function () {
                        this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = subframeEnabled, this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader, this.audioController = audioControllerFactory(), this.markers = []
                    };
                extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function (t) {
                    (t.wrapper || t.container) && (this.wrapper = t.wrapper || t.container);
                    var e = "svg";
                    switch (t.animType ? e = t.animType : t.renderer && (e = t.renderer), e) {
                        case "canvas":
                            this.renderer = new CanvasRenderer(this, t.rendererSettings);
                            break;
                        case "svg":
                            this.renderer = new SVGRenderer(this, t.rendererSettings);
                            break;
                        default:
                            this.renderer = new HybridRenderer(this, t.rendererSettings)
                    }
                    this.imagePreloader.setCacheType(e, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = e, "" === t.loop || null === t.loop || void 0 === t.loop || !0 === t.loop ? this.loop = !0 : !1 === t.loop ? this.loop = !1 : this.loop = parseInt(t.loop, 10), this.autoplay = !("autoplay" in t) || t.autoplay, this.name = t.name ? t.name : "", this.autoloadSegments = !Object.prototype.hasOwnProperty.call(t, "autoloadSegments") || t.autoloadSegments, this.assetsPath = t.assetsPath, this.initialSegment = t.initialSegment, t.audioFactory && this.audioController.setAudioFactory(t.audioFactory), t.animationData ? this.configAnimation(t.animationData) : t.path && (-1 !== t.path.lastIndexOf("\\") ? this.path = t.path.substr(0, t.path.lastIndexOf("\\") + 1) : this.path = t.path.substr(0, t.path.lastIndexOf("/") + 1), this.fileName = t.path.substr(t.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), assetLoader.load(t.path, this.configAnimation.bind(this), function () {
                        this.trigger("data_failed")
                    }.bind(this)))
                }, AnimationItem.prototype.setData = function (t, e) {
                    e && "object" != typeof e && (e = JSON.parse(e));
                    var r = {
                            wrapper: t,
                            animationData: e
                        },
                        n = t.attributes;
                    r.path = n.getNamedItem("data-animation-path") ? n.getNamedItem("data-animation-path").value : n.getNamedItem("data-bm-path") ? n.getNamedItem("data-bm-path").value : n.getNamedItem("bm-path") ? n.getNamedItem("bm-path").value : "", r.animType = n.getNamedItem("data-anim-type") ? n.getNamedItem("data-anim-type").value : n.getNamedItem("data-bm-type") ? n.getNamedItem("data-bm-type").value : n.getNamedItem("bm-type") ? n.getNamedItem("bm-type").value : n.getNamedItem("data-bm-renderer") ? n.getNamedItem("data-bm-renderer").value : n.getNamedItem("bm-renderer") ? n.getNamedItem("bm-renderer").value : "canvas";
                    var o = n.getNamedItem("data-anim-loop") ? n.getNamedItem("data-anim-loop").value : n.getNamedItem("data-bm-loop") ? n.getNamedItem("data-bm-loop").value : n.getNamedItem("bm-loop") ? n.getNamedItem("bm-loop").value : "";
                    "false" === o ? r.loop = !1 : "true" === o ? r.loop = !0 : "" !== o && (r.loop = parseInt(o, 10));
                    var h = n.getNamedItem("data-anim-autoplay") ? n.getNamedItem("data-anim-autoplay").value : n.getNamedItem("data-bm-autoplay") ? n.getNamedItem("data-bm-autoplay").value : !n.getNamedItem("bm-autoplay") || n.getNamedItem("bm-autoplay").value;
                    r.autoplay = "false" !== h, r.name = n.getNamedItem("data-name") ? n.getNamedItem("data-name").value : n.getNamedItem("data-bm-name") ? n.getNamedItem("data-bm-name").value : n.getNamedItem("bm-name") ? n.getNamedItem("bm-name").value : "", "false" === (n.getNamedItem("data-anim-prerender") ? n.getNamedItem("data-anim-prerender").value : n.getNamedItem("data-bm-prerender") ? n.getNamedItem("data-bm-prerender").value : n.getNamedItem("bm-prerender") ? n.getNamedItem("bm-prerender").value : "") && (r.prerender = !1), this.setParams(r)
                }, AnimationItem.prototype.includeLayers = function (data) {
                    data.op > this.animationData.op && (this.animationData.op = data.op, this.totalFrames = Math.floor(data.op - this.animationData.ip));
                    var i, t, e = this.animationData.layers,
                        r = e.length,
                        n = data.layers,
                        o = n.length;
                    for (t = 0; t < o; t += 1)
                        for (i = 0; i < r;) {
                            if (e[i].id === n[t].id) {
                                e[i] = n[t];
                                break
                            }
                            i += 1
                        }
                    if ((data.chars || data.fonts) && (this.renderer.globalData.fontManager.addChars(data.chars), this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs)), data.assets)
                        for (r = data.assets.length, i = 0; i < r; i += 1) this.animationData.assets.push(data.assets[i]);
                    this.animationData.__complete = !1, dataManager.completeData(this.animationData, this.renderer.globalData.fontManager), this.renderer.includeLayers(data.layers), expressionsPlugin && expressionsPlugin.initExpressions(this), this.loadNextSegment()
                }, AnimationItem.prototype.loadNextSegment = function () {
                    var t = this.animationData.segments;
                    if (!t || 0 === t.length || !this.autoloadSegments) return this.trigger("data_ready"), void(this.timeCompleted = this.totalFrames);
                    var e = t.shift();
                    this.timeCompleted = e.time * this.frameRate;
                    var r = this.path + this.fileName + "_" + this.segmentPos + ".json";
                    this.segmentPos += 1, assetLoader.load(r, this.includeLayers.bind(this), function () {
                        this.trigger("data_failed")
                    }.bind(this))
                }, AnimationItem.prototype.loadSegments = function () {
                    this.animationData.segments || (this.timeCompleted = this.totalFrames), this.loadNextSegment()
                }, AnimationItem.prototype.imagesLoaded = function () {
                    this.trigger("loaded_images"), this.checkLoaded()
                }, AnimationItem.prototype.preloadImages = function () {
                    this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
                }, AnimationItem.prototype.configAnimation = function (t) {
                    if (this.renderer) try {
                        this.animationData = t, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(t), t.assets || (t.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(t.assets), this.markers = markerParser(t.markers || []), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause()
                    } catch (t) {
                        this.triggerConfigError(t)
                    }
                }, AnimationItem.prototype.waitForFontsLoaded = function () {
                    this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
                }, AnimationItem.prototype.checkLoaded = function () {
                    !this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || "canvas" !== this.renderer.rendererType) && this.imagePreloader.loadedFootages() && (this.isLoaded = !0, dataManager.completeData(this.animationData, this.renderer.globalData.fontManager), expressionsPlugin && expressionsPlugin.initExpressions(this), this.renderer.initItems(), setTimeout(function () {
                        this.trigger("DOMLoaded")
                    }.bind(this), 0), this.gotoFrame(), this.autoplay && this.play())
                }, AnimationItem.prototype.resize = function () {
                    this.renderer.updateContainerSize()
                }, AnimationItem.prototype.setSubframe = function (t) {
                    this.isSubframeEnabled = !!t
                }, AnimationItem.prototype.gotoFrame = function () {
                    this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame()
                }, AnimationItem.prototype.renderFrame = function () {
                    if (!1 !== this.isLoaded && this.renderer) try {
                        this.renderer.renderFrame(this.currentFrame + this.firstFrame)
                    } catch (t) {
                        this.triggerRenderFrameError(t)
                    }
                }, AnimationItem.prototype.play = function (t) {
                    t && this.name !== t || !0 === this.isPaused && (this.isPaused = !1, this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active")))
                }, AnimationItem.prototype.pause = function (t) {
                    t && this.name !== t || !1 === this.isPaused && (this.isPaused = !0, this._idle = !0, this.trigger("_idle"), this.audioController.pause())
                }, AnimationItem.prototype.togglePause = function (t) {
                    t && this.name !== t || (!0 === this.isPaused ? this.play() : this.pause())
                }, AnimationItem.prototype.stop = function (t) {
                    t && this.name !== t || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0))
                }, AnimationItem.prototype.getMarkerData = function (t) {
                    for (var marker, i = 0; i < this.markers.length; i += 1)
                        if ((marker = this.markers[i]).payload && marker.payload.name === t) return marker;
                    return null
                }, AnimationItem.prototype.goToAndStop = function (t, e, r) {
                    if (!r || this.name === r) {
                        var n = Number(t);
                        if (isNaN(n)) {
                            var marker = this.getMarkerData(t);
                            marker && this.goToAndStop(marker.time, !0)
                        } else e ? this.setCurrentRawFrameValue(t) : this.setCurrentRawFrameValue(t * this.frameModifier);
                        this.pause()
                    }
                }, AnimationItem.prototype.goToAndPlay = function (t, e, r) {
                    if (!r || this.name === r) {
                        var n = Number(t);
                        if (isNaN(n)) {
                            var marker = this.getMarkerData(t);
                            marker && (marker.duration ? this.playSegments([marker.time, marker.time + marker.duration], !0) : this.goToAndStop(marker.time, !0))
                        } else this.goToAndStop(n, e, r);
                        this.play()
                    }
                }, AnimationItem.prototype.advanceTime = function (t) {
                    if (!0 !== this.isPaused && !1 !== this.isLoaded) {
                        var e = this.currentRawFrame + t * this.frameModifier,
                            r = !1;
                        e >= this.totalFrames - 1 && this.frameModifier > 0 ? this.loop && this.playCount !== this.loop ? e >= this.totalFrames ? (this.playCount += 1, this.checkSegments(e % this.totalFrames) || (this.setCurrentRawFrameValue(e % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(e) : this.checkSegments(e > this.totalFrames ? e % this.totalFrames : 0) || (r = !0, e = this.totalFrames - 1) : e < 0 ? this.checkSegments(e % this.totalFrames) || (!this.loop || this.playCount-- <= 0 && !0 !== this.loop ? (r = !0, e = 0) : (this.setCurrentRawFrameValue(this.totalFrames + e % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0)) : this.setCurrentRawFrameValue(e), r && (this.setCurrentRawFrameValue(e), this.pause(), this.trigger("complete"))
                    }
                }, AnimationItem.prototype.adjustSegment = function (t, e) {
                    this.playCount = 0, t[1] < t[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.totalFrames = t[0] - t[1], this.timeCompleted = this.totalFrames, this.firstFrame = t[1], this.setCurrentRawFrameValue(this.totalFrames - .001 - e)) : t[1] > t[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.totalFrames = t[1] - t[0], this.timeCompleted = this.totalFrames, this.firstFrame = t[0], this.setCurrentRawFrameValue(.001 + e)), this.trigger("segmentStart")
                }, AnimationItem.prototype.setSegment = function (t, e) {
                    var r = -1;
                    this.isPaused && (this.currentRawFrame + this.firstFrame < t ? r = t : this.currentRawFrame + this.firstFrame > e && (r = e - t)), this.firstFrame = t, this.totalFrames = e - t, this.timeCompleted = this.totalFrames, -1 !== r && this.goToAndStop(r, !0)
                }, AnimationItem.prototype.playSegments = function (t, e) {
                    if (e && (this.segments.length = 0), "object" == typeof t[0]) {
                        var i, r = t.length;
                        for (i = 0; i < r; i += 1) this.segments.push(t[i])
                    } else this.segments.push(t);
                    this.segments.length && e && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play()
                }, AnimationItem.prototype.resetSegments = function (t) {
                    this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), t && this.checkSegments(0)
                }, AnimationItem.prototype.checkSegments = function (t) {
                    return !!this.segments.length && (this.adjustSegment(this.segments.shift(), t), !0)
                }, AnimationItem.prototype.destroy = function (t) {
                    t && this.name !== t || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = null, this.onLoopComplete = null, this.onComplete = null, this.onSegmentStart = null, this.onDestroy = null, this.renderer = null, this.renderer = null, this.imagePreloader = null, this.projectInterface = null)
                }, AnimationItem.prototype.setCurrentRawFrameValue = function (t) {
                    this.currentRawFrame = t, this.gotoFrame()
                }, AnimationItem.prototype.setSpeed = function (t) {
                    this.playSpeed = t, this.updaFrameModifier()
                }, AnimationItem.prototype.setDirection = function (t) {
                    this.playDirection = t < 0 ? -1 : 1, this.updaFrameModifier()
                }, AnimationItem.prototype.setVolume = function (t, e) {
                    e && this.name !== e || this.audioController.setVolume(t)
                }, AnimationItem.prototype.getVolume = function () {
                    return this.audioController.getVolume()
                }, AnimationItem.prototype.mute = function (t) {
                    t && this.name !== t || this.audioController.mute()
                }, AnimationItem.prototype.unmute = function (t) {
                    t && this.name !== t || this.audioController.unmute()
                }, AnimationItem.prototype.updaFrameModifier = function () {
                    this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection)
                }, AnimationItem.prototype.getPath = function () {
                    return this.path
                }, AnimationItem.prototype.getAssetsPath = function (t) {
                    var path = "";
                    if (t.e) path = t.p;
                    else if (this.assetsPath) {
                        var e = t.p; - 1 !== e.indexOf("images/") && (e = e.split("/")[1]), path = this.assetsPath + e
                    } else path = this.path, path += t.u ? t.u : "", path += t.p;
                    return path
                }, AnimationItem.prototype.getAssetData = function (t) {
                    for (var i = 0, e = this.assets.length; i < e;) {
                        if (t === this.assets[i].id) return this.assets[i];
                        i += 1
                    }
                    return null
                }, AnimationItem.prototype.hide = function () {
                    this.renderer.hide()
                }, AnimationItem.prototype.show = function () {
                    this.renderer.show()
                }, AnimationItem.prototype.getDuration = function (t) {
                    return t ? this.totalFrames : this.totalFrames / this.frameRate
                }, AnimationItem.prototype.trigger = function (t) {
                    if (this._cbs && this._cbs[t]) switch (t) {
                        case "enterFrame":
                            this.triggerEvent(t, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameModifier));
                            break;
                        case "loopComplete":
                            this.triggerEvent(t, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult));
                            break;
                        case "complete":
                            this.triggerEvent(t, new BMCompleteEvent(t, this.frameMult));
                            break;
                        case "segmentStart":
                            this.triggerEvent(t, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames));
                            break;
                        case "destroy":
                            this.triggerEvent(t, new BMDestroyEvent(t, this));
                            break;
                        default:
                            this.triggerEvent(t)
                    }
                    "enterFrame" === t && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(t, this.currentFrame, this.totalFrames, this.frameMult)), "loopComplete" === t && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(t, this.loop, this.playCount, this.frameMult)), "complete" === t && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(t, this.frameMult)), "segmentStart" === t && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(t, this.firstFrame, this.totalFrames)), "destroy" === t && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(t, this))
                }, AnimationItem.prototype.triggerRenderFrameError = function (t) {
                    var e = new BMRenderFrameErrorEvent(t, this.currentFrame);
                    this.triggerEvent("error", e), this.onError && this.onError.call(this, e)
                }, AnimationItem.prototype.triggerConfigError = function (t) {
                    var e = new BMConfigErrorEvent(t, this.currentFrame);
                    this.triggerEvent("error", e), this.onError && this.onError.call(this, e)
                };
                var Expressions = function () {
                    var t = {
                        initExpressions: function (t) {
                            var e = 0,
                                r = [];
                            t.renderer.compInterface = CompExpressionInterface(t.renderer), t.renderer.globalData.projectInterface.registerComposition(t.renderer), t.renderer.globalData.pushExpression = function () {
                                e += 1
                            }, t.renderer.globalData.popExpression = function () {
                                0 == (e -= 1) && function () {
                                    var i, t = r.length;
                                    for (i = 0; i < t; i += 1) r[i].release();
                                    r.length = 0
                                }()
                            }, t.renderer.globalData.registerExpressionProperty = function (t) {
                                -1 === r.indexOf(t) && r.push(t)
                            }
                        }
                    };
                    return t
                }();
                expressionsPlugin = Expressions;
                var ExpressionManager = function () {
                        var ob = {},
                            Math = BMMath,
                            window = null,
                            document = null,
                            XMLHttpRequest = null,
                            fetch = null;

                        function $bm_isInstanceOfArray(t) {
                            return t.constructor === Array || t.constructor === Float32Array
                        }

                        function isNumerable(t, e) {
                            return "number" === t || "boolean" === t || "string" === t || e instanceof Number
                        }

                        function $bm_neg(a) {
                            var t = typeof a;
                            if ("number" === t || "boolean" === t || a instanceof Number) return -a;
                            if ($bm_isInstanceOfArray(a)) {
                                var i, e = a.length,
                                    r = [];
                                for (i = 0; i < e; i += 1) r[i] = -a[i];
                                return r
                            }
                            return a.propType ? a.v : -a
                        }
                        var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get,
                            easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get,
                            easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;

                        function sum(a, b) {
                            var t = typeof a,
                                e = typeof b;
                            if ("string" === t || "string" === e) return a + b;
                            if (isNumerable(t, a) && isNumerable(e, b)) return a + b;
                            if ($bm_isInstanceOfArray(a) && isNumerable(e, b)) return (a = a.slice(0))[0] += b, a;
                            if (isNumerable(t, a) && $bm_isInstanceOfArray(b)) return (b = b.slice(0))[0] = a + b[0], b;
                            if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
                                for (var i = 0, r = a.length, n = b.length, o = []; i < r || i < n;)("number" == typeof a[i] || a[i] instanceof Number) && ("number" == typeof b[i] || b[i] instanceof Number) ? o[i] = a[i] + b[i] : o[i] = void 0 === b[i] ? a[i] : a[i] || b[i], i += 1;
                                return o
                            }
                            return 0
                        }
                        var add = sum;

                        function sub(a, b) {
                            var t = typeof a,
                                e = typeof b;
                            if (isNumerable(t, a) && isNumerable(e, b)) return "string" === t && (a = parseInt(a, 10)), "string" === e && (b = parseInt(b, 10)), a - b;
                            if ($bm_isInstanceOfArray(a) && isNumerable(e, b)) return (a = a.slice(0))[0] -= b, a;
                            if (isNumerable(t, a) && $bm_isInstanceOfArray(b)) return (b = b.slice(0))[0] = a - b[0], b;
                            if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
                                for (var i = 0, r = a.length, n = b.length, o = []; i < r || i < n;)("number" == typeof a[i] || a[i] instanceof Number) && ("number" == typeof b[i] || b[i] instanceof Number) ? o[i] = a[i] - b[i] : o[i] = void 0 === b[i] ? a[i] : a[i] || b[i], i += 1;
                                return o
                            }
                            return 0
                        }

                        function mul(a, b) {
                            var t, i, e, r = typeof a,
                                n = typeof b;
                            if (isNumerable(r, a) && isNumerable(n, b)) return a * b;
                            if ($bm_isInstanceOfArray(a) && isNumerable(n, b)) {
                                for (e = a.length, t = createTypedArray("float32", e), i = 0; i < e; i += 1) t[i] = a[i] * b;
                                return t
                            }
                            if (isNumerable(r, a) && $bm_isInstanceOfArray(b)) {
                                for (e = b.length, t = createTypedArray("float32", e), i = 0; i < e; i += 1) t[i] = a * b[i];
                                return t
                            }
                            return 0
                        }

                        function div(a, b) {
                            var t, i, e, r = typeof a,
                                n = typeof b;
                            if (isNumerable(r, a) && isNumerable(n, b)) return a / b;
                            if ($bm_isInstanceOfArray(a) && isNumerable(n, b)) {
                                for (e = a.length, t = createTypedArray("float32", e), i = 0; i < e; i += 1) t[i] = a[i] / b;
                                return t
                            }
                            if (isNumerable(r, a) && $bm_isInstanceOfArray(b)) {
                                for (e = b.length, t = createTypedArray("float32", e), i = 0; i < e; i += 1) t[i] = a / b[i];
                                return t
                            }
                            return 0
                        }

                        function mod(a, b) {
                            return "string" == typeof a && (a = parseInt(a, 10)), "string" == typeof b && (b = parseInt(b, 10)), a % b
                        }
                        var $bm_sum = sum,
                            $bm_sub = sub,
                            $bm_mul = mul,
                            $bm_div = div,
                            $bm_mod = mod;

                        function clamp(t, e, r) {
                            if (e > r) {
                                var n = r;
                                r = e, e = n
                            }
                            return Math.min(Math.max(t, e), r)
                        }

                        function radiansToDegrees(t) {
                            return t / degToRads
                        }
                        var radians_to_degrees = radiansToDegrees;

                        function degreesToRadians(t) {
                            return t * degToRads
                        }
                        var degrees_to_radians = radiansToDegrees,
                            helperLengthArray = [0, 0, 0, 0, 0, 0];

                        function length(t, e) {
                            if ("number" == typeof t || t instanceof Number) return e = e || 0, Math.abs(t - e);
                            var i;
                            e || (e = helperLengthArray);
                            var r = Math.min(t.length, e.length),
                                n = 0;
                            for (i = 0; i < r; i += 1) n += Math.pow(e[i] - t[i], 2);
                            return Math.sqrt(n)
                        }

                        function normalize(t) {
                            return div(t, length(t))
                        }

                        function rgbToHsl(t) {
                            var e, s, r = t[0],
                                g = t[1],
                                b = t[2],
                                n = Math.max(r, g, b),
                                o = Math.min(r, g, b),
                                h = (n + o) / 2;
                            if (n === o) e = 0, s = 0;
                            else {
                                var l = n - o;
                                switch (s = h > .5 ? l / (2 - n - o) : l / (n + o), n) {
                                    case r:
                                        e = (g - b) / l + (g < b ? 6 : 0);
                                        break;
                                    case g:
                                        e = (b - r) / l + 2;
                                        break;
                                    case b:
                                        e = (r - g) / l + 4
                                }
                                e /= 6
                            }
                            return [e, s, h, t[3]]
                        }

                        function hue2rgb(p, q, t) {
                            return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p
                        }

                        function hslToRgb(t) {
                            var e, g, b, r = t[0],
                                s = t[1],
                                n = t[2];
                            if (0 === s) e = n, b = n, g = n;
                            else {
                                var q = n < .5 ? n * (1 + s) : n + s - n * s,
                                    p = 2 * n - q;
                                e = hue2rgb(p, q, r + 1 / 3), g = hue2rgb(p, q, r), b = hue2rgb(p, q, r - 1 / 3)
                            }
                            return [e, g, b, t[3]]
                        }

                        function linear(t, e, r, n, o) {
                            if (void 0 !== n && void 0 !== o || (n = e, o = r, e = 0, r = 1), r < e) {
                                var h = r;
                                r = e, e = h
                            }
                            if (t <= e) return n;
                            if (t >= r) return o;
                            var i, l = r === e ? 0 : (t - e) / (r - e);
                            if (!n.length) return n + (o - n) * l;
                            var c = n.length,
                                d = createTypedArray("float32", c);
                            for (i = 0; i < c; i += 1) d[i] = n[i] + (o[i] - n[i]) * l;
                            return d
                        }

                        function random(t, e) {
                            if (void 0 === e && (void 0 === t ? (t = 0, e = 1) : (e = t, t = void 0)), e.length) {
                                var i, r = e.length;
                                t || (t = createTypedArray("float32", r));
                                var n = createTypedArray("float32", r),
                                    o = BMMath.random();
                                for (i = 0; i < r; i += 1) n[i] = t[i] + o * (e[i] - t[i]);
                                return n
                            }
                            return void 0 === t && (t = 0), t + BMMath.random() * (e - t)
                        }

                        function createPath(t, e, r, n) {
                            var i, o = t.length,
                                path = shapePool.newElement();
                            path.setPathData(!!n, o);
                            var h, l, c = [0, 0];
                            for (i = 0; i < o; i += 1) h = e && e[i] ? e[i] : c, l = r && r[i] ? r[i] : c, path.setTripleAt(t[i][0], t[i][1], l[0] + t[i][0], l[1] + t[i][1], h[0] + t[i][0], h[1] + t[i][1], i, !0);
                            return path
                        }

                        function initiateExpression(elem, data, property) {
                            var val = data.x,
                                needsVelocity = /velocity(?![\w\d])/.test(val),
                                _needsRandom = -1 !== val.indexOf("random"),
                                elemType = elem.data.ty,
                                transform, $bm_transform, content, effect, thisProperty = property;
                            thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", {
                                get: function () {
                                    return thisProperty.v
                                }
                            }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0;
                            var inPoint = elem.data.ip / elem.comp.globalData.frameRate,
                                outPoint = elem.data.op / elem.comp.globalData.frameRate,
                                width = elem.data.sw ? elem.data.sw : 0,
                                height = elem.data.sh ? elem.data.sh : 0,
                                name = elem.data.nm,
                                loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0],
                                numKeys = property.kf ? data.k.length : 0,
                                active = !this.data || !0 !== this.data.hd,
                                wiggle = function (t, e) {
                                    var r, n, o = this.pv.length ? this.pv.length : 1,
                                        h = createTypedArray("float32", o),
                                        l = Math.floor(5 * time);
                                    for (r = 0, n = 0; r < l;) {
                                        for (n = 0; n < o; n += 1) h[n] += -e + 2 * e * BMMath.random();
                                        r += 1
                                    }
                                    var c = 5 * time,
                                        d = c - Math.floor(c),
                                        m = createTypedArray("float32", o);
                                    if (o > 1) {
                                        for (n = 0; n < o; n += 1) m[n] = this.pv[n] + h[n] + (-e + 2 * e * BMMath.random()) * d;
                                        return m
                                    }
                                    return this.pv + h[0] + (-e + 2 * e * BMMath.random()) * d
                                }.bind(this);

                            function loopInDuration(t, e) {
                                return loopIn(t, e, !0)
                            }

                            function loopOutDuration(t, e) {
                                return loopOut(t, e, !0)
                            }
                            thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty)), this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
                            var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface),
                                time, velocity, value, text, textIndex, textTotal, selectorValue;

                            function lookAt(t, e) {
                                var r = [e[0] - t[0], e[1] - t[1], e[2] - t[2]],
                                    n = Math.atan2(r[0], Math.sqrt(r[1] * r[1] + r[2] * r[2])) / degToRads;
                                return [-Math.atan2(r[1], r[2]) / degToRads, n, 0]
                            }

                            function easeOut(t, e, r, n, o) {
                                return applyEase(easeOutBez, t, e, r, n, o)
                            }

                            function easeIn(t, e, r, n, o) {
                                return applyEase(easeInBez, t, e, r, n, o)
                            }

                            function ease(t, e, r, n, o) {
                                return applyEase(easeInOutBez, t, e, r, n, o)
                            }

                            function applyEase(t, e, r, n, o, h) {
                                void 0 === o ? (o = r, h = n) : e = (e - r) / (n - r), e > 1 ? e = 1 : e < 0 && (e = 0);
                                var l = t(e);
                                if ($bm_isInstanceOfArray(o)) {
                                    var c, d = o.length,
                                        m = createTypedArray("float32", d);
                                    for (c = 0; c < d; c += 1) m[c] = (h[c] - o[c]) * l + o[c];
                                    return m
                                }
                                return (h - o) * l + o
                            }

                            function nearestKey(time) {
                                var t, e, r, n = data.k.length;
                                if (data.k.length && "number" != typeof data.k[0])
                                    if (e = -1, (time *= elem.comp.globalData.frameRate) < data.k[0].t) e = 1, r = data.k[0].t;
                                    else {
                                        for (t = 0; t < n - 1; t += 1) {
                                            if (time === data.k[t].t) {
                                                e = t + 1, r = data.k[t].t;
                                                break
                                            }
                                            if (time > data.k[t].t && time < data.k[t + 1].t) {
                                                time - data.k[t].t > data.k[t + 1].t - time ? (e = t + 2, r = data.k[t + 1].t) : (e = t + 1, r = data.k[t].t);
                                                break
                                            }
                                        } - 1 === e && (e = t + 1, r = data.k[t].t)
                                    }
                                else e = 0, r = 0;
                                var o = {};
                                return o.index = e, o.time = r / elem.comp.globalData.frameRate, o
                            }

                            function key(t) {
                                var e, r, n;
                                if (!data.k.length || "number" == typeof data.k[0]) throw new Error("The property has no keyframe at index " + t);
                                t -= 1, e = {
                                    time: data.k[t].t / elem.comp.globalData.frameRate,
                                    value: []
                                };
                                var o = Object.prototype.hasOwnProperty.call(data.k[t], "s") ? data.k[t].s : data.k[t - 1].e;
                                for (n = o.length, r = 0; r < n; r += 1) e[r] = o[r], e.value[r] = o[r];
                                return e
                            }

                            function framesToTime(t, e) {
                                return e || (e = elem.comp.globalData.frameRate), t / e
                            }

                            function timeToFrames(t, e) {
                                return t || 0 === t || (t = time), e || (e = elem.comp.globalData.frameRate), t * e
                            }

                            function seedRandom(t) {
                                BMMath.seedrandom(randSeed + t)
                            }

                            function sourceRectAtTime() {
                                return elem.sourceRectAtTime()
                            }

                            function substring(t, e) {
                                return "string" == typeof value ? void 0 === e ? value.substring(t) : value.substring(t, e) : ""
                            }

                            function substr(t, e) {
                                return "string" == typeof value ? void 0 === e ? value.substr(t) : value.substr(t, e) : ""
                            }

                            function posterizeTime(t) {
                                time = 0 === t ? 0 : Math.floor(time * t) / t, value = valueAtTime(time)
                            }
                            var index = elem.data.ind,
                                hasParent = !(!elem.hierarchy || !elem.hierarchy.length),
                                parent, randSeed = Math.floor(1e6 * Math.random()),
                                globalData = elem.globalData;

                            function executeExpression(t) {
                                return value = t, _needsRandom && seedRandom(randSeed), this.frameExpressionId === elem.globalData.frameId && "textSelector" !== this.propType ? value : ("textSelector" === this.propType && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), 4 !== elemType || content || (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), (hasParent = !(!elem.hierarchy || !elem.hierarchy.length)) && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, "shape" === scoped_bm_rt.propType && (scoped_bm_rt = scoped_bm_rt.v), scoped_bm_rt)
                            }
                            return executeExpression
                        }
                        return ob.initiateExpression = initiateExpression, ob
                    }(),
                    expressionHelpers = {
                        searchExpressions: function (t, data, e) {
                            data.x && (e.k = !0, e.x = !0, e.initiateExpression = ExpressionManager.initiateExpression, e.effectsSequence.push(e.initiateExpression(t, data, e).bind(e)))
                        },
                        getSpeedAtTime: function (t) {
                            var e = this.getValueAtTime(t),
                                r = this.getValueAtTime(t + -.01),
                                n = 0;
                            if (e.length) {
                                var i;
                                for (i = 0; i < e.length; i += 1) n += Math.pow(r[i] - e[i], 2);
                                n = 100 * Math.sqrt(n)
                            } else n = 0;
                            return n
                        },
                        getVelocityAtTime: function (t) {
                            if (void 0 !== this.vel) return this.vel;
                            var e, i, r = -.001,
                                n = this.getValueAtTime(t),
                                o = this.getValueAtTime(t + r);
                            if (n.length)
                                for (e = createTypedArray("float32", n.length), i = 0; i < n.length; i += 1) e[i] = (o[i] - n[i]) / r;
                            else e = (o - n) / r;
                            return e
                        },
                        getValueAtTime: function (t) {
                            return t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < t ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(t, this._cachingAtTime), this._cachingAtTime.lastFrame = t), this._cachingAtTime.value
                        },
                        getStaticValueAtTime: function () {
                            return this.pv
                        },
                        setGroupProperty: function (t) {
                            this.propertyGroup = t
                        }
                    };
                ! function () {
                    function t(t, e, r) {
                        if (!this.k || !this.keyframes) return this.pv;
                        t = t ? t.toLowerCase() : "";
                        var n, o, i, h, l, c = this.comp.renderedFrame,
                            d = this.keyframes,
                            m = d[d.length - 1].t;
                        if (c <= m) return this.pv;
                        if (r ? o = m - (n = e ? Math.abs(m - this.elem.comp.globalData.frameRate * e) : Math.max(0, m - this.elem.data.ip)) : ((!e || e > d.length - 1) && (e = d.length - 1), n = m - (o = d[d.length - 1 - e].t)), "pingpong" === t) {
                            if (Math.floor((c - o) / n) % 2 != 0) return this.getValueAtTime((n - (c - o) % n + o) / this.comp.globalData.frameRate, 0)
                        } else {
                            if ("offset" === t) {
                                var f = this.getValueAtTime(o / this.comp.globalData.frameRate, 0),
                                    y = this.getValueAtTime(m / this.comp.globalData.frameRate, 0),
                                    v = this.getValueAtTime(((c - o) % n + o) / this.comp.globalData.frameRate, 0),
                                    x = Math.floor((c - o) / n);
                                if (this.pv.length) {
                                    for (h = (l = new Array(f.length)).length, i = 0; i < h; i += 1) l[i] = (y[i] - f[i]) * x + v[i];
                                    return l
                                }
                                return (y - f) * x + v
                            }
                            if ("continue" === t) {
                                var _ = this.getValueAtTime(m / this.comp.globalData.frameRate, 0),
                                    M = this.getValueAtTime((m - .001) / this.comp.globalData.frameRate, 0);
                                if (this.pv.length) {
                                    for (h = (l = new Array(_.length)).length, i = 0; i < h; i += 1) l[i] = _[i] + (_[i] - M[i]) * ((c - m) / this.comp.globalData.frameRate) / 5e-4;
                                    return l
                                }
                                return _ + (c - m) / .001 * (_ - M)
                            }
                        }
                        return this.getValueAtTime(((c - o) % n + o) / this.comp.globalData.frameRate, 0)
                    }

                    function e(t, e, r) {
                        if (!this.k) return this.pv;
                        t = t ? t.toLowerCase() : "";
                        var n, o, i, h, l, c = this.comp.renderedFrame,
                            d = this.keyframes,
                            m = d[0].t;
                        if (c >= m) return this.pv;
                        if (r ? o = m + (n = e ? Math.abs(this.elem.comp.globalData.frameRate * e) : Math.max(0, this.elem.data.op - m)) : ((!e || e > d.length - 1) && (e = d.length - 1), n = (o = d[e].t) - m), "pingpong" === t) {
                            if (Math.floor((m - c) / n) % 2 == 0) return this.getValueAtTime(((m - c) % n + m) / this.comp.globalData.frameRate, 0)
                        } else {
                            if ("offset" === t) {
                                var f = this.getValueAtTime(m / this.comp.globalData.frameRate, 0),
                                    y = this.getValueAtTime(o / this.comp.globalData.frameRate, 0),
                                    v = this.getValueAtTime((n - (m - c) % n + m) / this.comp.globalData.frameRate, 0),
                                    x = Math.floor((m - c) / n) + 1;
                                if (this.pv.length) {
                                    for (h = (l = new Array(f.length)).length, i = 0; i < h; i += 1) l[i] = v[i] - (y[i] - f[i]) * x;
                                    return l
                                }
                                return v - (y - f) * x
                            }
                            if ("continue" === t) {
                                var _ = this.getValueAtTime(m / this.comp.globalData.frameRate, 0),
                                    M = this.getValueAtTime((m + .001) / this.comp.globalData.frameRate, 0);
                                if (this.pv.length) {
                                    for (h = (l = new Array(_.length)).length, i = 0; i < h; i += 1) l[i] = _[i] + (_[i] - M[i]) * (m - c) / .001;
                                    return l
                                }
                                return _ + (_ - M) * (m - c) / .001
                            }
                        }
                        return this.getValueAtTime((n - ((m - c) % n + m)) / this.comp.globalData.frameRate, 0)
                    }

                    function r(t, e) {
                        if (!this.k) return this.pv;
                        if (t = .5 * (t || .4), (e = Math.floor(e || 5)) <= 1) return this.pv;
                        var r, n, o = this.comp.renderedFrame / this.comp.globalData.frameRate,
                            h = o - t,
                            l = e > 1 ? (o + t - h) / (e - 1) : 1,
                            i = 0,
                            c = 0;
                        for (r = this.pv.length ? createTypedArray("float32", this.pv.length) : 0; i < e;) {
                            if (n = this.getValueAtTime(h + i * l), this.pv.length)
                                for (c = 0; c < this.pv.length; c += 1) r[c] += n[c];
                            else r += n;
                            i += 1
                        }
                        if (this.pv.length)
                            for (c = 0; c < this.pv.length; c += 1) r[c] /= e;
                        else r /= e;
                        return r
                    }

                    function n(time) {
                        this._transformCachingAtTime || (this._transformCachingAtTime = {
                            v: new Matrix
                        });
                        var t = this._transformCachingAtTime.v;
                        if (t.cloneFromProps(this.pre.props), this.appliedTransformations < 1) {
                            var e = this.a.getValueAtTime(time);
                            t.translate(-e[0] * this.a.mult, -e[1] * this.a.mult, e[2] * this.a.mult)
                        }
                        if (this.appliedTransformations < 2) {
                            var r = this.s.getValueAtTime(time);
                            t.scale(r[0] * this.s.mult, r[1] * this.s.mult, r[2] * this.s.mult)
                        }
                        if (this.sk && this.appliedTransformations < 3) {
                            var n = this.sk.getValueAtTime(time),
                                o = this.sa.getValueAtTime(time);
                            t.skewFromAxis(-n * this.sk.mult, o * this.sa.mult)
                        }
                        if (this.r && this.appliedTransformations < 4) {
                            var h = this.r.getValueAtTime(time);
                            t.rotate(-h * this.r.mult)
                        } else if (!this.r && this.appliedTransformations < 4) {
                            var l = this.rz.getValueAtTime(time),
                                c = this.ry.getValueAtTime(time),
                                d = this.rx.getValueAtTime(time),
                                m = this.or.getValueAtTime(time);
                            t.rotateZ(-l * this.rz.mult).rotateY(c * this.ry.mult).rotateX(d * this.rx.mult).rotateZ(-m[2] * this.or.mult).rotateY(m[1] * this.or.mult).rotateX(m[0] * this.or.mult)
                        }
                        if (this.data.p && this.data.p.s) {
                            var f = this.px.getValueAtTime(time),
                                y = this.py.getValueAtTime(time);
                            if (this.data.p.z) {
                                var v = this.pz.getValueAtTime(time);
                                t.translate(f * this.px.mult, y * this.py.mult, -v * this.pz.mult)
                            } else t.translate(f * this.px.mult, y * this.py.mult, 0)
                        } else {
                            var x = this.p.getValueAtTime(time);
                            t.translate(x[0] * this.p.mult, x[1] * this.p.mult, -x[2] * this.p.mult)
                        }
                        return t
                    }

                    function o() {
                        return this.v.clone(new Matrix)
                    }
                    var h = TransformPropertyFactory.getTransformProperty;
                    TransformPropertyFactory.getTransformProperty = function (t, data, e) {
                        var r = h(t, data, e);
                        return r.dynamicProperties.length ? r.getValueAtTime = n.bind(r) : r.getValueAtTime = o.bind(r), r.setGroupProperty = expressionHelpers.setGroupProperty, r
                    };
                    var l = PropertyFactory.getProp;
                    PropertyFactory.getProp = function (n, data, o, h, c) {
                        var d = l(n, data, o, h, c);
                        d.kf ? d.getValueAtTime = expressionHelpers.getValueAtTime.bind(d) : d.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(d), d.setGroupProperty = expressionHelpers.setGroupProperty, d.loopOut = t, d.loopIn = e, d.smooth = r, d.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(d), d.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(d), d.numKeys = 1 === data.a ? data.k.length : 0, d.propertyIndex = data.ix;
                        var m = 0;
                        return 0 !== o && (m = createTypedArray("float32", 1 === data.a ? data.k[0].s.length : data.k.length)), d._cachingAtTime = {
                            lastFrame: initialDefaultFrame,
                            lastIndex: 0,
                            value: m
                        }, expressionHelpers.searchExpressions(n, data, d), d.k && c.addDynamicProperty(d), d
                    };
                    var c = ShapePropertyFactory.getConstructorFunction(),
                        d = ShapePropertyFactory.getKeyframedConstructorFunction();

                    function m() {}
                    m.prototype = {
                        vertices: function (t, time) {
                            this.k && this.getValue();
                            var i, e = this.v;
                            void 0 !== time && (e = this.getValueAtTime(time, 0));
                            var r = e._length,
                                n = e[t],
                                o = e.v,
                                h = createSizedArray(r);
                            for (i = 0; i < r; i += 1) h[i] = "i" === t || "o" === t ? [n[i][0] - o[i][0], n[i][1] - o[i][1]] : [n[i][0], n[i][1]];
                            return h
                        },
                        points: function (time) {
                            return this.vertices("v", time)
                        },
                        inTangents: function (time) {
                            return this.vertices("i", time)
                        },
                        outTangents: function (time) {
                            return this.vertices("o", time)
                        },
                        isClosed: function () {
                            return this.v.c
                        },
                        pointOnPath: function (t, time) {
                            var e = this.v;
                            void 0 !== time && (e = this.getValueAtTime(time, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(e));
                            for (var r, n = this._segmentsLength, o = n.lengths, h = n.totalLength * t, i = 0, l = o.length, c = 0; i < l;) {
                                if (c + o[i].addedLength > h) {
                                    var d = i,
                                        m = e.c && i === l - 1 ? 0 : i + 1,
                                        f = (h - c) / o[i].addedLength;
                                    r = bez.getPointInSegment(e.v[d], e.v[m], e.o[d], e.i[m], f, o[i]);
                                    break
                                }
                                c += o[i].addedLength, i += 1
                            }
                            return r || (r = e.c ? [e.v[0][0], e.v[0][1]] : [e.v[e._length - 1][0], e.v[e._length - 1][1]]), r
                        },
                        vectorOnPath: function (t, time, e) {
                            1 == t ? t = this.v.c : 0 == t && (t = .999);
                            var r = this.pointOnPath(t, time),
                                n = this.pointOnPath(t + .001, time),
                                o = n[0] - r[0],
                                h = n[1] - r[1],
                                l = Math.sqrt(Math.pow(o, 2) + Math.pow(h, 2));
                            return 0 === l ? [0, 0] : "tangent" === e ? [o / l, h / l] : [-h / l, o / l]
                        },
                        tangentOnPath: function (t, time) {
                            return this.vectorOnPath(t, time, "tangent")
                        },
                        normalOnPath: function (t, time) {
                            return this.vectorOnPath(t, time, "normal")
                        },
                        setGroupProperty: expressionHelpers.setGroupProperty,
                        getValueAtTime: expressionHelpers.getStaticValueAtTime
                    }, extendPrototype([m], c), extendPrototype([m], d), d.prototype.getValueAtTime = function (t) {
                        return this._cachingAtTime || (this._cachingAtTime = {
                            shapeValue: shapePool.clone(this.pv),
                            lastIndex: 0,
                            lastTime: initialDefaultFrame
                        }), t *= this.elem.globalData.frameRate, (t -= this.offsetTime) !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < t ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = t, this.interpolateShape(t, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue
                    }, d.prototype.initiateExpression = ExpressionManager.initiateExpression;
                    var f = ShapePropertyFactory.getShapeProp;
                    ShapePropertyFactory.getShapeProp = function (t, data, e, r, n) {
                        var o = f(t, data, e, r, n);
                        return o.propertyIndex = data.ix, o.lock = !1, 3 === e ? expressionHelpers.searchExpressions(t, data.pt, o) : 4 === e && expressionHelpers.searchExpressions(t, data.ks, o), o.k && t.addDynamicProperty(o), o
                    }
                }(), TextProperty.prototype.getExpressionValue = function (t, text) {
                    var e = this.calculateExpression(text);
                    if (t.t !== e) {
                        var r = {};
                        return this.copyData(r, t), r.t = e.toString(), r.__complete = !1, r
                    }
                    return t
                }, TextProperty.prototype.searchProperty = function () {
                    var t = this.searchKeyframes(),
                        e = this.searchExpressions();
                    return this.kf = t || e, this.kf
                }, TextProperty.prototype.searchExpressions = function () {
                    return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0) : null
                };
                var ShapePathInterface = function (t, view, e) {
                        var r = view.sh;

                        function n(t) {
                            return "Shape" === t || "shape" === t || "Path" === t || "path" === t || "ADBE Vector Shape" === t || 2 === t ? n.path : null
                        }
                        var o = propertyGroupFactory(n, e);
                        return r.setGroupProperty(PropertyInterface("Path", o)), Object.defineProperties(n, {
                            path: {
                                get: function () {
                                    return r.k && r.getValue(), r
                                }
                            },
                            shape: {
                                get: function () {
                                    return r.k && r.getValue(), r
                                }
                            },
                            _name: {
                                value: t.nm
                            },
                            ix: {
                                value: t.ix
                            },
                            propertyIndex: {
                                value: t.ix
                            },
                            mn: {
                                value: t.mn
                            },
                            propertyGroup: {
                                value: e
                            }
                        }), n
                    },
                    propertyGroupFactory = function (t, e) {
                        return function (r) {
                            return (r = void 0 === r ? 1 : r) <= 0 ? t : e(r - 1)
                        }
                    },
                    PropertyInterface = function (t, e) {
                        var r = {
                            _name: t
                        };
                        return function (t) {
                            return (t = void 0 === t ? 1 : t) <= 0 ? r : e(t - 1)
                        }
                    },
                    ShapeExpressionInterface = function () {
                        function t(t, view, l) {
                            var i, v = [],
                                x = t ? t.length : 0;
                            for (i = 0; i < x; i += 1) "gr" === t[i].ty ? v.push(e(t[i], view[i], l)) : "fl" === t[i].ty ? v.push(r(t[i], view[i], l)) : "st" === t[i].ty ? v.push(o(t[i], view[i], l)) : "tm" === t[i].ty ? v.push(h(t[i], view[i], l)) : "tr" === t[i].ty || ("el" === t[i].ty ? v.push(c(t[i], view[i], l)) : "sr" === t[i].ty ? v.push(d(t[i], view[i], l)) : "sh" === t[i].ty ? v.push(ShapePathInterface(t[i], view[i], l)) : "rc" === t[i].ty ? v.push(m(t[i], view[i], l)) : "rd" === t[i].ty ? v.push(f(t[i], view[i], l)) : "rp" === t[i].ty ? v.push(y(t[i], view[i], l)) : "gf" === t[i].ty ? v.push(n(t[i], view[i], l)) : v.push((t[i], view[i], function () {
                                return null
                            })));
                            return v
                        }

                        function e(e, view, r) {
                            var n = function (t) {
                                switch (t) {
                                    case "ADBE Vectors Group":
                                    case "Contents":
                                    case 2:
                                        return n.content;
                                    default:
                                        return n.transform
                                }
                            };
                            n.propertyGroup = propertyGroupFactory(n, r);
                            var content = function (e, view, r) {
                                    var n, o = function (t) {
                                        for (var i = 0, e = n.length; i < e;) {
                                            if (n[i]._name === t || n[i].mn === t || n[i].propertyIndex === t || n[i].ix === t || n[i].ind === t) return n[i];
                                            i += 1
                                        }
                                        return "number" == typeof t ? n[t - 1] : null
                                    };
                                    o.propertyGroup = propertyGroupFactory(o, r), n = t(e.it, view.it, o.propertyGroup), o.numProperties = n.length;
                                    var h = l(e.it[e.it.length - 1], view.it[view.it.length - 1], o.propertyGroup);
                                    return o.transform = h, o.propertyIndex = e.cix, o._name = e.nm, o
                                }(e, view, n.propertyGroup),
                                o = l(e.it[e.it.length - 1], view.it[view.it.length - 1], n.propertyGroup);
                            return n.content = content, n.transform = o, Object.defineProperty(n, "_name", {
                                get: function () {
                                    return e.nm
                                }
                            }), n.numProperties = e.np, n.propertyIndex = e.ix, n.nm = e.nm, n.mn = e.mn, n
                        }

                        function r(t, view, e) {
                            function r(t) {
                                return "Color" === t || "color" === t ? r.color : "Opacity" === t || "opacity" === t ? r.opacity : null
                            }
                            return Object.defineProperties(r, {
                                color: {
                                    get: ExpressionPropertyInterface(view.c)
                                },
                                opacity: {
                                    get: ExpressionPropertyInterface(view.o)
                                },
                                _name: {
                                    value: t.nm
                                },
                                mn: {
                                    value: t.mn
                                }
                            }), view.c.setGroupProperty(PropertyInterface("Color", e)), view.o.setGroupProperty(PropertyInterface("Opacity", e)), r
                        }

                        function n(t, view, e) {
                            function r(t) {
                                return "Start Point" === t || "start point" === t ? r.startPoint : "End Point" === t || "end point" === t ? r.endPoint : "Opacity" === t || "opacity" === t ? r.opacity : null
                            }
                            return Object.defineProperties(r, {
                                startPoint: {
                                    get: ExpressionPropertyInterface(view.s)
                                },
                                endPoint: {
                                    get: ExpressionPropertyInterface(view.e)
                                },
                                opacity: {
                                    get: ExpressionPropertyInterface(view.o)
                                },
                                type: {
                                    get: function () {
                                        return "a"
                                    }
                                },
                                _name: {
                                    value: t.nm
                                },
                                mn: {
                                    value: t.mn
                                }
                            }), view.s.setGroupProperty(PropertyInterface("Start Point", e)), view.e.setGroupProperty(PropertyInterface("End Point", e)), view.o.setGroupProperty(PropertyInterface("Opacity", e)), r
                        }

                        function o(t, view, e) {
                            var i, r = propertyGroupFactory(c, e),
                                n = propertyGroupFactory(l, r);

                            function o(i) {
                                Object.defineProperty(l, t.d[i].nm, {
                                    get: ExpressionPropertyInterface(view.d.dataProps[i].p)
                                })
                            }
                            var h = t.d ? t.d.length : 0,
                                l = {};
                            for (i = 0; i < h; i += 1) o(i), view.d.dataProps[i].p.setGroupProperty(n);

                            function c(t) {
                                return "Color" === t || "color" === t ? c.color : "Opacity" === t || "opacity" === t ? c.opacity : "Stroke Width" === t || "stroke width" === t ? c.strokeWidth : null
                            }
                            return Object.defineProperties(c, {
                                color: {
                                    get: ExpressionPropertyInterface(view.c)
                                },
                                opacity: {
                                    get: ExpressionPropertyInterface(view.o)
                                },
                                strokeWidth: {
                                    get: ExpressionPropertyInterface(view.w)
                                },
                                dash: {
                                    get: function () {
                                        return l
                                    }
                                },
                                _name: {
                                    value: t.nm
                                },
                                mn: {
                                    value: t.mn
                                }
                            }), view.c.setGroupProperty(PropertyInterface("Color", r)), view.o.setGroupProperty(PropertyInterface("Opacity", r)), view.w.setGroupProperty(PropertyInterface("Stroke Width", r)), c
                        }

                        function h(t, view, e) {
                            function r(e) {
                                return e === t.e.ix || "End" === e || "end" === e ? r.end : e === t.s.ix ? r.start : e === t.o.ix ? r.offset : null
                            }
                            var n = propertyGroupFactory(r, e);
                            return r.propertyIndex = t.ix, view.s.setGroupProperty(PropertyInterface("Start", n)), view.e.setGroupProperty(PropertyInterface("End", n)), view.o.setGroupProperty(PropertyInterface("Offset", n)), r.propertyIndex = t.ix, r.propertyGroup = e, Object.defineProperties(r, {
                                start: {
                                    get: ExpressionPropertyInterface(view.s)
                                },
                                end: {
                                    get: ExpressionPropertyInterface(view.e)
                                },
                                offset: {
                                    get: ExpressionPropertyInterface(view.o)
                                },
                                _name: {
                                    value: t.nm
                                }
                            }), r.mn = t.mn, r
                        }

                        function l(t, view, e) {
                            function r(e) {
                                return t.a.ix === e || "Anchor Point" === e ? r.anchorPoint : t.o.ix === e || "Opacity" === e ? r.opacity : t.p.ix === e || "Position" === e ? r.position : t.r.ix === e || "Rotation" === e || "ADBE Vector Rotation" === e ? r.rotation : t.s.ix === e || "Scale" === e ? r.scale : t.sk && t.sk.ix === e || "Skew" === e ? r.skew : t.sa && t.sa.ix === e || "Skew Axis" === e ? r.skewAxis : null
                            }
                            var n = propertyGroupFactory(r, e);
                            return view.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", n)), view.transform.mProps.p.setGroupProperty(PropertyInterface("Position", n)), view.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", n)), view.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", n)), view.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", n)), view.transform.mProps.sk && (view.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", n)), view.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", n))), view.transform.op.setGroupProperty(PropertyInterface("Opacity", n)), Object.defineProperties(r, {
                                opacity: {
                                    get: ExpressionPropertyInterface(view.transform.mProps.o)
                                },
                                position: {
                                    get: ExpressionPropertyInterface(view.transform.mProps.p)
                                },
                                anchorPoint: {
                                    get: ExpressionPropertyInterface(view.transform.mProps.a)
                                },
                                scale: {
                                    get: ExpressionPropertyInterface(view.transform.mProps.s)
                                },
                                rotation: {
                                    get: ExpressionPropertyInterface(view.transform.mProps.r)
                                },
                                skew: {
                                    get: ExpressionPropertyInterface(view.transform.mProps.sk)
                                },
                                skewAxis: {
                                    get: ExpressionPropertyInterface(view.transform.mProps.sa)
                                },
                                _name: {
                                    value: t.nm
                                }
                            }), r.ty = "tr", r.mn = t.mn, r.propertyGroup = e, r
                        }

                        function c(t, view, e) {
                            function r(e) {
                                return t.p.ix === e ? r.position : t.s.ix === e ? r.size : null
                            }
                            var n = propertyGroupFactory(r, e);
                            r.propertyIndex = t.ix;
                            var o = "tm" === view.sh.ty ? view.sh.prop : view.sh;
                            return o.s.setGroupProperty(PropertyInterface("Size", n)), o.p.setGroupProperty(PropertyInterface("Position", n)), Object.defineProperties(r, {
                                size: {
                                    get: ExpressionPropertyInterface(o.s)
                                },
                                position: {
                                    get: ExpressionPropertyInterface(o.p)
                                },
                                _name: {
                                    value: t.nm
                                }
                            }), r.mn = t.mn, r
                        }

                        function d(t, view, e) {
                            function r(e) {
                                return t.p.ix === e ? r.position : t.r.ix === e ? r.rotation : t.pt.ix === e ? r.points : t.or.ix === e || "ADBE Vector Star Outer Radius" === e ? r.outerRadius : t.os.ix === e ? r.outerRoundness : !t.ir || t.ir.ix !== e && "ADBE Vector Star Inner Radius" !== e ? t.is && t.is.ix === e ? r.innerRoundness : null : r.innerRadius
                            }
                            var n = propertyGroupFactory(r, e),
                                o = "tm" === view.sh.ty ? view.sh.prop : view.sh;
                            return r.propertyIndex = t.ix, o.or.setGroupProperty(PropertyInterface("Outer Radius", n)), o.os.setGroupProperty(PropertyInterface("Outer Roundness", n)), o.pt.setGroupProperty(PropertyInterface("Points", n)), o.p.setGroupProperty(PropertyInterface("Position", n)), o.r.setGroupProperty(PropertyInterface("Rotation", n)), t.ir && (o.ir.setGroupProperty(PropertyInterface("Inner Radius", n)), o.is.setGroupProperty(PropertyInterface("Inner Roundness", n))), Object.defineProperties(r, {
                                position: {
                                    get: ExpressionPropertyInterface(o.p)
                                },
                                rotation: {
                                    get: ExpressionPropertyInterface(o.r)
                                },
                                points: {
                                    get: ExpressionPropertyInterface(o.pt)
                                },
                                outerRadius: {
                                    get: ExpressionPropertyInterface(o.or)
                                },
                                outerRoundness: {
                                    get: ExpressionPropertyInterface(o.os)
                                },
                                innerRadius: {
                                    get: ExpressionPropertyInterface(o.ir)
                                },
                                innerRoundness: {
                                    get: ExpressionPropertyInterface(o.is)
                                },
                                _name: {
                                    value: t.nm
                                }
                            }), r.mn = t.mn, r
                        }

                        function m(t, view, e) {
                            function r(e) {
                                return t.p.ix === e ? r.position : t.r.ix === e ? r.roundness : t.s.ix === e || "Size" === e || "ADBE Vector Rect Size" === e ? r.size : null
                            }
                            var n = propertyGroupFactory(r, e),
                                o = "tm" === view.sh.ty ? view.sh.prop : view.sh;
                            return r.propertyIndex = t.ix, o.p.setGroupProperty(PropertyInterface("Position", n)), o.s.setGroupProperty(PropertyInterface("Size", n)), o.r.setGroupProperty(PropertyInterface("Rotation", n)), Object.defineProperties(r, {
                                position: {
                                    get: ExpressionPropertyInterface(o.p)
                                },
                                roundness: {
                                    get: ExpressionPropertyInterface(o.r)
                                },
                                size: {
                                    get: ExpressionPropertyInterface(o.s)
                                },
                                _name: {
                                    value: t.nm
                                }
                            }), r.mn = t.mn, r
                        }

                        function f(t, view, e) {
                            function r(e) {
                                return t.r.ix === e || "Round Corners 1" === e ? r.radius : null
                            }
                            var n = propertyGroupFactory(r, e),
                                o = view;
                            return r.propertyIndex = t.ix, o.rd.setGroupProperty(PropertyInterface("Radius", n)), Object.defineProperties(r, {
                                radius: {
                                    get: ExpressionPropertyInterface(o.rd)
                                },
                                _name: {
                                    value: t.nm
                                }
                            }), r.mn = t.mn, r
                        }

                        function y(t, view, e) {
                            function r(e) {
                                return t.c.ix === e || "Copies" === e ? r.copies : t.o.ix === e || "Offset" === e ? r.offset : null
                            }
                            var n = propertyGroupFactory(r, e),
                                o = view;
                            return r.propertyIndex = t.ix, o.c.setGroupProperty(PropertyInterface("Copies", n)), o.o.setGroupProperty(PropertyInterface("Offset", n)), Object.defineProperties(r, {
                                copies: {
                                    get: ExpressionPropertyInterface(o.c)
                                },
                                offset: {
                                    get: ExpressionPropertyInterface(o.o)
                                },
                                _name: {
                                    value: t.nm
                                }
                            }), r.mn = t.mn, r
                        }
                        return function (e, view, r) {
                            var n;

                            function o(t) {
                                if ("number" == typeof t) return 0 === (t = void 0 === t ? 1 : t) ? r : n[t - 1];
                                for (var i = 0, e = n.length; i < e;) {
                                    if (n[i]._name === t) return n[i];
                                    i += 1
                                }
                                return null
                            }
                            return o.propertyGroup = propertyGroupFactory(o, (function () {
                                return r
                            })), n = t(e, view, o.propertyGroup), o.numProperties = n.length, o._name = "Contents", o
                        }
                    }(),
                    TextExpressionInterface = function (t) {
                        var e, r;

                        function n(t) {
                            switch (t) {
                                case "ADBE Text Document":
                                    return n.sourceText;
                                default:
                                    return null
                            }
                        }
                        return Object.defineProperty(n, "sourceText", {
                            get: function () {
                                t.textProperty.getValue();
                                var n = t.textProperty.currentData.t;
                                return n !== e && (t.textProperty.currentData.t = e, (r = new String(n)).value = n || new String(n)), r
                            }
                        }), n
                    },
                    LayerExpressionInterface = function () {
                        function t(time) {
                            var t = new Matrix;
                            return void 0 !== time ? this._elem.finalTransform.mProp.getValueAtTime(time).clone(t) : this._elem.finalTransform.mProp.applyToMatrix(t), t
                        }

                        function e(t, time) {
                            var e = this.getMatrix(time);
                            return e.props[12] = 0, e.props[13] = 0, e.props[14] = 0, this.applyPoint(e, t)
                        }

                        function r(t, time) {
                            var e = this.getMatrix(time);
                            return this.applyPoint(e, t)
                        }

                        function n(t, time) {
                            var e = this.getMatrix(time);
                            return e.props[12] = 0, e.props[13] = 0, e.props[14] = 0, this.invertPoint(e, t)
                        }

                        function o(t, time) {
                            var e = this.getMatrix(time);
                            return this.invertPoint(e, t)
                        }

                        function h(t, e) {
                            if (this._elem.hierarchy && this._elem.hierarchy.length) {
                                var i, r = this._elem.hierarchy.length;
                                for (i = 0; i < r; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(t)
                            }
                            return t.applyToPointArray(e[0], e[1], e[2] || 0)
                        }

                        function l(t, e) {
                            if (this._elem.hierarchy && this._elem.hierarchy.length) {
                                var i, r = this._elem.hierarchy.length;
                                for (i = 0; i < r; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(t)
                            }
                            return t.inversePoint(e)
                        }

                        function c(t) {
                            var e = new Matrix;
                            if (e.reset(), this._elem.finalTransform.mProp.applyToMatrix(e), this._elem.hierarchy && this._elem.hierarchy.length) {
                                var i, r = this._elem.hierarchy.length;
                                for (i = 0; i < r; i += 1) this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(e);
                                return e.inversePoint(t)
                            }
                            return e.inversePoint(t)
                        }

                        function d() {
                            return [1, 1, 1, 1]
                        }
                        return function (m) {
                            var f;

                            function y(t) {
                                switch (t) {
                                    case "ADBE Root Vectors Group":
                                    case "Contents":
                                    case 2:
                                        return y.shapeInterface;
                                    case 1:
                                    case 6:
                                    case "Transform":
                                    case "transform":
                                    case "ADBE Transform Group":
                                        return f;
                                    case 4:
                                    case "ADBE Effect Parade":
                                    case "effects":
                                    case "Effects":
                                        return y.effect;
                                    case "ADBE Text Properties":
                                        return y.textInterface;
                                    default:
                                        return null
                                }
                            }
                            y.getMatrix = t, y.invertPoint = l, y.applyPoint = h, y.toWorld = r, y.toWorldVec = e, y.fromWorld = o, y.fromWorldVec = n, y.toComp = r, y.fromComp = c, y.sampleImage = d, y.sourceRectAtTime = m.sourceRectAtTime.bind(m), y._elem = m;
                            var v = getDescriptor(f = TransformExpressionInterface(m.finalTransform.mProp), "anchorPoint");
                            return Object.defineProperties(y, {
                                hasParent: {
                                    get: function () {
                                        return m.hierarchy.length
                                    }
                                },
                                parent: {
                                    get: function () {
                                        return m.hierarchy[0].layerInterface
                                    }
                                },
                                rotation: getDescriptor(f, "rotation"),
                                scale: getDescriptor(f, "scale"),
                                position: getDescriptor(f, "position"),
                                opacity: getDescriptor(f, "opacity"),
                                anchorPoint: v,
                                anchor_point: v,
                                transform: {
                                    get: function () {
                                        return f
                                    }
                                },
                                active: {
                                    get: function () {
                                        return m.isInRange
                                    }
                                }
                            }), y.startTime = m.data.st, y.index = m.data.ind, y.source = m.data.refId, y.height = 0 === m.data.ty ? m.data.h : 100, y.width = 0 === m.data.ty ? m.data.w : 100, y.inPoint = m.data.ip / m.comp.globalData.frameRate, y.outPoint = m.data.op / m.comp.globalData.frameRate, y._name = m.data.nm, y.registerMaskInterface = function (t) {
                                y.mask = new MaskManagerInterface(t, m)
                            }, y.registerEffectsInterface = function (t) {
                                y.effect = t
                            }, y
                        }
                    }(),
                    FootageInterface = (dataInterfaceFactory = function (t) {
                        function e(t) {
                            return "Outline" === t ? e.outlineInterface() : null
                        }
                        return e._name = "Outline", e.outlineInterface = function (t) {
                            var e = "",
                                r = t.getFootageData();

                            function n(t) {
                                if (r[t]) return e = t, "object" == typeof (r = r[t]) ? n : r;
                                var o = t.indexOf(e);
                                if (-1 !== o) {
                                    var h = parseInt(t.substr(o + e.length), 10);
                                    return "object" == typeof (r = r[h]) ? n : r
                                }
                                return ""
                            }
                            return function () {
                                return e = "", r = t.getFootageData(), n
                            }
                        }(t), e
                    }, function (t) {
                        function e(t) {
                            return "Data" === t ? e.dataInterface : null
                        }
                        return e._name = "Data", e.dataInterface = dataInterfaceFactory(t), e
                    }),
                    dataInterfaceFactory, CompExpressionInterface = function (t) {
                        function e(e) {
                            for (var i = 0, r = t.layers.length; i < r;) {
                                if (t.layers[i].nm === e || t.layers[i].ind === e) return t.elements[i].layerInterface;
                                i += 1
                            }
                            return null
                        }
                        return Object.defineProperty(e, "_name", {
                            value: t.data.nm
                        }), e.layer = e, e.pixelAspect = 1, e.height = t.data.h || t.globalData.compSize.h, e.width = t.data.w || t.globalData.compSize.w, e.pixelAspect = 1, e.frameDuration = 1 / t.globalData.frameRate, e.displayStartTime = 0, e.numLayers = t.layers.length, e
                    },
                    TransformExpressionInterface = function (t) {
                        function e(t) {
                            switch (t) {
                                case "scale":
                                case "Scale":
                                case "ADBE Scale":
                                case 6:
                                    return e.scale;
                                case "rotation":
                                case "Rotation":
                                case "ADBE Rotation":
                                case "ADBE Rotate Z":
                                case 10:
                                    return e.rotation;
                                case "ADBE Rotate X":
                                    return e.xRotation;
                                case "ADBE Rotate Y":
                                    return e.yRotation;
                                case "position":
                                case "Position":
                                case "ADBE Position":
                                case 2:
                                    return e.position;
                                case "ADBE Position_0":
                                    return e.xPosition;
                                case "ADBE Position_1":
                                    return e.yPosition;
                                case "ADBE Position_2":
                                    return e.zPosition;
                                case "anchorPoint":
                                case "AnchorPoint":
                                case "Anchor Point":
                                case "ADBE AnchorPoint":
                                case 1:
                                    return e.anchorPoint;
                                case "opacity":
                                case "Opacity":
                                case 11:
                                    return e.opacity;
                                default:
                                    return null
                            }
                        }
                        var r, n, o, h;
                        return Object.defineProperty(e, "rotation", {
                            get: ExpressionPropertyInterface(t.r || t.rz)
                        }), Object.defineProperty(e, "zRotation", {
                            get: ExpressionPropertyInterface(t.rz || t.r)
                        }), Object.defineProperty(e, "xRotation", {
                            get: ExpressionPropertyInterface(t.rx)
                        }), Object.defineProperty(e, "yRotation", {
                            get: ExpressionPropertyInterface(t.ry)
                        }), Object.defineProperty(e, "scale", {
                            get: ExpressionPropertyInterface(t.s)
                        }), t.p ? h = ExpressionPropertyInterface(t.p) : (r = ExpressionPropertyInterface(t.px), n = ExpressionPropertyInterface(t.py), t.pz && (o = ExpressionPropertyInterface(t.pz))), Object.defineProperty(e, "position", {
                            get: function () {
                                return t.p ? h() : [r(), n(), o ? o() : 0]
                            }
                        }), Object.defineProperty(e, "xPosition", {
                            get: ExpressionPropertyInterface(t.px)
                        }), Object.defineProperty(e, "yPosition", {
                            get: ExpressionPropertyInterface(t.py)
                        }), Object.defineProperty(e, "zPosition", {
                            get: ExpressionPropertyInterface(t.pz)
                        }), Object.defineProperty(e, "anchorPoint", {
                            get: ExpressionPropertyInterface(t.a)
                        }), Object.defineProperty(e, "opacity", {
                            get: ExpressionPropertyInterface(t.o)
                        }), Object.defineProperty(e, "skew", {
                            get: ExpressionPropertyInterface(t.sk)
                        }), Object.defineProperty(e, "skewAxis", {
                            get: ExpressionPropertyInterface(t.sa)
                        }), Object.defineProperty(e, "orientation", {
                            get: ExpressionPropertyInterface(t.or)
                        }), e
                    },
                    ProjectInterface = function () {
                        function t(t) {
                            this.compositions.push(t)
                        }
                        return function () {
                            function e(t) {
                                for (var i = 0, e = this.compositions.length; i < e;) {
                                    if (this.compositions[i].data && this.compositions[i].data.nm === t) return this.compositions[i].prepareFrame && this.compositions[i].data.xt && this.compositions[i].prepareFrame(this.currentFrame), this.compositions[i].compInterface;
                                    i += 1
                                }
                                return null
                            }
                            return e.compositions = [], e.currentFrame = 0, e.registerComposition = t, e
                        }
                    }(),
                    EffectsExpressionInterface = function () {
                        function t(data, r, n, o) {
                            function h(t) {
                                for (var e = data.ef, i = 0, r = e.length; i < r;) {
                                    if (t === e[i].nm || t === e[i].mn || t === e[i].ix) return 5 === e[i].ty ? c[i] : c[i]();
                                    i += 1
                                }
                                throw new Error
                            }
                            var i, l = propertyGroupFactory(h, n),
                                c = [],
                                d = data.ef.length;
                            for (i = 0; i < d; i += 1) 5 === data.ef[i].ty ? c.push(t(data.ef[i], r.effectElements[i], r.effectElements[i].propertyGroup, o)) : c.push(e(r.effectElements[i], data.ef[i].ty, o, l));
                            return "ADBE Color Control" === data.mn && Object.defineProperty(h, "color", {
                                get: function () {
                                    return c[0]()
                                }
                            }), Object.defineProperties(h, {
                                numProperties: {
                                    get: function () {
                                        return data.np
                                    }
                                },
                                _name: {
                                    value: data.nm
                                },
                                propertyGroup: {
                                    value: l
                                }
                            }), h.enabled = 0 !== data.en, h.active = h.enabled, h
                        }

                        function e(element, t, e, r) {
                            var n = ExpressionPropertyInterface(element.p);
                            return element.p.setGroupProperty && element.p.setGroupProperty(PropertyInterface("", r)),
                                function () {
                                    return 10 === t ? e.comp.compInterface(element.p.v) : n()
                                }
                        }
                        return {
                            createEffectsInterface: function (e, r) {
                                if (e.effectsManager) {
                                    var i, n = [],
                                        o = e.data.ef,
                                        h = e.effectsManager.effectElements.length;
                                    for (i = 0; i < h; i += 1) n.push(t(o[i], e.effectsManager.effectElements[i], r, e));
                                    var l = e.data.ef || [],
                                        c = function (t) {
                                            for (i = 0, h = l.length; i < h;) {
                                                if (t === l[i].nm || t === l[i].mn || t === l[i].ix) return n[i];
                                                i += 1
                                            }
                                            return null
                                        };
                                    return Object.defineProperty(c, "numProperties", {
                                        get: function () {
                                            return l.length
                                        }
                                    }), c
                                }
                                return null
                            }
                        }
                    }(),
                    MaskManagerInterface = function () {
                        function t(mask, data) {
                            this._mask = mask, this._data = data
                        }
                        return Object.defineProperty(t.prototype, "maskPath", {
                                get: function () {
                                    return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop
                                }
                            }), Object.defineProperty(t.prototype, "maskOpacity", {
                                get: function () {
                                    return this._mask.op.k && this._mask.op.getValue(), 100 * this._mask.op.v
                                }
                            }),
                            function (e) {
                                var i, r = createSizedArray(e.viewData.length),
                                    n = e.viewData.length;
                                for (i = 0; i < n; i += 1) r[i] = new t(e.viewData[i], e.masksProperties[i]);
                                return function (t) {
                                    for (i = 0; i < n;) {
                                        if (e.masksProperties[i].nm === t) return r[i];
                                        i += 1
                                    }
                                    return null
                                }
                            }
                    }(),
                    ExpressionPropertyInterface = function () {
                        var t = {
                                pv: 0,
                                v: 0,
                                mult: 1
                            },
                            e = {
                                pv: [0, 0, 0],
                                v: [0, 0, 0],
                                mult: 1
                            };

                        function r(t, e, r) {
                            Object.defineProperty(t, "velocity", {
                                get: function () {
                                    return e.getVelocityAtTime(e.comp.currentFrame)
                                }
                            }), t.numKeys = e.keyframes ? e.keyframes.length : 0, t.key = function (n) {
                                if (!t.numKeys) return 0;
                                var o = "";
                                o = "s" in e.keyframes[n - 1] ? e.keyframes[n - 1].s : "e" in e.keyframes[n - 2] ? e.keyframes[n - 2].e : e.keyframes[n - 2].s;
                                var h = "unidimensional" === r ? new Number(o) : Object.assign({}, o);
                                return h.time = e.keyframes[n - 1].t / e.elem.comp.globalData.frameRate, h.value = "unidimensional" === r ? o[0] : o, h
                            }, t.valueAtTime = e.getValueAtTime, t.speedAtTime = e.getSpeedAtTime, t.velocityAtTime = e.getVelocityAtTime, t.propertyGroup = e.propertyGroup
                        }

                        function n() {
                            return t
                        }
                        return function (o) {
                            return o ? "unidimensional" === o.propType ? function (e) {
                                e && "pv" in e || (e = t);
                                var n = 1 / e.mult,
                                    o = e.pv * n,
                                    h = new Number(o);
                                return h.value = o, r(h, e, "unidimensional"),
                                    function () {
                                        return e.k && e.getValue(), o = e.v * n, h.value !== o && ((h = new Number(o)).value = o, r(h, e, "unidimensional")), h
                                    }
                            }(o) : function (t) {
                                t && "pv" in t || (t = e);
                                var n = 1 / t.mult,
                                    o = t.data && t.data.l || t.pv.length,
                                    h = createTypedArray("float32", o),
                                    l = createTypedArray("float32", o);
                                return h.value = l, r(h, t, "multidimensional"),
                                    function () {
                                        t.k && t.getValue();
                                        for (var i = 0; i < o; i += 1) l[i] = t.v[i] * n, h[i] = l[i];
                                        return h
                                    }
                            }(o) : n
                        }
                    }(),
                    TextExpressionSelectorPropFactory = function () {
                        function t(t, e) {
                            return this.textIndex = t + 1, this.textTotal = e, this.v = this.getValue() * this.mult, this.v
                        }
                        return function (e, data) {
                            this.pv = 1, this.comp = e.comp, this.elem = e, this.mult = .01, this.propType = "textSelector", this.textTotal = data.totalChars, this.selectorValue = 100, this.lastValue = [1, 1, 1], this.k = !0, this.x = !0, this.getValue = ExpressionManager.initiateExpression.bind(this)(e, data, this), this.getMult = t, this.getVelocityAtTime = expressionHelpers.getVelocityAtTime, this.kf ? this.getValueAtTime = expressionHelpers.getValueAtTime.bind(this) : this.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(this), this.setGroupProperty = expressionHelpers.setGroupProperty
                        }
                    }(),
                    propertyGetTextProp = TextSelectorProp.getTextSelectorProp;

                function SliderEffect(data, t, e) {
                    this.p = PropertyFactory.getProp(t, data.v, 0, 0, e)
                }

                function AngleEffect(data, t, e) {
                    this.p = PropertyFactory.getProp(t, data.v, 0, 0, e)
                }

                function ColorEffect(data, t, e) {
                    this.p = PropertyFactory.getProp(t, data.v, 1, 0, e)
                }

                function PointEffect(data, t, e) {
                    this.p = PropertyFactory.getProp(t, data.v, 1, 0, e)
                }

                function LayerIndexEffect(data, t, e) {
                    this.p = PropertyFactory.getProp(t, data.v, 0, 0, e)
                }

                function MaskIndexEffect(data, t, e) {
                    this.p = PropertyFactory.getProp(t, data.v, 0, 0, e)
                }

                function CheckboxEffect(data, t, e) {
                    this.p = PropertyFactory.getProp(t, data.v, 0, 0, e)
                }

                function NoValueEffect() {
                    this.p = {}
                }

                function EffectsManager(data, element) {
                    var i, t = data.ef || [];
                    this.effectElements = [];
                    var e, r = t.length;
                    for (i = 0; i < r; i += 1) e = new GroupEffect(t[i], element), this.effectElements.push(e)
                }

                function GroupEffect(data, element) {
                    this.init(data, element)
                }
                TextSelectorProp.getTextSelectorProp = function (t, data, e) {
                    return 1 === data.t ? new TextExpressionSelectorPropFactory(t, data, e) : propertyGetTextProp(t, data, e)
                }, extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function (data, element) {
                    var i;
                    this.data = data, this.effectElements = [], this.initDynamicPropertyContainer(element);
                    var t, e = this.data.ef.length,
                        r = this.data.ef;
                    for (i = 0; i < e; i += 1) {
                        switch (t = null, r[i].ty) {
                            case 0:
                                t = new SliderEffect(r[i], element, this);
                                break;
                            case 1:
                                t = new AngleEffect(r[i], element, this);
                                break;
                            case 2:
                                t = new ColorEffect(r[i], element, this);
                                break;
                            case 3:
                                t = new PointEffect(r[i], element, this);
                                break;
                            case 4:
                            case 7:
                                t = new CheckboxEffect(r[i], element, this);
                                break;
                            case 10:
                                t = new LayerIndexEffect(r[i], element, this);
                                break;
                            case 11:
                                t = new MaskIndexEffect(r[i], element, this);
                                break;
                            case 5:
                                t = new EffectsManager(r[i], element, this);
                                break;
                            default:
                                t = new NoValueEffect(r[i], element, this)
                        }
                        t && this.effectElements.push(t)
                    }
                };
                var lottie = {};

                function setLocationHref(t) {
                    locationHref = t
                }

                function searchAnimations() {
                    !0 === standalone ? animationManager.searchAnimations(animationData, standalone, renderer) : animationManager.searchAnimations()
                }

                function setSubframeRendering(t) {
                    subframeEnabled = t
                }

                function setIDPrefix(t) {
                    idPrefix = t
                }

                function loadAnimation(t) {
                    return !0 === standalone && (t.animationData = JSON.parse(animationData)), animationManager.loadAnimation(t)
                }

                function setQuality(t) {
                    if ("string" == typeof t) switch (t) {
                        case "high":
                            defaultCurveSegments = 200;
                            break;
                        default:
                        case "medium":
                            defaultCurveSegments = 50;
                            break;
                        case "low":
                            defaultCurveSegments = 10
                    } else !isNaN(t) && t > 1 && (defaultCurveSegments = t);
                    roundValues(!(defaultCurveSegments >= 50))
                }

                function inBrowser() {
                    return "undefined" != typeof navigator
                }

                function installPlugin(t, e) {
                    "expressions" === t && (expressionsPlugin = e)
                }

                function getFactory(t) {
                    switch (t) {
                        case "propertyFactory":
                            return PropertyFactory;
                        case "shapePropertyFactory":
                            return ShapePropertyFactory;
                        case "matrix":
                            return Matrix;
                        default:
                            return null
                    }
                }

                function checkReady() {
                    "complete" === document.readyState && (clearInterval(readyStateCheckInterval), searchAnimations())
                }

                function getQueryVariable(t) {
                    for (var e = queryString.split("&"), i = 0; i < e.length; i += 1) {
                        var r = e[i].split("=");
                        if (decodeURIComponent(r[0]) == t) return decodeURIComponent(r[1])
                    }
                    return null
                }
                lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocationHref, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.setIDPrefix = setIDPrefix, lottie.__getFactory = getFactory, lottie.version = "5.7.13";
                var standalone = "__[STANDALONE]__",
                    animationData = "__[ANIMATIONDATA]__",
                    renderer = "",
                    queryString;
                if (standalone) {
                    var scripts = document.getElementsByTagName("script"),
                        index = scripts.length - 1,
                        myScript = scripts[index] || {
                            src: ""
                        };
                    queryString = myScript.src.replace(/^[^\?]+\??/, ""), renderer = getQueryVariable("renderer")
                }
                var readyStateCheckInterval = setInterval(checkReady, 100);
                return lottie
            }, void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                return factory(root)
            }.call(exports, __webpack_require__, exports, module)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
        },
        244: function (t, e, r) {
            "use strict";
            r.d(e, "a", (function () {
                return bi
            })), r.d(e, "b", (function () {
                return Ci
            })), r.d(e, "c", (function () {
                return Ui
            })), r.d(e, "d", (function () {
                return hs
            })), r.d(e, "e", (function () {
                return Ai
            })), r.d(e, "f", (function () {
                return at
            })), r.d(e, "g", (function () {
                return vt
            })), r.d(e, "h", (function () {
                return ss
            }));
            const n = 100,
                o = 301,
                h = 302,
                l = 306,
                c = 307,
                d = 1e3,
                m = 1001,
                f = 1002,
                y = 1003,
                v = 1004,
                x = 1005,
                _ = 1006,
                M = 1008,
                S = 1009,
                w = 1012,
                E = 1014,
                T = 1015,
                A = 1016,
                P = 1020,
                C = 1022,
                L = 1023,
                D = 1026,
                R = 1027,
                I = 2300,
                F = 2301,
                k = 2302,
                N = 2400,
                B = 2401,
                z = 2402,
                V = 2500,
                O = 3e3,
                G = 3001,
                H = 3007,
                U = 3002,
                W = 7680,
                j = 35044,
                X = 35048,
                Y = "300 es";
            class J {
                addEventListener(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    const r = this._listeners;
                    void 0 === r[t] && (r[t] = []), -1 === r[t].indexOf(e) && r[t].push(e)
                }
                hasEventListener(t, e) {
                    if (void 0 === this._listeners) return !1;
                    const r = this._listeners;
                    return void 0 !== r[t] && -1 !== r[t].indexOf(e)
                }
                removeEventListener(t, e) {
                    if (void 0 === this._listeners) return;
                    const r = this._listeners[t];
                    if (void 0 !== r) {
                        const t = r.indexOf(e); - 1 !== t && r.splice(t, 1)
                    }
                }
                dispatchEvent(t) {
                    if (void 0 === this._listeners) return;
                    const e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        const r = e.slice(0);
                        for (let i = 0, e = r.length; i < e; i++) r[i].call(this, t);
                        t.target = null
                    }
                }
            }
            const Z = [];
            for (let i = 0; i < 256; i++) Z[i] = (i < 16 ? "0" : "") + i.toString(16);
            const K = Math.PI / 180,
                Q = 180 / Math.PI;

            function $() {
                const t = 4294967295 * Math.random() | 0,
                    e = 4294967295 * Math.random() | 0,
                    r = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0;
                return (Z[255 & t] + Z[t >> 8 & 255] + Z[t >> 16 & 255] + Z[t >> 24 & 255] + "-" + Z[255 & e] + Z[e >> 8 & 255] + "-" + Z[e >> 16 & 15 | 64] + Z[e >> 24 & 255] + "-" + Z[63 & r | 128] + Z[r >> 8 & 255] + "-" + Z[r >> 16 & 255] + Z[r >> 24 & 255] + Z[255 & n] + Z[n >> 8 & 255] + Z[n >> 16 & 255] + Z[n >> 24 & 255]).toUpperCase()
            }

            function tt(t, e, r) {
                return Math.max(e, Math.min(r, t))
            }

            function et(t, e) {
                return (t % e + e) % e
            }

            function it(t, e, r) {
                return (1 - r) * t + r * e
            }

            function nt(t) {
                return 0 == (t & t - 1) && 0 !== t
            }

            function st(t) {
                return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
            }
            class at {
                constructor(t = 0, e = 0) {
                    this.x = t, this.y = e
                }
                get width() {
                    return this.x
                }
                set width(t) {
                    this.x = t
                }
                get height() {
                    return this.y
                }
                set height(t) {
                    this.y = t
                }
                set(t, e) {
                    return this.x = t, this.y = e, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                }
                addScalar(s) {
                    return this.x += s, this.y += s, this
                }
                addVectors(a, b) {
                    return this.x = a.x + b.x, this.y = a.y + b.y, this
                }
                addScaledVector(t, s) {
                    return this.x += t.x * s, this.y += t.y * s, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                }
                subScalar(s) {
                    return this.x -= s, this.y -= s, this
                }
                subVectors(a, b) {
                    return this.x = a.x - b.x, this.y = a.y - b.y, this
                }
                multiply(t) {
                    return this.x *= t.x, this.y *= t.y, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                applyMatrix3(t) {
                    const e = this.x,
                        r = this.y,
                        n = t.elements;
                    return this.x = n[0] * e + n[3] * r + n[6], this.y = n[1] * e + n[4] * r + n[7], this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                }
                clampLength(t, e) {
                    const r = this.length();
                    return this.divideScalar(r || 1).multiplyScalar(Math.max(t, Math.min(e, r)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y
                }
                cross(t) {
                    return this.x * t.y - this.y * t.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        r = this.y - t.y;
                    return e * e + r * r
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                }
                lerpVectors(t, e, r) {
                    return this.x = t.x + (e.x - t.x) * r, this.y = t.y + (e.y - t.y) * r, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t
                }
                fromBufferAttribute(t, e, r) {
                    return void 0 !== r && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                }
                rotateAround(t, e) {
                    const r = Math.cos(e),
                        s = Math.sin(e),
                        n = this.x - t.x,
                        o = this.y - t.y;
                    return this.x = n * r - o * s + t.x, this.y = n * s + o * r + t.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }
            }
            at.prototype.isVector2 = !0;
            class ot {
                constructor() {
                    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                }
                set(t, e, r, n, o, h, l, c, d) {
                    const m = this.elements;
                    return m[0] = t, m[1] = n, m[2] = l, m[3] = e, m[4] = o, m[5] = c, m[6] = r, m[7] = h, m[8] = d, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                copy(t) {
                    const e = this.elements,
                        r = t.elements;
                    return e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e[4] = r[4], e[5] = r[5], e[6] = r[6], e[7] = r[7], e[8] = r[8], this
                }
                extractBasis(t, e, r) {
                    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(t) {
                    const e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                }
                multiply(t) {
                    return this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(a, b) {
                    const t = a.elements,
                        e = b.elements,
                        r = this.elements,
                        n = t[0],
                        o = t[3],
                        h = t[6],
                        l = t[1],
                        c = t[4],
                        d = t[7],
                        m = t[2],
                        f = t[5],
                        y = t[8],
                        v = e[0],
                        x = e[3],
                        _ = e[6],
                        M = e[1],
                        S = e[4],
                        w = e[7],
                        E = e[2],
                        T = e[5],
                        A = e[8];
                    return r[0] = n * v + o * M + h * E, r[3] = n * x + o * S + h * T, r[6] = n * _ + o * w + h * A, r[1] = l * v + c * M + d * E, r[4] = l * x + c * S + d * T, r[7] = l * _ + c * w + d * A, r[2] = m * v + f * M + y * E, r[5] = m * x + f * S + y * T, r[8] = m * _ + f * w + y * A, this
                }
                multiplyScalar(s) {
                    const t = this.elements;
                    return t[0] *= s, t[3] *= s, t[6] *= s, t[1] *= s, t[4] *= s, t[7] *= s, t[2] *= s, t[5] *= s, t[8] *= s, this
                }
                determinant() {
                    const t = this.elements,
                        a = t[0],
                        b = t[1],
                        e = t[2],
                        r = t[3],
                        n = t[4],
                        o = t[5],
                        g = t[6],
                        h = t[7],
                        i = t[8];
                    return a * n * i - a * o * h - b * r * i + b * o * g + e * r * h - e * n * g
                }
                invert() {
                    const t = this.elements,
                        e = t[0],
                        r = t[1],
                        n = t[2],
                        o = t[3],
                        h = t[4],
                        l = t[5],
                        c = t[6],
                        d = t[7],
                        m = t[8],
                        f = m * h - l * d,
                        y = l * c - m * o,
                        v = d * o - h * c,
                        x = e * f + r * y + n * v;
                    if (0 === x) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const _ = 1 / x;
                    return t[0] = f * _, t[1] = (n * d - m * r) * _, t[2] = (l * r - n * h) * _, t[3] = y * _, t[4] = (m * e - n * c) * _, t[5] = (n * o - l * e) * _, t[6] = v * _, t[7] = (r * c - d * e) * _, t[8] = (h * e - r * o) * _, this
                }
                transpose() {
                    let t;
                    const e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                }
                getNormalMatrix(t) {
                    return this.setFromMatrix4(t).invert().transpose()
                }
                transposeIntoArray(t) {
                    const e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                }
                setUvTransform(t, e, r, n, o, h, l) {
                    const c = Math.cos(o),
                        s = Math.sin(o);
                    return this.set(r * c, r * s, -r * (c * h + s * l) + h + t, -n * s, n * c, -n * (-s * h + c * l) + l + e, 0, 0, 1), this
                }
                scale(t, e) {
                    const r = this.elements;
                    return r[0] *= t, r[3] *= t, r[6] *= t, r[1] *= e, r[4] *= e, r[7] *= e, this
                }
                rotate(t) {
                    const e = Math.cos(t),
                        s = Math.sin(t),
                        r = this.elements,
                        n = r[0],
                        o = r[3],
                        h = r[6],
                        l = r[1],
                        c = r[4],
                        d = r[7];
                    return r[0] = e * n + s * l, r[3] = e * o + s * c, r[6] = e * h + s * d, r[1] = -s * n + e * l, r[4] = -s * o + e * c, r[7] = -s * h + e * d, this
                }
                translate(t, e) {
                    const r = this.elements;
                    return r[0] += t * r[2], r[3] += t * r[5], r[6] += t * r[8], r[1] += e * r[2], r[4] += e * r[5], r[7] += e * r[8], this
                }
                equals(t) {
                    const e = this.elements,
                        r = t.elements;
                    for (let i = 0; i < 9; i++)
                        if (e[i] !== r[i]) return !1;
                    return !0
                }
                fromArray(t, e = 0) {
                    for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
                    return this
                }
                toArray(t = [], e = 0) {
                    const r = this.elements;
                    return t[e] = r[0], t[e + 1] = r[1], t[e + 2] = r[2], t[e + 3] = r[3], t[e + 4] = r[4], t[e + 5] = r[5], t[e + 6] = r[6], t[e + 7] = r[7], t[e + 8] = r[8], t
                }
                clone() {
                    return (new this.constructor).fromArray(this.elements)
                }
            }
            let ht;
            ot.prototype.isMatrix3 = !0;
            class lt {
                static getDataURL(image) {
                    if (/^data:/i.test(image.src)) return image.src;
                    if ("undefined" == typeof HTMLCanvasElement) return image.src;
                    let canvas;
                    if (image instanceof HTMLCanvasElement) canvas = image;
                    else {
                        void 0 === ht && (ht = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), ht.width = image.width, ht.height = image.height;
                        const t = ht.getContext("2d");
                        image instanceof ImageData ? t.putImageData(image, 0, 0) : t.drawImage(image, 0, 0, image.width, image.height), canvas = ht
                    }
                    return canvas.width > 2048 || canvas.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image), canvas.toDataURL("image/jpeg", .6)) : canvas.toDataURL("image/png")
                }
            }
            let ct = 0;
            class pt extends J {
                constructor(image = pt.DEFAULT_IMAGE, t = pt.DEFAULT_MAPPING, e = 1001, r = 1001, n = 1006, o = 1008, h = 1023, l = 1009, c = 1, d = 3e3) {
                    super(), Object.defineProperty(this, "id", {
                        value: ct++
                    }), this.uuid = $(), this.name = "", this.image = image, this.mipmaps = [], this.mapping = t, this.wrapS = e, this.wrapT = r, this.magFilter = n, this.minFilter = o, this.anisotropy = c, this.format = h, this.internalFormat = null, this.type = l, this.offset = new at(0, 0), this.repeat = new at(1, 1), this.center = new at(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ot, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = d, this.version = 0, this.onUpdate = null
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(source) {
                    return this.name = source.name, this.image = source.image, this.mipmaps = source.mipmaps.slice(0), this.mapping = source.mapping, this.wrapS = source.wrapS, this.wrapT = source.wrapT, this.magFilter = source.magFilter, this.minFilter = source.minFilter, this.anisotropy = source.anisotropy, this.format = source.format, this.internalFormat = source.internalFormat, this.type = source.type, this.offset.copy(source.offset), this.repeat.copy(source.repeat), this.center.copy(source.center), this.rotation = source.rotation, this.matrixAutoUpdate = source.matrixAutoUpdate, this.matrix.copy(source.matrix), this.generateMipmaps = source.generateMipmaps, this.premultiplyAlpha = source.premultiplyAlpha, this.flipY = source.flipY, this.unpackAlignment = source.unpackAlignment, this.encoding = source.encoding, this
                }
                toJSON(meta) {
                    const t = void 0 === meta || "string" == typeof meta;
                    if (!t && void 0 !== meta.textures[this.uuid]) return meta.textures[this.uuid];
                    const output = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (void 0 !== this.image) {
                        const image = this.image;
                        if (void 0 === image.uuid && (image.uuid = $()), !t && void 0 === meta.images[image.uuid]) {
                            let t;
                            if (Array.isArray(image)) {
                                t = [];
                                for (let i = 0, e = image.length; i < e; i++) image[i].isDataTexture ? t.push(ut(image[i].image)) : t.push(ut(image[i]))
                            } else t = ut(image);
                            meta.images[image.uuid] = {
                                uuid: image.uuid,
                                url: t
                            }
                        }
                        output.image = image.uuid
                    }
                    return t || (meta.textures[this.uuid] = output), output
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(t) {
                    if (300 !== this.mapping) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case d:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case m:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case f:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case d:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case m:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case f:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
            }

            function ut(image) {
                return "undefined" != typeof HTMLImageElement && image instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && image instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && image instanceof ImageBitmap ? lt.getDataURL(image) : image.data ? {
                    data: Array.prototype.slice.call(image.data),
                    width: image.width,
                    height: image.height,
                    type: image.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
            }
            pt.DEFAULT_IMAGE = void 0, pt.DEFAULT_MAPPING = 300, pt.prototype.isTexture = !0;
            class mt {
                constructor(t = 0, e = 0, r = 0, n = 1) {
                    this.x = t, this.y = e, this.z = r, this.w = n
                }
                get width() {
                    return this.z
                }
                set width(t) {
                    this.z = t
                }
                get height() {
                    return this.w
                }
                set height(t) {
                    this.w = t
                }
                set(t, e, r, n) {
                    return this.x = t, this.y = e, this.z = r, this.w = n, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setW(t) {
                    return this.w = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                }
                addScalar(s) {
                    return this.x += s, this.y += s, this.z += s, this.w += s, this
                }
                addVectors(a, b) {
                    return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, this
                }
                addScaledVector(t, s) {
                    return this.x += t.x * s, this.y += t.y * s, this.z += t.z * s, this.w += t.w * s, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                }
                subScalar(s) {
                    return this.x -= s, this.y -= s, this.z -= s, this.w -= s, this
                }
                subVectors(a, b) {
                    return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, this
                }
                multiply(t) {
                    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                }
                applyMatrix4(t) {
                    const e = this.x,
                        r = this.y,
                        n = this.z,
                        o = this.w,
                        h = t.elements;
                    return this.x = h[0] * e + h[4] * r + h[8] * n + h[12] * o, this.y = h[1] * e + h[5] * r + h[9] * n + h[13] * o, this.z = h[2] * e + h[6] * r + h[10] * n + h[14] * o, this.w = h[3] * e + h[7] * r + h[11] * n + h[15] * o, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                setAxisAngleFromQuaternion(q) {
                    this.w = 2 * Math.acos(q.w);
                    const s = Math.sqrt(1 - q.w * q.w);
                    return s < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = q.x / s, this.y = q.y / s, this.z = q.z / s), this
                }
                setAxisAngleFromRotationMatrix(t) {
                    let e, r, n, o;
                    const h = .01,
                        l = .1,
                        c = t.elements,
                        d = c[0],
                        m = c[4],
                        f = c[8],
                        y = c[1],
                        v = c[5],
                        x = c[9],
                        _ = c[2],
                        M = c[6],
                        S = c[10];
                    if (Math.abs(m - y) < h && Math.abs(f - _) < h && Math.abs(x - M) < h) {
                        if (Math.abs(m + y) < l && Math.abs(f + _) < l && Math.abs(x + M) < l && Math.abs(d + v + S - 3) < l) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        const t = (d + 1) / 2,
                            c = (v + 1) / 2,
                            w = (S + 1) / 2,
                            E = (m + y) / 4,
                            T = (f + _) / 4,
                            A = (x + M) / 4;
                        return t > c && t > w ? t < h ? (r = 0, n = .707106781, o = .707106781) : (r = Math.sqrt(t), n = E / r, o = T / r) : c > w ? c < h ? (r = .707106781, n = 0, o = .707106781) : (n = Math.sqrt(c), r = E / n, o = A / n) : w < h ? (r = .707106781, n = .707106781, o = 0) : (o = Math.sqrt(w), r = T / o, n = A / o), this.set(r, n, o, e), this
                    }
                    let s = Math.sqrt((M - x) * (M - x) + (f - _) * (f - _) + (y - m) * (y - m));
                    return Math.abs(s) < .001 && (s = 1), this.x = (M - x) / s, this.y = (f - _) / s, this.z = (y - m) / s, this.w = Math.acos((d + v + S - 1) / 2), this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
                }
                clampLength(t, e) {
                    const r = this.length();
                    return this.divideScalar(r || 1).multiplyScalar(Math.max(t, Math.min(e, r)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                }
                lerpVectors(t, e, r) {
                    return this.x = t.x + (e.x - t.x) * r, this.y = t.y + (e.y - t.y) * r, this.z = t.z + (e.z - t.z) * r, this.w = t.w + (e.w - t.w) * r, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                }
                fromBufferAttribute(t, e, r) {
                    return void 0 !== r && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }
            }
            mt.prototype.isVector4 = !0;
            class ft extends J {
                constructor(t, e, r = {}) {
                    super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new mt(0, 0, t, e), this.scissorTest = !1, this.viewport = new mt(0, 0, t, e), this.texture = new pt(void 0, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.encoding), this.texture.image = {
                        width: t,
                        height: e,
                        depth: 1
                    }, this.texture.generateMipmaps = void 0 !== r.generateMipmaps && r.generateMipmaps, this.texture.minFilter = void 0 !== r.minFilter ? r.minFilter : _, this.depthBuffer = void 0 === r.depthBuffer || r.depthBuffer, this.stencilBuffer = void 0 !== r.stencilBuffer && r.stencilBuffer, this.depthTexture = void 0 !== r.depthTexture ? r.depthTexture : null
                }
                setTexture(t) {
                    t.image = {
                        width: this.width,
                        height: this.height,
                        depth: this.depth
                    }, this.texture = t
                }
                setSize(t, e, r = 1) {
                    this.width === t && this.height === e && this.depth === r || (this.width = t, this.height = e, this.depth = r, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = r, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(source) {
                    return this.width = source.width, this.height = source.height, this.depth = source.depth, this.viewport.copy(source.viewport), this.texture = source.texture.clone(), this.texture.image = {
                        ...this.texture.image
                    }, this.depthBuffer = source.depthBuffer, this.stencilBuffer = source.stencilBuffer, this.depthTexture = source.depthTexture, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            ft.prototype.isWebGLRenderTarget = !0;
            (class extends ft {
                constructor(t, e, r) {
                    super(t, e);
                    const n = this.texture;
                    this.texture = [];
                    for (let i = 0; i < r; i++) this.texture[i] = n.clone()
                }
                setSize(t, e, r = 1) {
                    if (this.width !== t || this.height !== e || this.depth !== r) {
                        this.width = t, this.height = e, this.depth = r;
                        for (let i = 0, n = this.texture.length; i < n; i++) this.texture[i].image.width = t, this.texture[i].image.height = e, this.texture[i].image.depth = r;
                        this.dispose()
                    }
                    return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
                }
                copy(source) {
                    this.dispose(), this.width = source.width, this.height = source.height, this.depth = source.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = source.depthBuffer, this.stencilBuffer = source.stencilBuffer, this.depthTexture = source.depthTexture, this.texture.length = 0;
                    for (let i = 0, t = source.texture.length; i < t; i++) this.texture[i] = source.texture[i].clone();
                    return this
                }
            }).prototype.isWebGLMultipleRenderTargets = !0;
            class gt extends ft {
                constructor(t, e, r) {
                    super(t, e, r), this.samples = 4
                }
                copy(source) {
                    return super.copy.call(this, source), this.samples = source.samples, this
                }
            }
            gt.prototype.isWebGLMultisampleRenderTarget = !0;
            class yt {
                constructor(t = 0, e = 0, r = 0, n = 1) {
                    this._x = t, this._y = e, this._z = r, this._w = n
                }
                static slerp(t, e, r, n) {
                    return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), r.slerpQuaternions(t, e, n)
                }
                static slerpFlat(t, e, r, n, o, h, l) {
                    let c = r[n + 0],
                        d = r[n + 1],
                        m = r[n + 2],
                        f = r[n + 3];
                    const y = o[h + 0],
                        v = o[h + 1],
                        x = o[h + 2],
                        _ = o[h + 3];
                    if (0 === l) return t[e + 0] = c, t[e + 1] = d, t[e + 2] = m, void(t[e + 3] = f);
                    if (1 === l) return t[e + 0] = y, t[e + 1] = v, t[e + 2] = x, void(t[e + 3] = _);
                    if (f !== _ || c !== y || d !== v || m !== x) {
                        let s = 1 - l;
                        const t = c * y + d * v + m * x + f * _,
                            e = t >= 0 ? 1 : -1,
                            r = 1 - t * t;
                        if (r > Number.EPSILON) {
                            const n = Math.sqrt(r),
                                o = Math.atan2(n, t * e);
                            s = Math.sin(s * o) / n, l = Math.sin(l * o) / n
                        }
                        const n = l * e;
                        if (c = c * s + y * n, d = d * s + v * n, m = m * s + x * n, f = f * s + _ * n, s === 1 - l) {
                            const t = 1 / Math.sqrt(c * c + d * d + m * m + f * f);
                            c *= t, d *= t, m *= t, f *= t
                        }
                    }
                    t[e] = c, t[e + 1] = d, t[e + 2] = m, t[e + 3] = f
                }
                static multiplyQuaternionsFlat(t, e, r, n, o, h) {
                    const l = r[n],
                        c = r[n + 1],
                        d = r[n + 2],
                        m = r[n + 3],
                        f = o[h],
                        y = o[h + 1],
                        v = o[h + 2],
                        x = o[h + 3];
                    return t[e] = l * x + m * f + c * v - d * y, t[e + 1] = c * x + m * y + d * f - l * v, t[e + 2] = d * x + m * v + l * y - c * f, t[e + 3] = m * x - l * f - c * y - d * v, t
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(t) {
                    this._w = t, this._onChangeCallback()
                }
                set(t, e, r, n) {
                    return this._x = t, this._y = e, this._z = r, this._w = n, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                }
                setFromEuler(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    const r = t._x,
                        n = t._y,
                        o = t._z,
                        h = t._order,
                        l = Math.cos,
                        c = Math.sin,
                        d = l(r / 2),
                        m = l(n / 2),
                        f = l(o / 2),
                        y = c(r / 2),
                        v = c(n / 2),
                        x = c(o / 2);
                    switch (h) {
                        case "XYZ":
                            this._x = y * m * f + d * v * x, this._y = d * v * f - y * m * x, this._z = d * m * x + y * v * f, this._w = d * m * f - y * v * x;
                            break;
                        case "YXZ":
                            this._x = y * m * f + d * v * x, this._y = d * v * f - y * m * x, this._z = d * m * x - y * v * f, this._w = d * m * f + y * v * x;
                            break;
                        case "ZXY":
                            this._x = y * m * f - d * v * x, this._y = d * v * f + y * m * x, this._z = d * m * x + y * v * f, this._w = d * m * f - y * v * x;
                            break;
                        case "ZYX":
                            this._x = y * m * f - d * v * x, this._y = d * v * f + y * m * x, this._z = d * m * x - y * v * f, this._w = d * m * f + y * v * x;
                            break;
                        case "YZX":
                            this._x = y * m * f + d * v * x, this._y = d * v * f + y * m * x, this._z = d * m * x - y * v * f, this._w = d * m * f - y * v * x;
                            break;
                        case "XZY":
                            this._x = y * m * f - d * v * x, this._y = d * v * f - y * m * x, this._z = d * m * x + y * v * f, this._w = d * m * f + y * v * x;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + h)
                    }
                    return !1 !== e && this._onChangeCallback(), this
                }
                setFromAxisAngle(t, e) {
                    const r = e / 2,
                        s = Math.sin(r);
                    return this._x = t.x * s, this._y = t.y * s, this._z = t.z * s, this._w = Math.cos(r), this._onChangeCallback(), this
                }
                setFromRotationMatrix(t) {
                    const e = t.elements,
                        r = e[0],
                        n = e[4],
                        o = e[8],
                        h = e[1],
                        l = e[5],
                        c = e[9],
                        d = e[2],
                        m = e[6],
                        f = e[10],
                        y = r + l + f;
                    if (y > 0) {
                        const s = .5 / Math.sqrt(y + 1);
                        this._w = .25 / s, this._x = (m - c) * s, this._y = (o - d) * s, this._z = (h - n) * s
                    } else if (r > l && r > f) {
                        const s = 2 * Math.sqrt(1 + r - l - f);
                        this._w = (m - c) / s, this._x = .25 * s, this._y = (n + h) / s, this._z = (o + d) / s
                    } else if (l > f) {
                        const s = 2 * Math.sqrt(1 + l - r - f);
                        this._w = (o - d) / s, this._x = (n + h) / s, this._y = .25 * s, this._z = (c + m) / s
                    } else {
                        const s = 2 * Math.sqrt(1 + f - r - l);
                        this._w = (h - n) / s, this._x = (o + d) / s, this._y = (c + m) / s, this._z = .25 * s
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(t, e) {
                    let r = t.dot(e) + 1;
                    return r < Number.EPSILON ? (r = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = r)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = r), this.normalize()
                }
                angleTo(q) {
                    return 2 * Math.acos(Math.abs(tt(this.dot(q), -1, 1)))
                }
                rotateTowards(q, t) {
                    const e = this.angleTo(q);
                    if (0 === e) return this;
                    const r = Math.min(1, t / e);
                    return this.slerp(q, r), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                }
                multiply(q, p) {
                    return void 0 !== p ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(q, p)) : this.multiplyQuaternions(this, q)
                }
                premultiply(q) {
                    return this.multiplyQuaternions(q, this)
                }
                multiplyQuaternions(a, b) {
                    const t = a._x,
                        e = a._y,
                        r = a._z,
                        n = a._w,
                        o = b._x,
                        h = b._y,
                        l = b._z,
                        c = b._w;
                    return this._x = t * c + n * o + e * l - r * h, this._y = e * c + n * h + r * o - t * l, this._z = r * c + n * l + t * h - e * o, this._w = n * c - t * o - e * h - r * l, this._onChangeCallback(), this
                }
                slerp(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    const r = this._x,
                        n = this._y,
                        o = this._z,
                        h = this._w;
                    let l = h * t._w + r * t._x + n * t._y + o * t._z;
                    if (l < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, l = -l) : this.copy(t), l >= 1) return this._w = h, this._x = r, this._y = n, this._z = o, this;
                    const c = 1 - l * l;
                    if (c <= Number.EPSILON) {
                        const s = 1 - e;
                        return this._w = s * h + e * this._w, this._x = s * r + e * this._x, this._y = s * n + e * this._y, this._z = s * o + e * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    const d = Math.sqrt(c),
                        m = Math.atan2(d, l),
                        f = Math.sin((1 - e) * m) / d,
                        y = Math.sin(e * m) / d;
                    return this._w = h * f + this._w * y, this._x = r * f + this._x * y, this._y = n * f + this._y * y, this._z = o * f + this._z * y, this._onChangeCallback(), this
                }
                slerpQuaternions(t, e, r) {
                    this.copy(t).slerp(e, r)
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                }
                fromArray(t, e = 0) {
                    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                }
                fromBufferAttribute(t, e) {
                    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}
            }
            yt.prototype.isQuaternion = !0;
            class vt {
                constructor(t = 0, e = 0, r = 0) {
                    this.x = t, this.y = e, this.z = r
                }
                set(t, e, r) {
                    return void 0 === r && (r = this.z), this.x = t, this.y = e, this.z = r, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                }
                addScalar(s) {
                    return this.x += s, this.y += s, this.z += s, this
                }
                addVectors(a, b) {
                    return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this
                }
                addScaledVector(t, s) {
                    return this.x += t.x * s, this.y += t.y * s, this.z += t.z * s, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                }
                subScalar(s) {
                    return this.x -= s, this.y -= s, this.z -= s, this
                }
                subVectors(a, b) {
                    return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                }
                multiplyVectors(a, b) {
                    return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this
                }
                applyEuler(t) {
                    return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(_t.setFromEuler(t))
                }
                applyAxisAngle(t, e) {
                    return this.applyQuaternion(_t.setFromAxisAngle(t, e))
                }
                applyMatrix3(t) {
                    const e = this.x,
                        r = this.y,
                        n = this.z,
                        o = t.elements;
                    return this.x = o[0] * e + o[3] * r + o[6] * n, this.y = o[1] * e + o[4] * r + o[7] * n, this.z = o[2] * e + o[5] * r + o[8] * n, this
                }
                applyNormalMatrix(t) {
                    return this.applyMatrix3(t).normalize()
                }
                applyMatrix4(t) {
                    const e = this.x,
                        r = this.y,
                        n = this.z,
                        o = t.elements,
                        h = 1 / (o[3] * e + o[7] * r + o[11] * n + o[15]);
                    return this.x = (o[0] * e + o[4] * r + o[8] * n + o[12]) * h, this.y = (o[1] * e + o[5] * r + o[9] * n + o[13]) * h, this.z = (o[2] * e + o[6] * r + o[10] * n + o[14]) * h, this
                }
                applyQuaternion(q) {
                    const t = this.x,
                        e = this.y,
                        r = this.z,
                        n = q.x,
                        o = q.y,
                        h = q.z,
                        l = q.w,
                        c = l * t + o * r - h * e,
                        d = l * e + h * t - n * r,
                        m = l * r + n * e - o * t,
                        f = -n * t - o * e - h * r;
                    return this.x = c * l + f * -n + d * -h - m * -o, this.y = d * l + f * -o + m * -n - c * -h, this.z = m * l + f * -h + c * -o - d * -n, this
                }
                project(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                }
                unproject(t) {
                    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                }
                transformDirection(t) {
                    const e = this.x,
                        r = this.y,
                        n = this.z,
                        o = t.elements;
                    return this.x = o[0] * e + o[4] * r + o[8] * n, this.y = o[1] * e + o[5] * r + o[9] * n, this.z = o[2] * e + o[6] * r + o[10] * n, this.normalize()
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                }
                clampLength(t, e) {
                    const r = this.length();
                    return this.divideScalar(r || 1).multiplyScalar(Math.max(t, Math.min(e, r)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                }
                lerpVectors(t, e, r) {
                    return this.x = t.x + (e.x - t.x) * r, this.y = t.y + (e.y - t.y) * r, this.z = t.z + (e.z - t.z) * r, this
                }
                cross(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                }
                crossVectors(a, b) {
                    const t = a.x,
                        e = a.y,
                        r = a.z,
                        n = b.x,
                        o = b.y,
                        h = b.z;
                    return this.x = e * h - r * o, this.y = r * n - t * h, this.z = t * o - e * n, this
                }
                projectOnVector(t) {
                    const e = t.lengthSq();
                    if (0 === e) return this.set(0, 0, 0);
                    const r = t.dot(this) / e;
                    return this.copy(t).multiplyScalar(r)
                }
                projectOnPlane(t) {
                    return xt.copy(this).projectOnVector(t), this.sub(xt)
                }
                reflect(t) {
                    return this.sub(xt.copy(t).multiplyScalar(2 * this.dot(t)))
                }
                angleTo(t) {
                    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                    if (0 === e) return Math.PI / 2;
                    const r = this.dot(t) / e;
                    return Math.acos(tt(r, -1, 1))
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        r = this.y - t.y,
                        n = this.z - t.z;
                    return e * e + r * r + n * n
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                }
                setFromSpherical(s) {
                    return this.setFromSphericalCoords(s.radius, s.phi, s.theta)
                }
                setFromSphericalCoords(t, e, r) {
                    const n = Math.sin(e) * t;
                    return this.x = n * Math.sin(r), this.y = Math.cos(e) * t, this.z = n * Math.cos(r), this
                }
                setFromCylindrical(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                }
                setFromCylindricalCoords(t, e, r) {
                    return this.x = t * Math.sin(e), this.y = r, this.z = t * Math.cos(e), this
                }
                setFromMatrixPosition(t) {
                    const e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                }
                setFromMatrixScale(t) {
                    const e = this.setFromMatrixColumn(t, 0).length(),
                        r = this.setFromMatrixColumn(t, 1).length(),
                        n = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = r, this.z = n, this
                }
                setFromMatrixColumn(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                }
                setFromMatrix3Column(t, e) {
                    return this.fromArray(t.elements, 3 * e)
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                }
                fromBufferAttribute(t, e, r) {
                    return void 0 !== r && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
            }
            vt.prototype.isVector3 = !0;
            const xt = new vt,
                _t = new yt;
            class bt {
                constructor(t = new vt(1 / 0, 1 / 0, 1 / 0), e = new vt(-1 / 0, -1 / 0, -1 / 0)) {
                    this.min = t, this.max = e
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                }
                setFromArray(t) {
                    let e = 1 / 0,
                        r = 1 / 0,
                        n = 1 / 0,
                        o = -1 / 0,
                        h = -1 / 0,
                        l = -1 / 0;
                    for (let i = 0, c = t.length; i < c; i += 3) {
                        const c = t[i],
                            d = t[i + 1],
                            m = t[i + 2];
                        c < e && (e = c), d < r && (r = d), m < n && (n = m), c > o && (o = c), d > h && (h = d), m > l && (l = m)
                    }
                    return this.min.set(e, r, n), this.max.set(o, h, l), this
                }
                setFromBufferAttribute(t) {
                    let e = 1 / 0,
                        r = 1 / 0,
                        n = 1 / 0,
                        o = -1 / 0,
                        h = -1 / 0,
                        l = -1 / 0;
                    for (let i = 0, c = t.count; i < c; i++) {
                        const c = t.getX(i),
                            d = t.getY(i),
                            m = t.getZ(i);
                        c < e && (e = c), d < r && (r = d), m < n && (n = m), c > o && (o = c), d > h && (h = d), m > l && (l = m)
                    }
                    return this.min.set(e, r, n), this.max.set(o, h, l), this
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let i = 0, e = t.length; i < e; i++) this.expandByPoint(t[i]);
                    return this
                }
                setFromCenterAndSize(t, e) {
                    const r = St.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
                }
                setFromObject(object) {
                    return this.makeEmpty(), this.expandByObject(object)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(t) {
                    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(t) {
                    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                }
                expandByObject(object) {
                    object.updateWorldMatrix(!1, !1);
                    const t = object.geometry;
                    void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), wt.copy(t.boundingBox), wt.applyMatrix4(object.matrixWorld), this.union(wt));
                    const e = object.children;
                    for (let i = 0, t = e.length; i < t; i++) this.expandByObject(e[i]);
                    return this
                }
                containsPoint(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                }
                containsBox(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                }
                getParameter(t, e) {
                    return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                }
                intersectsSphere(t) {
                    return this.clampPoint(t.center, St), St.distanceToSquared(t.center) <= t.radius * t.radius
                }
                intersectsPlane(t) {
                    let e, r;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, r = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, r = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, r += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, r += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, r += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, r += t.normal.z * this.min.z), e <= -t.constant && r >= -t.constant
                }
                intersectsTriangle(t) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(Dt), Rt.subVectors(this.max, Dt), Et.subVectors(t.a, Dt), Tt.subVectors(t.b, Dt), At.subVectors(t.c, Dt), Pt.subVectors(Tt, Et), Ct.subVectors(At, Tt), Lt.subVectors(Et, At);
                    let e = [0, -Pt.z, Pt.y, 0, -Ct.z, Ct.y, 0, -Lt.z, Lt.y, Pt.z, 0, -Pt.x, Ct.z, 0, -Ct.x, Lt.z, 0, -Lt.x, -Pt.y, Pt.x, 0, -Ct.y, Ct.x, 0, -Lt.y, Lt.x, 0];
                    return !!kt(e, Et, Tt, At, Rt) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!kt(e, Et, Tt, At, Rt) && (It.crossVectors(Pt, Ct), e = [It.x, It.y, It.z], kt(e, Et, Tt, At, Rt)))
                }
                clampPoint(t, e) {
                    return e.copy(t).clamp(this.min, this.max)
                }
                distanceToPoint(t) {
                    return St.copy(t).clamp(this.min, this.max).sub(t).length()
                }
                getBoundingSphere(t) {
                    return this.getCenter(t.center), t.radius = .5 * this.getSize(St).length(), t
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                }
                applyMatrix4(t) {
                    return this.isEmpty() || (Mt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Mt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Mt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Mt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Mt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Mt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Mt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Mt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Mt)), this
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }
            bt.prototype.isBox3 = !0;
            const Mt = [new vt, new vt, new vt, new vt, new vt, new vt, new vt, new vt],
                St = new vt,
                wt = new bt,
                Et = new vt,
                Tt = new vt,
                At = new vt,
                Pt = new vt,
                Ct = new vt,
                Lt = new vt,
                Dt = new vt,
                Rt = new vt,
                It = new vt,
                Ft = new vt;

            function kt(t, e, r, n, o) {
                for (let i = 0, h = t.length - 3; i <= h; i += 3) {
                    Ft.fromArray(t, i);
                    const h = o.x * Math.abs(Ft.x) + o.y * Math.abs(Ft.y) + o.z * Math.abs(Ft.z),
                        l = e.dot(Ft),
                        c = r.dot(Ft),
                        d = n.dot(Ft);
                    if (Math.max(-Math.max(l, c, d), Math.min(l, c, d)) > h) return !1
                }
                return !0
            }
            const Nt = new bt,
                Bt = new vt,
                zt = new vt,
                Vt = new vt;
            class Ot {
                constructor(t = new vt, e = -1) {
                    this.center = t, this.radius = e
                }
                set(t, e) {
                    return this.center.copy(t), this.radius = e, this
                }
                setFromPoints(t, e) {
                    const r = this.center;
                    void 0 !== e ? r.copy(e) : Nt.setFromPoints(t).getCenter(r);
                    let n = 0;
                    for (let i = 0, e = t.length; i < e; i++) n = Math.max(n, r.distanceToSquared(t[i]));
                    return this.radius = Math.sqrt(n), this
                }
                copy(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(t) {
                    return t.distanceTo(this.center) - this.radius
                }
                intersectsSphere(t) {
                    const e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                }
                intersectsBox(t) {
                    return t.intersectsSphere(this)
                }
                intersectsPlane(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(t, e) {
                    const r = this.center.distanceToSquared(t);
                    return e.copy(t), r > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                }
                getBoundingBox(t) {
                    return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
                }
                applyMatrix4(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                }
                translate(t) {
                    return this.center.add(t), this
                }
                expandByPoint(t) {
                    Vt.subVectors(t, this.center);
                    const e = Vt.lengthSq();
                    if (e > this.radius * this.radius) {
                        const t = Math.sqrt(e),
                            r = .5 * (t - this.radius);
                        this.center.add(Vt.multiplyScalar(r / t)), this.radius += r
                    }
                    return this
                }
                union(t) {
                    return zt.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(Bt.copy(t.center).add(zt)), this.expandByPoint(Bt.copy(t.center).sub(zt)), this
                }
                equals(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Gt = new vt,
                Ht = new vt,
                Ut = new vt,
                Wt = new vt,
                jt = new vt,
                qt = new vt,
                Xt = new vt;
            class Yt {
                constructor(t = new vt, e = new vt(0, 0, -1)) {
                    this.origin = t, this.direction = e
                }
                set(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                }
                copy(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                }
                at(t, e) {
                    return e.copy(this.direction).multiplyScalar(t).add(this.origin)
                }
                lookAt(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                }
                recast(t) {
                    return this.origin.copy(this.at(t, Gt)), this
                }
                closestPointToPoint(t, e) {
                    e.subVectors(t, this.origin);
                    const r = e.dot(this.direction);
                    return r < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(r).add(this.origin)
                }
                distanceToPoint(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                }
                distanceSqToPoint(t) {
                    const e = Gt.subVectors(t, this.origin).dot(this.direction);
                    return e < 0 ? this.origin.distanceToSquared(t) : (Gt.copy(this.direction).multiplyScalar(e).add(this.origin), Gt.distanceToSquared(t))
                }
                distanceSqToSegment(t, e, r, n) {
                    Ht.copy(t).add(e).multiplyScalar(.5), Ut.copy(e).sub(t).normalize(), Wt.copy(this.origin).sub(Ht);
                    const o = .5 * t.distanceTo(e),
                        h = -this.direction.dot(Ut),
                        l = Wt.dot(this.direction),
                        c = -Wt.dot(Ut),
                        d = Wt.lengthSq(),
                        m = Math.abs(1 - h * h);
                    let f, y, v, x;
                    if (m > 0)
                        if (f = h * c - l, y = h * l - c, x = o * m, f >= 0)
                            if (y >= -x)
                                if (y <= x) {
                                    const t = 1 / m;
                                    f *= t, y *= t, v = f * (f + h * y + 2 * l) + y * (h * f + y + 2 * c) + d
                                } else y = o, f = Math.max(0, -(h * y + l)), v = -f * f + y * (y + 2 * c) + d;
                    else y = -o, f = Math.max(0, -(h * y + l)), v = -f * f + y * (y + 2 * c) + d;
                    else y <= -x ? (f = Math.max(0, -(-h * o + l)), y = f > 0 ? -o : Math.min(Math.max(-o, -c), o), v = -f * f + y * (y + 2 * c) + d) : y <= x ? (f = 0, y = Math.min(Math.max(-o, -c), o), v = y * (y + 2 * c) + d) : (f = Math.max(0, -(h * o + l)), y = f > 0 ? o : Math.min(Math.max(-o, -c), o), v = -f * f + y * (y + 2 * c) + d);
                    else y = h > 0 ? -o : o, f = Math.max(0, -(h * y + l)), v = -f * f + y * (y + 2 * c) + d;
                    return r && r.copy(this.direction).multiplyScalar(f).add(this.origin), n && n.copy(Ut).multiplyScalar(y).add(Ht), v
                }
                intersectSphere(t, e) {
                    Gt.subVectors(t.center, this.origin);
                    const r = Gt.dot(this.direction),
                        n = Gt.dot(Gt) - r * r,
                        o = t.radius * t.radius;
                    if (n > o) return null;
                    const h = Math.sqrt(o - n),
                        l = r - h,
                        c = r + h;
                    return l < 0 && c < 0 ? null : l < 0 ? this.at(c, e) : this.at(l, e)
                }
                intersectsSphere(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                }
                distanceToPlane(t) {
                    const e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    const r = -(this.origin.dot(t.normal) + t.constant) / e;
                    return r >= 0 ? r : null
                }
                intersectPlane(t, e) {
                    const r = this.distanceToPlane(t);
                    return null === r ? null : this.at(r, e)
                }
                intersectsPlane(t) {
                    const e = t.distanceToPoint(this.origin);
                    if (0 === e) return !0;
                    return t.normal.dot(this.direction) * e < 0
                }
                intersectBox(t, e) {
                    let r, n, o, h, l, c;
                    const d = 1 / this.direction.x,
                        m = 1 / this.direction.y,
                        f = 1 / this.direction.z,
                        y = this.origin;
                    return d >= 0 ? (r = (t.min.x - y.x) * d, n = (t.max.x - y.x) * d) : (r = (t.max.x - y.x) * d, n = (t.min.x - y.x) * d), m >= 0 ? (o = (t.min.y - y.y) * m, h = (t.max.y - y.y) * m) : (o = (t.max.y - y.y) * m, h = (t.min.y - y.y) * m), r > h || o > n ? null : ((o > r || r != r) && (r = o), (h < n || n != n) && (n = h), f >= 0 ? (l = (t.min.z - y.z) * f, c = (t.max.z - y.z) * f) : (l = (t.max.z - y.z) * f, c = (t.min.z - y.z) * f), r > c || l > n ? null : ((l > r || r != r) && (r = l), (c < n || n != n) && (n = c), n < 0 ? null : this.at(r >= 0 ? r : n, e)))
                }
                intersectsBox(t) {
                    return null !== this.intersectBox(t, Gt)
                }
                intersectTriangle(a, b, t, e, r) {
                    jt.subVectors(b, a), qt.subVectors(t, a), Xt.crossVectors(jt, qt);
                    let n, o = this.direction.dot(Xt);
                    if (o > 0) {
                        if (e) return null;
                        n = 1
                    } else {
                        if (!(o < 0)) return null;
                        n = -1, o = -o
                    }
                    Wt.subVectors(this.origin, a);
                    const h = n * this.direction.dot(qt.crossVectors(Wt, qt));
                    if (h < 0) return null;
                    const l = n * this.direction.dot(jt.cross(Wt));
                    if (l < 0) return null;
                    if (h + l > o) return null;
                    const c = -n * Wt.dot(Xt);
                    return c < 0 ? null : this.at(c / o, r)
                }
                applyMatrix4(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                }
                equals(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class Jt {
                constructor() {
                    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                }
                set(t, e, r, n, o, h, l, c, d, m, f, y, v, x, _, M) {
                    const S = this.elements;
                    return S[0] = t, S[4] = e, S[8] = r, S[12] = n, S[1] = o, S[5] = h, S[9] = l, S[13] = c, S[2] = d, S[6] = m, S[10] = f, S[14] = y, S[3] = v, S[7] = x, S[11] = _, S[15] = M, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return (new Jt).fromArray(this.elements)
                }
                copy(t) {
                    const e = this.elements,
                        r = t.elements;
                    return e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e[4] = r[4], e[5] = r[5], e[6] = r[6], e[7] = r[7], e[8] = r[8], e[9] = r[9], e[10] = r[10], e[11] = r[11], e[12] = r[12], e[13] = r[13], e[14] = r[14], e[15] = r[15], this
                }
                copyPosition(t) {
                    const e = this.elements,
                        r = t.elements;
                    return e[12] = r[12], e[13] = r[13], e[14] = r[14], this
                }
                setFromMatrix3(t) {
                    const e = t.elements;
                    return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
                }
                extractBasis(t, e, r) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this
                }
                makeBasis(t, e, r) {
                    return this.set(t.x, e.x, r.x, 0, t.y, e.y, r.y, 0, t.z, e.z, r.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(t) {
                    const e = this.elements,
                        r = t.elements,
                        n = 1 / Zt.setFromMatrixColumn(t, 0).length(),
                        o = 1 / Zt.setFromMatrixColumn(t, 1).length(),
                        h = 1 / Zt.setFromMatrixColumn(t, 2).length();
                    return e[0] = r[0] * n, e[1] = r[1] * n, e[2] = r[2] * n, e[3] = 0, e[4] = r[4] * o, e[5] = r[5] * o, e[6] = r[6] * o, e[7] = 0, e[8] = r[8] * h, e[9] = r[9] * h, e[10] = r[10] * h, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromEuler(t) {
                    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    const e = this.elements,
                        r = t.x,
                        n = t.y,
                        o = t.z,
                        a = Math.cos(r),
                        b = Math.sin(r),
                        h = Math.cos(n),
                        l = Math.sin(n),
                        c = Math.cos(o),
                        d = Math.sin(o);
                    if ("XYZ" === t.order) {
                        const t = a * c,
                            r = a * d,
                            n = b * c,
                            o = b * d;
                        e[0] = h * c, e[4] = -h * d, e[8] = l, e[1] = r + n * l, e[5] = t - o * l, e[9] = -b * h, e[2] = o - t * l, e[6] = n + r * l, e[10] = a * h
                    } else if ("YXZ" === t.order) {
                        const t = h * c,
                            r = h * d,
                            n = l * c,
                            o = l * d;
                        e[0] = t + o * b, e[4] = n * b - r, e[8] = a * l, e[1] = a * d, e[5] = a * c, e[9] = -b, e[2] = r * b - n, e[6] = o + t * b, e[10] = a * h
                    } else if ("ZXY" === t.order) {
                        const t = h * c,
                            r = h * d,
                            n = l * c,
                            o = l * d;
                        e[0] = t - o * b, e[4] = -a * d, e[8] = n + r * b, e[1] = r + n * b, e[5] = a * c, e[9] = o - t * b, e[2] = -a * l, e[6] = b, e[10] = a * h
                    } else if ("ZYX" === t.order) {
                        const t = a * c,
                            r = a * d,
                            n = b * c,
                            o = b * d;
                        e[0] = h * c, e[4] = n * l - r, e[8] = t * l + o, e[1] = h * d, e[5] = o * l + t, e[9] = r * l - n, e[2] = -l, e[6] = b * h, e[10] = a * h
                    } else if ("YZX" === t.order) {
                        const t = a * h,
                            r = a * l,
                            n = b * h,
                            o = b * l;
                        e[0] = h * c, e[4] = o - t * d, e[8] = n * d + r, e[1] = d, e[5] = a * c, e[9] = -b * c, e[2] = -l * c, e[6] = r * d + n, e[10] = t - o * d
                    } else if ("XZY" === t.order) {
                        const t = a * h,
                            r = a * l,
                            n = b * h,
                            o = b * l;
                        e[0] = h * c, e[4] = -d, e[8] = l * c, e[1] = t * d + o, e[5] = a * c, e[9] = r * d - n, e[2] = n * d - r, e[6] = b * c, e[10] = o * d + t
                    }
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromQuaternion(q) {
                    return this.compose(Qt, q, $t)
                }
                lookAt(t, e, r) {
                    const n = this.elements;
                    return ie.subVectors(t, e), 0 === ie.lengthSq() && (ie.z = 1), ie.normalize(), te.crossVectors(r, ie), 0 === te.lengthSq() && (1 === Math.abs(r.z) ? ie.x += 1e-4 : ie.z += 1e-4, ie.normalize(), te.crossVectors(r, ie)), te.normalize(), ee.crossVectors(ie, te), n[0] = te.x, n[4] = ee.x, n[8] = ie.x, n[1] = te.y, n[5] = ee.y, n[9] = ie.y, n[2] = te.z, n[6] = ee.z, n[10] = ie.z, this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(a, b) {
                    const t = a.elements,
                        e = b.elements,
                        r = this.elements,
                        n = t[0],
                        o = t[4],
                        h = t[8],
                        l = t[12],
                        c = t[1],
                        d = t[5],
                        m = t[9],
                        f = t[13],
                        y = t[2],
                        v = t[6],
                        x = t[10],
                        _ = t[14],
                        M = t[3],
                        S = t[7],
                        w = t[11],
                        E = t[15],
                        T = e[0],
                        A = e[4],
                        P = e[8],
                        C = e[12],
                        L = e[1],
                        D = e[5],
                        R = e[9],
                        I = e[13],
                        F = e[2],
                        k = e[6],
                        N = e[10],
                        B = e[14],
                        z = e[3],
                        V = e[7],
                        O = e[11],
                        G = e[15];
                    return r[0] = n * T + o * L + h * F + l * z, r[4] = n * A + o * D + h * k + l * V, r[8] = n * P + o * R + h * N + l * O, r[12] = n * C + o * I + h * B + l * G, r[1] = c * T + d * L + m * F + f * z, r[5] = c * A + d * D + m * k + f * V, r[9] = c * P + d * R + m * N + f * O, r[13] = c * C + d * I + m * B + f * G, r[2] = y * T + v * L + x * F + _ * z, r[6] = y * A + v * D + x * k + _ * V, r[10] = y * P + v * R + x * N + _ * O, r[14] = y * C + v * I + x * B + _ * G, r[3] = M * T + S * L + w * F + E * z, r[7] = M * A + S * D + w * k + E * V, r[11] = M * P + S * R + w * N + E * O, r[15] = M * C + S * I + w * B + E * G, this
                }
                multiplyScalar(s) {
                    const t = this.elements;
                    return t[0] *= s, t[4] *= s, t[8] *= s, t[12] *= s, t[1] *= s, t[5] *= s, t[9] *= s, t[13] *= s, t[2] *= s, t[6] *= s, t[10] *= s, t[14] *= s, t[3] *= s, t[7] *= s, t[11] *= s, t[15] *= s, this
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        r = t[4],
                        n = t[8],
                        o = t[12],
                        h = t[1],
                        l = t[5],
                        c = t[9],
                        d = t[13],
                        m = t[2],
                        f = t[6],
                        y = t[10],
                        v = t[14];
                    return t[3] * (+o * c * f - n * d * f - o * l * y + r * d * y + n * l * v - r * c * v) + t[7] * (+e * c * v - e * d * y + o * h * y - n * h * v + n * d * m - o * c * m) + t[11] * (+e * d * f - e * l * v - o * h * f + r * h * v + o * l * m - r * d * m) + t[15] * (-n * l * m - e * c * f + e * l * y + n * h * f - r * h * y + r * c * m)
                }
                transpose() {
                    const t = this.elements;
                    let e;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                }
                setPosition(t, e, r) {
                    const n = this.elements;
                    return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = r), this
                }
                invert() {
                    const t = this.elements,
                        e = t[0],
                        r = t[1],
                        n = t[2],
                        o = t[3],
                        h = t[4],
                        l = t[5],
                        c = t[6],
                        d = t[7],
                        m = t[8],
                        f = t[9],
                        y = t[10],
                        v = t[11],
                        x = t[12],
                        _ = t[13],
                        M = t[14],
                        S = t[15],
                        w = f * M * d - _ * y * d + _ * c * v - l * M * v - f * c * S + l * y * S,
                        E = x * y * d - m * M * d - x * c * v + h * M * v + m * c * S - h * y * S,
                        T = m * _ * d - x * f * d + x * l * v - h * _ * v - m * l * S + h * f * S,
                        A = x * f * c - m * _ * c - x * l * y + h * _ * y + m * l * M - h * f * M,
                        P = e * w + r * E + n * T + o * A;
                    if (0 === P) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const C = 1 / P;
                    return t[0] = w * C, t[1] = (_ * y * o - f * M * o - _ * n * v + r * M * v + f * n * S - r * y * S) * C, t[2] = (l * M * o - _ * c * o + _ * n * d - r * M * d - l * n * S + r * c * S) * C, t[3] = (f * c * o - l * y * o - f * n * d + r * y * d + l * n * v - r * c * v) * C, t[4] = E * C, t[5] = (m * M * o - x * y * o + x * n * v - e * M * v - m * n * S + e * y * S) * C, t[6] = (x * c * o - h * M * o - x * n * d + e * M * d + h * n * S - e * c * S) * C, t[7] = (h * y * o - m * c * o + m * n * d - e * y * d - h * n * v + e * c * v) * C, t[8] = T * C, t[9] = (x * f * o - m * _ * o - x * r * v + e * _ * v + m * r * S - e * f * S) * C, t[10] = (h * _ * o - x * l * o + x * r * d - e * _ * d - h * r * S + e * l * S) * C, t[11] = (m * l * o - h * f * o - m * r * d + e * f * d + h * r * v - e * l * v) * C, t[12] = A * C, t[13] = (m * _ * n - x * f * n + x * r * y - e * _ * y - m * r * M + e * f * M) * C, t[14] = (x * l * n - h * _ * n - x * r * c + e * _ * c + h * r * M - e * l * M) * C, t[15] = (h * f * n - m * l * n + m * r * c - e * f * c - h * r * y + e * l * y) * C, this
                }
                scale(t) {
                    const e = this.elements,
                        r = t.x,
                        n = t.y,
                        o = t.z;
                    return e[0] *= r, e[4] *= n, e[8] *= o, e[1] *= r, e[5] *= n, e[9] *= o, e[2] *= r, e[6] *= n, e[10] *= o, e[3] *= r, e[7] *= n, e[11] *= o, this
                }
                getMaxScaleOnAxis() {
                    const t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        r = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, r, n))
                }
                makeTranslation(t, e, r) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, r, 0, 0, 0, 1), this
                }
                makeRotationX(t) {
                    const e = Math.cos(t),
                        s = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -s, 0, 0, s, e, 0, 0, 0, 0, 1), this
                }
                makeRotationY(t) {
                    const e = Math.cos(t),
                        s = Math.sin(t);
                    return this.set(e, 0, s, 0, 0, 1, 0, 0, -s, 0, e, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(t) {
                    const e = Math.cos(t),
                        s = Math.sin(t);
                    return this.set(e, -s, 0, 0, s, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(t, e) {
                    const r = Math.cos(e),
                        s = Math.sin(e),
                        n = 1 - r,
                        o = t.x,
                        h = t.y,
                        l = t.z,
                        c = n * o,
                        d = n * h;
                    return this.set(c * o + r, c * h - s * l, c * l + s * h, 0, c * h + s * l, d * h + r, d * l - s * o, 0, c * l - s * h, d * l + s * o, n * l * l + r, 0, 0, 0, 0, 1), this
                }
                makeScale(t, e, r) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this
                }
                makeShear(t, e, r, n, o, h) {
                    return this.set(1, r, o, 0, t, 1, h, 0, e, n, 1, 0, 0, 0, 0, 1), this
                }
                compose(t, e, r) {
                    const n = this.elements,
                        o = e._x,
                        h = e._y,
                        l = e._z,
                        c = e._w,
                        d = o + o,
                        m = h + h,
                        f = l + l,
                        y = o * d,
                        v = o * m,
                        x = o * f,
                        _ = h * m,
                        M = h * f,
                        S = l * f,
                        w = c * d,
                        E = c * m,
                        T = c * f,
                        A = r.x,
                        P = r.y,
                        C = r.z;
                    return n[0] = (1 - (_ + S)) * A, n[1] = (v + T) * A, n[2] = (x - E) * A, n[3] = 0, n[4] = (v - T) * P, n[5] = (1 - (y + S)) * P, n[6] = (M + w) * P, n[7] = 0, n[8] = (x + E) * C, n[9] = (M - w) * C, n[10] = (1 - (y + _)) * C, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
                }
                decompose(t, e, r) {
                    const n = this.elements;
                    let o = Zt.set(n[0], n[1], n[2]).length();
                    const h = Zt.set(n[4], n[5], n[6]).length(),
                        l = Zt.set(n[8], n[9], n[10]).length();
                    this.determinant() < 0 && (o = -o), t.x = n[12], t.y = n[13], t.z = n[14], Kt.copy(this);
                    const c = 1 / o,
                        d = 1 / h,
                        m = 1 / l;
                    return Kt.elements[0] *= c, Kt.elements[1] *= c, Kt.elements[2] *= c, Kt.elements[4] *= d, Kt.elements[5] *= d, Kt.elements[6] *= d, Kt.elements[8] *= m, Kt.elements[9] *= m, Kt.elements[10] *= m, e.setFromRotationMatrix(Kt), r.x = o, r.y = h, r.z = l, this
                }
                makePerspective(t, e, r, n, o, h) {
                    void 0 === h && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    const l = this.elements,
                        c = 2 * o / (e - t),
                        d = 2 * o / (r - n),
                        a = (e + t) / (e - t),
                        b = (r + n) / (r - n),
                        m = -(h + o) / (h - o),
                        f = -2 * h * o / (h - o);
                    return l[0] = c, l[4] = 0, l[8] = a, l[12] = 0, l[1] = 0, l[5] = d, l[9] = b, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = m, l[14] = f, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this
                }
                makeOrthographic(t, e, r, n, o, h) {
                    const l = this.elements,
                        c = 1 / (e - t),
                        d = 1 / (r - n),
                        p = 1 / (h - o),
                        m = (e + t) * c,
                        f = (r + n) * d,
                        y = (h + o) * p;
                    return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -m, l[1] = 0, l[5] = 2 * d, l[9] = 0, l[13] = -f, l[2] = 0, l[6] = 0, l[10] = -2 * p, l[14] = -y, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this
                }
                equals(t) {
                    const e = this.elements,
                        r = t.elements;
                    for (let i = 0; i < 16; i++)
                        if (e[i] !== r[i]) return !1;
                    return !0
                }
                fromArray(t, e = 0) {
                    for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
                    return this
                }
                toArray(t = [], e = 0) {
                    const r = this.elements;
                    return t[e] = r[0], t[e + 1] = r[1], t[e + 2] = r[2], t[e + 3] = r[3], t[e + 4] = r[4], t[e + 5] = r[5], t[e + 6] = r[6], t[e + 7] = r[7], t[e + 8] = r[8], t[e + 9] = r[9], t[e + 10] = r[10], t[e + 11] = r[11], t[e + 12] = r[12], t[e + 13] = r[13], t[e + 14] = r[14], t[e + 15] = r[15], t
                }
            }
            Jt.prototype.isMatrix4 = !0;
            const Zt = new vt,
                Kt = new Jt,
                Qt = new vt(0, 0, 0),
                $t = new vt(1, 1, 1),
                te = new vt,
                ee = new vt,
                ie = new vt,
                re = new Jt,
                ne = new yt;
            class se {
                constructor(t = 0, e = 0, r = 0, n = se.DefaultOrder) {
                    this._x = t, this._y = e, this._z = r, this._order = n
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(t) {
                    this._order = t, this._onChangeCallback()
                }
                set(t, e, r, n = this._order) {
                    return this._x = t, this._y = e, this._z = r, this._order = n, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(t, e = this._order, r = !0) {
                    const n = t.elements,
                        o = n[0],
                        h = n[4],
                        l = n[8],
                        c = n[1],
                        d = n[5],
                        m = n[9],
                        f = n[2],
                        y = n[6],
                        v = n[10];
                    switch (e) {
                        case "XYZ":
                            this._y = Math.asin(tt(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-m, v), this._z = Math.atan2(-h, o)) : (this._x = Math.atan2(y, d), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-tt(m, -1, 1)), Math.abs(m) < .9999999 ? (this._y = Math.atan2(l, v), this._z = Math.atan2(c, d)) : (this._y = Math.atan2(-f, o), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(tt(y, -1, 1)), Math.abs(y) < .9999999 ? (this._y = Math.atan2(-f, v), this._z = Math.atan2(-h, d)) : (this._y = 0, this._z = Math.atan2(c, o));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-tt(f, -1, 1)), Math.abs(f) < .9999999 ? (this._x = Math.atan2(y, v), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-h, d));
                            break;
                        case "YZX":
                            this._z = Math.asin(tt(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-m, d), this._y = Math.atan2(-f, o)) : (this._x = 0, this._y = Math.atan2(l, v));
                            break;
                        case "XZY":
                            this._z = Math.asin(-tt(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(y, d), this._y = Math.atan2(l, o)) : (this._x = Math.atan2(-m, v), this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                    }
                    return this._order = e, !0 === r && this._onChangeCallback(), this
                }
                setFromQuaternion(q, t, e) {
                    return re.makeRotationFromQuaternion(q), this.setFromRotationMatrix(re, t, e)
                }
                setFromVector3(t, e = this._order) {
                    return this.set(t.x, t.y, t.z, e)
                }
                reorder(t) {
                    return ne.setFromEuler(this), this.setFromQuaternion(ne, t)
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                }
                fromArray(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                }
                toVector3(t) {
                    return t ? t.set(this._x, this._y, this._z) : new vt(this._x, this._y, this._z)
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}
            }
            se.prototype.isEuler = !0, se.DefaultOrder = "XYZ", se.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            class ae {
                constructor() {
                    this.mask = 1
                }
                set(t) {
                    this.mask = 1 << t | 0
                }
                enable(t) {
                    this.mask |= 1 << t | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(t) {
                    this.mask ^= 1 << t | 0
                }
                disable(t) {
                    this.mask &= ~(1 << t | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(t) {
                    return 0 != (this.mask & t.mask)
                }
            }
            let oe = 0;
            const he = new vt,
                le = new yt,
                ce = new Jt,
                pe = new vt,
                ue = new vt,
                de = new vt,
                me = new yt,
                fe = new vt(1, 0, 0),
                ge = new vt(0, 1, 0),
                ye = new vt(0, 0, 1),
                ve = {
                    type: "added"
                },
                xe = {
                    type: "removed"
                };
            class _e extends J {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: oe++
                    }), this.uuid = $(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = _e.DefaultUp.clone();
                    const t = new vt,
                        e = new se,
                        r = new yt,
                        n = new vt(1, 1, 1);
                    e._onChange((function () {
                        r.setFromEuler(e, !1)
                    })), r._onChange((function () {
                        e.setFromQuaternion(r, void 0, !1)
                    })), Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: r
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: n
                        },
                        modelViewMatrix: {
                            value: new Jt
                        },
                        normalMatrix: {
                            value: new ot
                        }
                    }), this.matrix = new Jt, this.matrixWorld = new Jt, this.matrixAutoUpdate = _e.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ae, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
                }
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                }
                applyQuaternion(q) {
                    return this.quaternion.premultiply(q), this
                }
                setRotationFromAxisAngle(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                }
                setRotationFromEuler(t) {
                    this.quaternion.setFromEuler(t, !0)
                }
                setRotationFromMatrix(t) {
                    this.quaternion.setFromRotationMatrix(t)
                }
                setRotationFromQuaternion(q) {
                    this.quaternion.copy(q)
                }
                rotateOnAxis(t, e) {
                    return le.setFromAxisAngle(t, e), this.quaternion.multiply(le), this
                }
                rotateOnWorldAxis(t, e) {
                    return le.setFromAxisAngle(t, e), this.quaternion.premultiply(le), this
                }
                rotateX(t) {
                    return this.rotateOnAxis(fe, t)
                }
                rotateY(t) {
                    return this.rotateOnAxis(ge, t)
                }
                rotateZ(t) {
                    return this.rotateOnAxis(ye, t)
                }
                translateOnAxis(t, e) {
                    return he.copy(t).applyQuaternion(this.quaternion), this.position.add(he.multiplyScalar(e)), this
                }
                translateX(t) {
                    return this.translateOnAxis(fe, t)
                }
                translateY(t) {
                    return this.translateOnAxis(ge, t)
                }
                translateZ(t) {
                    return this.translateOnAxis(ye, t)
                }
                localToWorld(t) {
                    return t.applyMatrix4(this.matrixWorld)
                }
                worldToLocal(t) {
                    return t.applyMatrix4(ce.copy(this.matrixWorld).invert())
                }
                lookAt(t, e, r) {
                    t.isVector3 ? pe.copy(t) : pe.set(t, e, r);
                    const n = this.parent;
                    this.updateWorldMatrix(!0, !1), ue.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ce.lookAt(ue, pe, this.up) : ce.lookAt(pe, ue, this.up), this.quaternion.setFromRotationMatrix(ce), n && (ce.extractRotation(n.matrixWorld), le.setFromRotationMatrix(ce), this.quaternion.premultiply(le.invert()))
                }
                add(object) {
                    if (arguments.length > 1) {
                        for (let i = 0; i < arguments.length; i++) this.add(arguments[i]);
                        return this
                    }
                    return object === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", object), this) : (object && object.isObject3D ? (null !== object.parent && object.parent.remove(object), object.parent = this, this.children.push(object), object.dispatchEvent(ve)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object), this)
                }
                remove(object) {
                    if (arguments.length > 1) {
                        for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
                        return this
                    }
                    const t = this.children.indexOf(object);
                    return -1 !== t && (object.parent = null, this.children.splice(t, 1), object.dispatchEvent(xe)), this
                }
                removeFromParent() {
                    const t = this.parent;
                    return null !== t && t.remove(this), this
                }
                clear() {
                    for (let i = 0; i < this.children.length; i++) {
                        const object = this.children[i];
                        object.parent = null, object.dispatchEvent(xe)
                    }
                    return this.children.length = 0, this
                }
                attach(object) {
                    return this.updateWorldMatrix(!0, !1), ce.copy(this.matrixWorld).invert(), null !== object.parent && (object.parent.updateWorldMatrix(!0, !1), ce.multiply(object.parent.matrixWorld)), object.applyMatrix4(ce), this.add(object), object.updateWorldMatrix(!1, !0), this
                }
                getObjectById(t) {
                    return this.getObjectByProperty("id", t)
                }
                getObjectByName(t) {
                    return this.getObjectByProperty("name", t)
                }
                getObjectByProperty(t, e) {
                    if (this[t] === e) return this;
                    for (let i = 0, r = this.children.length; i < r; i++) {
                        const object = this.children[i].getObjectByProperty(t, e);
                        if (void 0 !== object) return object
                    }
                }
                getWorldPosition(t) {
                    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                }
                getWorldQuaternion(t) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ue, t, de), t
                }
                getWorldScale(t) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ue, me, t), t
                }
                getWorldDirection(t) {
                    this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                }
                raycast() {}
                traverse(t) {
                    t(this);
                    const e = this.children;
                    for (let i = 0, r = e.length; i < r; i++) e[i].traverse(t)
                }
                traverseVisible(t) {
                    if (!1 === this.visible) return;
                    t(this);
                    const e = this.children;
                    for (let i = 0, r = e.length; i < r; i++) e[i].traverseVisible(t)
                }
                traverseAncestors(t) {
                    const e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                }
                updateMatrixWorld(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                    const e = this.children;
                    for (let i = 0, r = e.length; i < r; i++) e[i].updateMatrixWorld(t)
                }
                updateWorldMatrix(t, e) {
                    const r = this.parent;
                    if (!0 === t && null !== r && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                        const t = this.children;
                        for (let i = 0, e = t.length; i < e; i++) t[i].updateWorldMatrix(!1, !0)
                    }
                }
                toJSON(meta) {
                    const t = void 0 === meta || "string" == typeof meta,
                        output = {};
                    t && (meta = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {}
                    }, output.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    const object = {};

                    function e(t, element) {
                        return void 0 === t[element.uuid] && (t[element.uuid] = element.toJSON(meta)), element.uuid
                    }
                    if (object.uuid = this.uuid, object.type = this.type, "" !== this.name && (object.name = this.name), !0 === this.castShadow && (object.castShadow = !0), !0 === this.receiveShadow && (object.receiveShadow = !0), !1 === this.visible && (object.visible = !1), !1 === this.frustumCulled && (object.frustumCulled = !1), 0 !== this.renderOrder && (object.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (object.userData = this.userData), object.layers = this.layers.mask, object.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (object.matrixAutoUpdate = !1), this.isInstancedMesh && (object.type = "InstancedMesh", object.count = this.count, object.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (object.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? object.background = this.background.toJSON() : this.background.isTexture && (object.background = this.background.toJSON(meta).uuid)), this.environment && this.environment.isTexture && (object.environment = this.environment.toJSON(meta).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        object.geometry = e(meta.geometries, this.geometry);
                        const t = this.geometry.parameters;
                        if (void 0 !== t && void 0 !== t.shapes) {
                            const r = t.shapes;
                            if (Array.isArray(r))
                                for (let i = 0, t = r.length; i < t; i++) {
                                    const t = r[i];
                                    e(meta.shapes, t)
                                } else e(meta.shapes, r)
                        }
                    }
                    if (this.isSkinnedMesh && (object.bindMode = this.bindMode, object.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (e(meta.skeletons, this.skeleton), object.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const t = [];
                            for (let i = 0, r = this.material.length; i < r; i++) t.push(e(meta.materials, this.material[i]));
                            object.material = t
                        } else object.material = e(meta.materials, this.material);
                    if (this.children.length > 0) {
                        object.children = [];
                        for (let i = 0; i < this.children.length; i++) object.children.push(this.children[i].toJSON(meta).object)
                    }
                    if (this.animations.length > 0) {
                        object.animations = [];
                        for (let i = 0; i < this.animations.length; i++) {
                            const t = this.animations[i];
                            object.animations.push(e(meta.animations, t))
                        }
                    }
                    if (t) {
                        const t = r(meta.geometries),
                            e = r(meta.materials),
                            n = r(meta.textures),
                            o = r(meta.images),
                            h = r(meta.shapes),
                            l = r(meta.skeletons),
                            c = r(meta.animations);
                        t.length > 0 && (output.geometries = t), e.length > 0 && (output.materials = e), n.length > 0 && (output.textures = n), o.length > 0 && (output.images = o), h.length > 0 && (output.shapes = h), l.length > 0 && (output.skeletons = l), c.length > 0 && (output.animations = c)
                    }
                    return output.object = object, output;

                    function r(t) {
                        const e = [];
                        for (const r in t) {
                            const data = t[r];
                            delete data.metadata, e.push(data)
                        }
                        return e
                    }
                }
                clone(t) {
                    return (new this.constructor).copy(this, t)
                }
                copy(source, t = !0) {
                    if (this.name = source.name, this.up.copy(source.up), this.position.copy(source.position), this.rotation.order = source.rotation.order, this.quaternion.copy(source.quaternion), this.scale.copy(source.scale), this.matrix.copy(source.matrix), this.matrixWorld.copy(source.matrixWorld), this.matrixAutoUpdate = source.matrixAutoUpdate, this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate, this.layers.mask = source.layers.mask, this.visible = source.visible, this.castShadow = source.castShadow, this.receiveShadow = source.receiveShadow, this.frustumCulled = source.frustumCulled, this.renderOrder = source.renderOrder, this.userData = JSON.parse(JSON.stringify(source.userData)), !0 === t)
                        for (let i = 0; i < source.children.length; i++) {
                            const t = source.children[i];
                            this.add(t.clone())
                        }
                    return this
                }
            }
            _e.DefaultUp = new vt(0, 1, 0), _e.DefaultMatrixAutoUpdate = !0, _e.prototype.isObject3D = !0;
            const be = new vt,
                Me = new vt,
                Se = new vt,
                we = new vt,
                Ee = new vt,
                Te = new vt,
                Ae = new vt,
                Pe = new vt,
                Ce = new vt,
                Le = new vt;
            class De {
                constructor(a = new vt, b = new vt, t = new vt) {
                    this.a = a, this.b = b, this.c = t
                }
                static getNormal(a, b, t, e) {
                    e.subVectors(t, b), be.subVectors(a, b), e.cross(be);
                    const r = e.lengthSq();
                    return r > 0 ? e.multiplyScalar(1 / Math.sqrt(r)) : e.set(0, 0, 0)
                }
                static getBarycoord(t, a, b, e, r) {
                    be.subVectors(e, a), Me.subVectors(b, a), Se.subVectors(t, a);
                    const n = be.dot(be),
                        o = be.dot(Me),
                        h = be.dot(Se),
                        l = Me.dot(Me),
                        c = Me.dot(Se),
                        d = n * l - o * o;
                    if (0 === d) return r.set(-2, -1, -1);
                    const m = 1 / d,
                        u = (l * h - o * c) * m,
                        f = (n * c - o * h) * m;
                    return r.set(1 - u - f, f, u)
                }
                static containsPoint(t, a, b, e) {
                    return this.getBarycoord(t, a, b, e, we), we.x >= 0 && we.y >= 0 && we.x + we.y <= 1
                }
                static getUV(t, e, r, n, o, h, l, c) {
                    return this.getBarycoord(t, e, r, n, we), c.set(0, 0), c.addScaledVector(o, we.x), c.addScaledVector(h, we.y), c.addScaledVector(l, we.z), c
                }
                static isFrontFacing(a, b, t, e) {
                    return be.subVectors(t, b), Me.subVectors(a, b), be.cross(Me).dot(e) < 0
                }
                set(a, b, t) {
                    return this.a.copy(a), this.b.copy(b), this.c.copy(t), this
                }
                setFromPointsAndIndices(t, e, r, n) {
                    return this.a.copy(t[e]), this.b.copy(t[r]), this.c.copy(t[n]), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                }
                getArea() {
                    return be.subVectors(this.c, this.b), Me.subVectors(this.a, this.b), .5 * be.cross(Me).length()
                }
                getMidpoint(t) {
                    return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(t) {
                    return De.getNormal(this.a, this.b, this.c, t)
                }
                getPlane(t) {
                    return t.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(t, e) {
                    return De.getBarycoord(t, this.a, this.b, this.c, e)
                }
                getUV(t, e, r, n, o) {
                    return De.getUV(t, this.a, this.b, this.c, e, r, n, o)
                }
                containsPoint(t) {
                    return De.containsPoint(t, this.a, this.b, this.c)
                }
                isFrontFacing(t) {
                    return De.isFrontFacing(this.a, this.b, this.c, t)
                }
                intersectsBox(t) {
                    return t.intersectsTriangle(this)
                }
                closestPointToPoint(p, t) {
                    const a = this.a,
                        b = this.b,
                        e = this.c;
                    let r, n;
                    Ee.subVectors(b, a), Te.subVectors(e, a), Pe.subVectors(p, a);
                    const o = Ee.dot(Pe),
                        h = Te.dot(Pe);
                    if (o <= 0 && h <= 0) return t.copy(a);
                    Ce.subVectors(p, b);
                    const l = Ee.dot(Ce),
                        c = Te.dot(Ce);
                    if (l >= 0 && c <= l) return t.copy(b);
                    const d = o * c - l * h;
                    if (d <= 0 && o >= 0 && l <= 0) return r = o / (o - l), t.copy(a).addScaledVector(Ee, r);
                    Le.subVectors(p, e);
                    const m = Ee.dot(Le),
                        f = Te.dot(Le);
                    if (f >= 0 && m <= f) return t.copy(e);
                    const y = m * h - o * f;
                    if (y <= 0 && h >= 0 && f <= 0) return n = h / (h - f), t.copy(a).addScaledVector(Te, n);
                    const v = l * f - m * c;
                    if (v <= 0 && c - l >= 0 && m - f >= 0) return Ae.subVectors(e, b), n = (c - l) / (c - l + (m - f)), t.copy(b).addScaledVector(Ae, n);
                    const x = 1 / (v + y + d);
                    return r = y * x, n = d * x, t.copy(a).addScaledVector(Ee, r).addScaledVector(Te, n)
                }
                equals(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            }
            let Re = 0;
            class Ie extends J {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: Re++
                    }), this.uuid = $(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = n, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = W, this.stencilZFail = W, this.stencilZPass = W, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
                }
                onBuild() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString()
                }
                setValues(t) {
                    if (void 0 !== t)
                        for (const e in t) {
                            const r = t[e];
                            if (void 0 === r) {
                                console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                                continue
                            }
                            if ("shading" === e) {
                                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === r;
                                continue
                            }
                            const n = this[e];
                            void 0 !== n ? n && n.isColor ? n.set(r) : n && n.isVector3 && r && r.isVector3 ? n.copy(r) : this[e] = r : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                        }
                }
                toJSON(meta) {
                    const t = void 0 === meta || "string" == typeof meta;
                    t && (meta = {
                        textures: {},
                        images: {}
                    });
                    const data = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function e(t) {
                        const e = [];
                        for (const r in t) {
                            const data = t[r];
                            delete data.metadata, e.push(data)
                        }
                        return e
                    }
                    if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), this.color && this.color.isColor && (data.color = this.color.getHex()), void 0 !== this.roughness && (data.roughness = this.roughness), void 0 !== this.metalness && (data.metalness = this.metalness), this.sheen && this.sheen.isColor && (data.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (data.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (data.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (data.specular = this.specular.getHex()), void 0 !== this.shininess && (data.shininess = this.shininess), void 0 !== this.clearcoat && (data.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (data.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid, data.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (data.map = this.map.toJSON(meta).uuid), this.matcap && this.matcap.isTexture && (data.matcap = this.matcap.toJSON(meta).uuid), this.alphaMap && this.alphaMap.isTexture && (data.alphaMap = this.alphaMap.toJSON(meta).uuid), this.lightMap && this.lightMap.isTexture && (data.lightMap = this.lightMap.toJSON(meta).uuid, data.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (data.aoMap = this.aoMap.toJSON(meta).uuid, data.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (data.bumpMap = this.bumpMap.toJSON(meta).uuid, data.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (data.normalMap = this.normalMap.toJSON(meta).uuid, data.normalMapType = this.normalMapType, data.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (data.displacementMap = this.displacementMap.toJSON(meta).uuid, data.displacementScale = this.displacementScale, data.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (data.roughnessMap = this.roughnessMap.toJSON(meta).uuid), this.metalnessMap && this.metalnessMap.isTexture && (data.metalnessMap = this.metalnessMap.toJSON(meta).uuid), this.emissiveMap && this.emissiveMap.isTexture && (data.emissiveMap = this.emissiveMap.toJSON(meta).uuid), this.specularMap && this.specularMap.isTexture && (data.specularMap = this.specularMap.toJSON(meta).uuid), this.envMap && this.envMap.isTexture && (data.envMap = this.envMap.toJSON(meta).uuid, void 0 !== this.combine && (data.combine = this.combine)), void 0 !== this.envMapIntensity && (data.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (data.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (data.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (data.gradientMap = this.gradientMap.toJSON(meta).uuid), void 0 !== this.transmission && (data.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (data.transmissionMap = this.transmissionMap.toJSON(meta).uuid), void 0 !== this.thickness && (data.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (data.thicknessMap = this.thicknessMap.toJSON(meta).uuid), void 0 !== this.attenuationDistance && (data.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (data.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (data.size = this.size), null !== this.shadowSide && (data.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (data.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (data.blending = this.blending), 0 !== this.side && (data.side = this.side), this.vertexColors && (data.vertexColors = !0), this.opacity < 1 && (data.opacity = this.opacity), !0 === this.transparent && (data.transparent = this.transparent), data.depthFunc = this.depthFunc, data.depthTest = this.depthTest, data.depthWrite = this.depthWrite, data.colorWrite = this.colorWrite, data.stencilWrite = this.stencilWrite, data.stencilWriteMask = this.stencilWriteMask, data.stencilFunc = this.stencilFunc, data.stencilRef = this.stencilRef, data.stencilFuncMask = this.stencilFuncMask, data.stencilFail = this.stencilFail, data.stencilZFail = this.stencilZFail, data.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (data.rotation = this.rotation), !0 === this.polygonOffset && (data.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (data.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (data.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (data.linewidth = this.linewidth), void 0 !== this.dashSize && (data.dashSize = this.dashSize), void 0 !== this.gapSize && (data.gapSize = this.gapSize), void 0 !== this.scale && (data.scale = this.scale), !0 === this.dithering && (data.dithering = !0), this.alphaTest > 0 && (data.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (data.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (data.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (data.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (data.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (data.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (data.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (data.morphTargets = !0), !0 === this.morphNormals && (data.morphNormals = !0), !0 === this.flatShading && (data.flatShading = this.flatShading), !1 === this.visible && (data.visible = !1), !1 === this.toneMapped && (data.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (data.userData = this.userData), t) {
                        const t = e(meta.textures),
                            r = e(meta.images);
                        t.length > 0 && (data.textures = t), r.length > 0 && (data.images = r)
                    }
                    return data
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(source) {
                    this.name = source.name, this.fog = source.fog, this.blending = source.blending, this.side = source.side, this.vertexColors = source.vertexColors, this.opacity = source.opacity, this.transparent = source.transparent, this.blendSrc = source.blendSrc, this.blendDst = source.blendDst, this.blendEquation = source.blendEquation, this.blendSrcAlpha = source.blendSrcAlpha, this.blendDstAlpha = source.blendDstAlpha, this.blendEquationAlpha = source.blendEquationAlpha, this.depthFunc = source.depthFunc, this.depthTest = source.depthTest, this.depthWrite = source.depthWrite, this.stencilWriteMask = source.stencilWriteMask, this.stencilFunc = source.stencilFunc, this.stencilRef = source.stencilRef, this.stencilFuncMask = source.stencilFuncMask, this.stencilFail = source.stencilFail, this.stencilZFail = source.stencilZFail, this.stencilZPass = source.stencilZPass, this.stencilWrite = source.stencilWrite;
                    const t = source.clippingPlanes;
                    let e = null;
                    if (null !== t) {
                        const r = t.length;
                        e = new Array(r);
                        for (let i = 0; i !== r; ++i) e[i] = t[i].clone()
                    }
                    return this.clippingPlanes = e, this.clipIntersection = source.clipIntersection, this.clipShadows = source.clipShadows, this.shadowSide = source.shadowSide, this.colorWrite = source.colorWrite, this.precision = source.precision, this.polygonOffset = source.polygonOffset, this.polygonOffsetFactor = source.polygonOffsetFactor, this.polygonOffsetUnits = source.polygonOffsetUnits, this.dithering = source.dithering, this.alphaTest = source.alphaTest, this.alphaToCoverage = source.alphaToCoverage, this.premultipliedAlpha = source.premultipliedAlpha, this.visible = source.visible, this.toneMapped = source.toneMapped, this.userData = JSON.parse(JSON.stringify(source.userData)), this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
            }
            Ie.prototype.isMaterial = !0;
            const Fe = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                ke = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                Ne = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function Be(p, q, t) {
                return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + 6 * (q - p) * (2 / 3 - t) : p
            }

            function ze(t) {
                return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
            }

            function Ve(t) {
                return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
            }
            class Oe {
                constructor(t, g, b) {
                    return void 0 === g && void 0 === b ? this.set(t) : this.setRGB(t, g, b)
                }
                set(t) {
                    return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                }
                setScalar(t) {
                    return this.r = t, this.g = t, this.b = t, this
                }
                setHex(t) {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                }
                setRGB(t, g, b) {
                    return this.r = t, this.g = g, this.b = b, this
                }
                setHSL(t, s, e) {
                    if (t = et(t, 1), s = tt(s, 0, 1), e = tt(e, 0, 1), 0 === s) this.r = this.g = this.b = e;
                    else {
                        const p = e <= .5 ? e * (1 + s) : e + s - e * s,
                            q = 2 * e - p;
                        this.r = Be(q, p, t + 1 / 3), this.g = Be(q, p, t), this.b = Be(q, p, t - 1 / 3)
                    }
                    return this
                }
                setStyle(style) {
                    function t(t) {
                        void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + style + " will be ignored.")
                    }
                    let e;
                    if (e = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
                        let r;
                        const n = e[1],
                            o = e[2];
                        switch (n) {
                            case "rgb":
                            case "rgba":
                                if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, t(r[4]), this;
                                if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, t(r[4]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) {
                                    const e = parseFloat(r[1]) / 360,
                                        s = parseInt(r[2], 10) / 100,
                                        n = parseInt(r[3], 10) / 100;
                                    return t(r[4]), this.setHSL(e, s, n)
                                }
                        }
                    } else if (e = /^\#([A-Fa-f\d]+)$/.exec(style)) {
                        const t = e[1],
                            r = t.length;
                        if (3 === r) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                        if (6 === r) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                    }
                    return style && style.length > 0 ? this.setColorName(style) : this
                }
                setColorName(style) {
                    const t = Fe[style.toLowerCase()];
                    return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + style), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                }
                copyGammaToLinear(t, e = 2) {
                    return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                }
                copyLinearToGamma(t, e = 2) {
                    const r = e > 0 ? 1 / e : 1;
                    return this.r = Math.pow(t.r, r), this.g = Math.pow(t.g, r), this.b = Math.pow(t.b, r), this
                }
                convertGammaToLinear(t) {
                    return this.copyGammaToLinear(this, t), this
                }
                convertLinearToGamma(t) {
                    return this.copyLinearToGamma(this, t), this
                }
                copySRGBToLinear(t) {
                    return this.r = ze(t.r), this.g = ze(t.g), this.b = ze(t.b), this
                }
                copyLinearToSRGB(t) {
                    return this.r = Ve(t.r), this.g = Ve(t.g), this.b = Ve(t.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                }
                getHexString() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                }
                getHSL(t) {
                    const e = this.r,
                        g = this.g,
                        b = this.b,
                        r = Math.max(e, g, b),
                        n = Math.min(e, g, b);
                    let o, h;
                    const l = (n + r) / 2;
                    if (n === r) o = 0, h = 0;
                    else {
                        const t = r - n;
                        switch (h = l <= .5 ? t / (r + n) : t / (2 - r - n), r) {
                            case e:
                                o = (g - b) / t + (g < b ? 6 : 0);
                                break;
                            case g:
                                o = (b - e) / t + 2;
                                break;
                            case b:
                                o = (e - g) / t + 4
                        }
                        o /= 6
                    }
                    return t.h = o, t.s = h, t.l = l, t
                }
                getStyle() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                }
                offsetHSL(t, s, e) {
                    return this.getHSL(ke), ke.h += t, ke.s += s, ke.l += e, this.setHSL(ke.h, ke.s, ke.l), this
                }
                add(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                }
                addColors(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                }
                addScalar(s) {
                    return this.r += s, this.g += s, this.b += s, this
                }
                sub(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                }
                multiply(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                }
                multiplyScalar(s) {
                    return this.r *= s, this.g *= s, this.b *= s, this
                }
                lerp(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                }
                lerpColors(t, e, r) {
                    return this.r = t.r + (e.r - t.r) * r, this.g = t.g + (e.g - t.g) * r, this.b = t.b + (e.b - t.b) * r, this
                }
                lerpHSL(t, e) {
                    this.getHSL(ke), t.getHSL(Ne);
                    const r = it(ke.h, Ne.h, e),
                        s = it(ke.s, Ne.s, e),
                        n = it(ke.l, Ne.l, e);
                    return this.setHSL(r, s, n), this
                }
                equals(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                }
                fromArray(t, e = 0) {
                    return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                }
                fromBufferAttribute(t, e) {
                    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                }
                toJSON() {
                    return this.getHex()
                }
            }
            Oe.NAMES = Fe, Oe.prototype.isColor = !0, Oe.prototype.r = 1, Oe.prototype.g = 1, Oe.prototype.b = 1;
            class Ge extends Ie {
                constructor(t) {
                    super(), this.type = "MeshBasicMaterial", this.color = new Oe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.color.copy(source.color), this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.morphTargets = source.morphTargets, this
                }
            }
            Ge.prototype.isMeshBasicMaterial = !0;
            const He = new vt,
                Ue = new at;
            class We {
                constructor(t, e, r) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === r, this.usage = j, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0
                }
                onUploadCallback() {}
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
                setUsage(t) {
                    return this.usage = t, this
                }
                copy(source) {
                    return this.name = source.name, this.array = new source.array.constructor(source.array), this.itemSize = source.itemSize, this.count = source.count, this.normalized = source.normalized, this.usage = source.usage, this
                }
                copyAt(t, e, r) {
                    t *= this.itemSize, r *= e.itemSize;
                    for (let i = 0, n = this.itemSize; i < n; i++) this.array[t + i] = e.array[r + i];
                    return this
                }
                copyArray(t) {
                    return this.array.set(t), this
                }
                copyColorsArray(t) {
                    const e = this.array;
                    let r = 0;
                    for (let i = 0, n = t.length; i < n; i++) {
                        let n = t[i];
                        void 0 === n && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), n = new Oe), e[r++] = n.r, e[r++] = n.g, e[r++] = n.b
                    }
                    return this
                }
                copyVector2sArray(t) {
                    const e = this.array;
                    let r = 0;
                    for (let i = 0, n = t.length; i < n; i++) {
                        let n = t[i];
                        void 0 === n && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), n = new at), e[r++] = n.x, e[r++] = n.y
                    }
                    return this
                }
                copyVector3sArray(t) {
                    const e = this.array;
                    let r = 0;
                    for (let i = 0, n = t.length; i < n; i++) {
                        let n = t[i];
                        void 0 === n && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), n = new vt), e[r++] = n.x, e[r++] = n.y, e[r++] = n.z
                    }
                    return this
                }
                copyVector4sArray(t) {
                    const e = this.array;
                    let r = 0;
                    for (let i = 0, n = t.length; i < n; i++) {
                        let n = t[i];
                        void 0 === n && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), n = new mt), e[r++] = n.x, e[r++] = n.y, e[r++] = n.z, e[r++] = n.w
                    }
                    return this
                }
                applyMatrix3(t) {
                    if (2 === this.itemSize)
                        for (let i = 0, e = this.count; i < e; i++) Ue.fromBufferAttribute(this, i), Ue.applyMatrix3(t), this.setXY(i, Ue.x, Ue.y);
                    else if (3 === this.itemSize)
                        for (let i = 0, e = this.count; i < e; i++) He.fromBufferAttribute(this, i), He.applyMatrix3(t), this.setXYZ(i, He.x, He.y, He.z);
                    return this
                }
                applyMatrix4(t) {
                    for (let i = 0, e = this.count; i < e; i++) He.x = this.getX(i), He.y = this.getY(i), He.z = this.getZ(i), He.applyMatrix4(t), this.setXYZ(i, He.x, He.y, He.z);
                    return this
                }
                applyNormalMatrix(t) {
                    for (let i = 0, e = this.count; i < e; i++) He.x = this.getX(i), He.y = this.getY(i), He.z = this.getZ(i), He.applyNormalMatrix(t), this.setXYZ(i, He.x, He.y, He.z);
                    return this
                }
                transformDirection(t) {
                    for (let i = 0, e = this.count; i < e; i++) He.x = this.getX(i), He.y = this.getY(i), He.z = this.getZ(i), He.transformDirection(t), this.setXYZ(i, He.x, He.y, He.z);
                    return this
                }
                set(t, e = 0) {
                    return this.array.set(t, e), this
                }
                getX(t) {
                    return this.array[t * this.itemSize]
                }
                setX(t, e) {
                    return this.array[t * this.itemSize] = e, this
                }
                getY(t) {
                    return this.array[t * this.itemSize + 1]
                }
                setY(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                }
                getZ(t) {
                    return this.array[t * this.itemSize + 2]
                }
                setZ(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                }
                getW(t) {
                    return this.array[t * this.itemSize + 3]
                }
                setW(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                }
                setXY(t, e, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = r, this
                }
                setXYZ(t, e, r, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = r, this.array[t + 2] = n, this
                }
                setXYZW(t, e, r, n, o) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = r, this.array[t + 2] = n, this.array[t + 3] = o, this
                }
                onUpload(t) {
                    return this.onUploadCallback = t, this
                }
                clone() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
                toJSON() {
                    const data = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (data.name = this.name), this.usage !== j && (data.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (data.updateRange = this.updateRange), data
                }
            }
            We.prototype.isBufferAttribute = !0;
            class je extends We {
                constructor(t, e, r) {
                    super(new Uint16Array(t), e, r)
                }
            }
            class qe extends We {
                constructor(t, e, r) {
                    super(new Uint32Array(t), e, r)
                }
            }(class extends We {
                constructor(t, e, r) {
                    super(new Uint16Array(t), e, r)
                }
            }).prototype.isFloat16BufferAttribute = !0;
            class Xe extends We {
                constructor(t, e, r) {
                    super(new Float32Array(t), e, r)
                }
            }

            function Ye(t) {
                if (0 === t.length) return -1 / 0;
                let e = t[0];
                for (let i = 1, r = t.length; i < r; ++i) t[i] > e && (e = t[i]);
                return e
            }
            Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
            let Je = 0;
            const Ze = new Jt,
                Ke = new _e,
                Qe = new vt,
                $e = new bt,
                ti = new bt,
                ei = new vt;
            class ii extends J {
                constructor() {
                    super(), Object.defineProperty(this, "id", {
                        value: Je++
                    }), this.uuid = $(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    }, this.userData = {}
                }
                getIndex() {
                    return this.index
                }
                setIndex(t) {
                    return Array.isArray(t) ? this.index = new(Ye(t) > 65535 ? qe : je)(t, 1) : this.index = t, this
                }
                getAttribute(t) {
                    return this.attributes[t]
                }
                setAttribute(t, e) {
                    return this.attributes[t] = e, this
                }
                deleteAttribute(t) {
                    return delete this.attributes[t], this
                }
                hasAttribute(t) {
                    return void 0 !== this.attributes[t]
                }
                addGroup(t, e, r = 0) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: r
                    })
                }
                clearGroups() {
                    this.groups = []
                }
                setDrawRange(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                }
                applyMatrix4(t) {
                    const e = this.attributes.position;
                    void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                    const r = this.attributes.normal;
                    if (void 0 !== r) {
                        const e = (new ot).getNormalMatrix(t);
                        r.applyNormalMatrix(e), r.needsUpdate = !0
                    }
                    const n = this.attributes.tangent;
                    return void 0 !== n && (n.transformDirection(t), n.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                }
                applyQuaternion(q) {
                    return Ze.makeRotationFromQuaternion(q), this.applyMatrix4(Ze), this
                }
                rotateX(t) {
                    return Ze.makeRotationX(t), this.applyMatrix4(Ze), this
                }
                rotateY(t) {
                    return Ze.makeRotationY(t), this.applyMatrix4(Ze), this
                }
                rotateZ(t) {
                    return Ze.makeRotationZ(t), this.applyMatrix4(Ze), this
                }
                translate(t, e, r) {
                    return Ze.makeTranslation(t, e, r), this.applyMatrix4(Ze), this
                }
                scale(t, e, r) {
                    return Ze.makeScale(t, e, r), this.applyMatrix4(Ze), this
                }
                lookAt(t) {
                    return Ke.lookAt(t), Ke.updateMatrix(), this.applyMatrix4(Ke.matrix), this
                }
                center() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(Qe).negate(), this.translate(Qe.x, Qe.y, Qe.z), this
                }
                setFromPoints(t) {
                    const e = [];
                    for (let i = 0, r = t.length; i < r; i++) {
                        const r = t[i];
                        e.push(r.x, r.y, r.z || 0)
                    }
                    return this.setAttribute("position", new Xe(e, 3)), this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new bt);
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new vt(-1 / 0, -1 / 0, -1 / 0), new vt(1 / 0, 1 / 0, 1 / 0));
                    if (void 0 !== t) {
                        if (this.boundingBox.setFromBufferAttribute(t), e)
                            for (let i = 0, t = e.length; i < t; i++) {
                                const t = e[i];
                                $e.setFromBufferAttribute(t), this.morphTargetsRelative ? (ei.addVectors(this.boundingBox.min, $e.min), this.boundingBox.expandByPoint(ei), ei.addVectors(this.boundingBox.max, $e.max), this.boundingBox.expandByPoint(ei)) : (this.boundingBox.expandByPoint($e.min), this.boundingBox.expandByPoint($e.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new Ot);
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new vt, 1 / 0);
                    if (t) {
                        const r = this.boundingSphere.center;
                        if ($e.setFromBufferAttribute(t), e)
                            for (let i = 0, t = e.length; i < t; i++) {
                                const t = e[i];
                                ti.setFromBufferAttribute(t), this.morphTargetsRelative ? (ei.addVectors($e.min, ti.min), $e.expandByPoint(ei), ei.addVectors($e.max, ti.max), $e.expandByPoint(ei)) : ($e.expandByPoint(ti.min), $e.expandByPoint(ti.max))
                            }
                        $e.getCenter(r);
                        let n = 0;
                        for (let i = 0, e = t.count; i < e; i++) ei.fromBufferAttribute(t, i), n = Math.max(n, r.distanceToSquared(ei));
                        if (e)
                            for (let i = 0, o = e.length; i < o; i++) {
                                const o = e[i],
                                    h = this.morphTargetsRelative;
                                for (let e = 0, l = o.count; e < l; e++) ei.fromBufferAttribute(o, e), h && (Qe.fromBufferAttribute(t, e), ei.add(Qe)), n = Math.max(n, r.distanceToSquared(ei))
                            }
                        this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
                computeFaceNormals() {}
                computeTangents() {
                    const t = this.index,
                        e = this.attributes;
                    if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                    const r = t.array,
                        n = e.position.array,
                        o = e.normal.array,
                        h = e.uv.array,
                        l = n.length / 3;
                    void 0 === e.tangent && this.setAttribute("tangent", new We(new Float32Array(4 * l), 4));
                    const c = e.tangent.array,
                        d = [],
                        m = [];
                    for (let i = 0; i < l; i++) d[i] = new vt, m[i] = new vt;
                    const f = new vt,
                        y = new vt,
                        v = new vt,
                        x = new at,
                        _ = new at,
                        M = new at,
                        S = new vt,
                        w = new vt;

                    function E(a, b, t) {
                        f.fromArray(n, 3 * a), y.fromArray(n, 3 * b), v.fromArray(n, 3 * t), x.fromArray(h, 2 * a), _.fromArray(h, 2 * b), M.fromArray(h, 2 * t), y.sub(f), v.sub(f), _.sub(x), M.sub(x);
                        const e = 1 / (_.x * M.y - M.x * _.y);
                        isFinite(e) && (S.copy(y).multiplyScalar(M.y).addScaledVector(v, -_.y).multiplyScalar(e), w.copy(v).multiplyScalar(_.x).addScaledVector(y, -M.x).multiplyScalar(e), d[a].add(S), d[b].add(S), d[t].add(S), m[a].add(w), m[b].add(w), m[t].add(w))
                    }
                    let T = this.groups;
                    0 === T.length && (T = [{
                        start: 0,
                        count: r.length
                    }]);
                    for (let i = 0, t = T.length; i < t; ++i) {
                        const t = T[i],
                            e = t.start;
                        for (let n = e, o = e + t.count; n < o; n += 3) E(r[n + 0], r[n + 1], r[n + 2])
                    }
                    const A = new vt,
                        P = new vt,
                        C = new vt,
                        L = new vt;

                    function D(t) {
                        C.fromArray(o, 3 * t), L.copy(C);
                        const e = d[t];
                        A.copy(e), A.sub(C.multiplyScalar(C.dot(e))).normalize(), P.crossVectors(L, e);
                        const r = P.dot(m[t]) < 0 ? -1 : 1;
                        c[4 * t] = A.x, c[4 * t + 1] = A.y, c[4 * t + 2] = A.z, c[4 * t + 3] = r
                    }
                    for (let i = 0, t = T.length; i < t; ++i) {
                        const t = T[i],
                            e = t.start;
                        for (let n = e, o = e + t.count; n < o; n += 3) D(r[n + 0]), D(r[n + 1]), D(r[n + 2])
                    }
                }
                computeVertexNormals() {
                    const t = this.index,
                        e = this.getAttribute("position");
                    if (void 0 !== e) {
                        let r = this.getAttribute("normal");
                        if (void 0 === r) r = new We(new Float32Array(3 * e.count), 3), this.setAttribute("normal", r);
                        else
                            for (let i = 0, t = r.count; i < t; i++) r.setXYZ(i, 0, 0, 0);
                        const n = new vt,
                            o = new vt,
                            h = new vt,
                            l = new vt,
                            c = new vt,
                            d = new vt,
                            m = new vt,
                            f = new vt;
                        if (t)
                            for (let i = 0, y = t.count; i < y; i += 3) {
                                const y = t.getX(i + 0),
                                    v = t.getX(i + 1),
                                    x = t.getX(i + 2);
                                n.fromBufferAttribute(e, y), o.fromBufferAttribute(e, v), h.fromBufferAttribute(e, x), m.subVectors(h, o), f.subVectors(n, o), m.cross(f), l.fromBufferAttribute(r, y), c.fromBufferAttribute(r, v), d.fromBufferAttribute(r, x), l.add(m), c.add(m), d.add(m), r.setXYZ(y, l.x, l.y, l.z), r.setXYZ(v, c.x, c.y, c.z), r.setXYZ(x, d.x, d.y, d.z)
                            } else
                                for (let i = 0, t = e.count; i < t; i += 3) n.fromBufferAttribute(e, i + 0), o.fromBufferAttribute(e, i + 1), h.fromBufferAttribute(e, i + 2), m.subVectors(h, o), f.subVectors(n, o), m.cross(f), r.setXYZ(i + 0, m.x, m.y, m.z), r.setXYZ(i + 1, m.x, m.y, m.z), r.setXYZ(i + 2, m.x, m.y, m.z);
                        this.normalizeNormals(), r.needsUpdate = !0
                    }
                }
                merge(t, e) {
                    if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                    void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    const r = this.attributes;
                    for (const n in r) {
                        if (void 0 === t.attributes[n]) continue;
                        const o = r[n].array,
                            h = t.attributes[n],
                            l = h.array,
                            c = h.itemSize * e,
                            d = Math.min(l.length, o.length - c);
                        for (let i = 0, t = c; i < d; i++, t++) o[t] = l[i]
                    }
                    return this
                }
                normalizeNormals() {
                    const t = this.attributes.normal;
                    for (let i = 0, e = t.count; i < e; i++) ei.fromBufferAttribute(t, i), ei.normalize(), t.setXYZ(i, ei.x, ei.y, ei.z)
                }
                toNonIndexed() {
                    function t(t, e) {
                        const r = t.array,
                            n = t.itemSize,
                            o = t.normalized,
                            h = new r.constructor(e.length * n);
                        let l = 0,
                            c = 0;
                        for (let i = 0, o = e.length; i < o; i++) {
                            l = t.isInterleavedBufferAttribute ? e[i] * t.data.stride + t.offset : e[i] * n;
                            for (let t = 0; t < n; t++) h[c++] = r[l++]
                        }
                        return new We(h, n, o)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                    const e = new ii,
                        r = this.index.array,
                        n = this.attributes;
                    for (const o in n) {
                        const h = t(n[o], r);
                        e.setAttribute(o, h)
                    }
                    const o = this.morphAttributes;
                    for (const n in o) {
                        const h = [],
                            l = o[n];
                        for (let i = 0, e = l.length; i < e; i++) {
                            const e = t(l[i], r);
                            h.push(e)
                        }
                        e.morphAttributes[n] = h
                    }
                    e.morphTargetsRelative = this.morphTargetsRelative;
                    const h = this.groups;
                    for (let i = 0, t = h.length; i < t; i++) {
                        const t = h[i];
                        e.addGroup(t.start, t.count, t.materialIndex)
                    }
                    return e
                }
                toJSON() {
                    const data = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), Object.keys(this.userData).length > 0 && (data.userData = this.userData), void 0 !== this.parameters) {
                        const t = this.parameters;
                        for (const e in t) void 0 !== t[e] && (data[e] = t[e]);
                        return data
                    }
                    data.data = {
                        attributes: {}
                    };
                    const t = this.index;
                    null !== t && (data.data.index = {
                        type: t.array.constructor.name,
                        array: Array.prototype.slice.call(t.array)
                    });
                    const e = this.attributes;
                    for (const t in e) {
                        const r = e[t];
                        data.data.attributes[t] = r.toJSON(data.data)
                    }
                    const r = {};
                    let n = !1;
                    for (const t in this.morphAttributes) {
                        const e = this.morphAttributes[t],
                            o = [];
                        for (let i = 0, t = e.length; i < t; i++) {
                            const t = e[i];
                            o.push(t.toJSON(data.data))
                        }
                        o.length > 0 && (r[t] = o, n = !0)
                    }
                    n && (data.data.morphAttributes = r, data.data.morphTargetsRelative = this.morphTargetsRelative);
                    const o = this.groups;
                    o.length > 0 && (data.data.groups = JSON.parse(JSON.stringify(o)));
                    const h = this.boundingSphere;
                    return null !== h && (data.data.boundingSphere = {
                        center: h.center.toArray(),
                        radius: h.radius
                    }), data
                }
                clone() {
                    return (new ii).copy(this)
                }
                copy(source) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    const data = {};
                    this.name = source.name;
                    const t = source.index;
                    null !== t && this.setIndex(t.clone(data));
                    const e = source.attributes;
                    for (const t in e) {
                        const r = e[t];
                        this.setAttribute(t, r.clone(data))
                    }
                    const r = source.morphAttributes;
                    for (const t in r) {
                        const e = [],
                            n = r[t];
                        for (let i = 0, t = n.length; i < t; i++) e.push(n[i].clone(data));
                        this.morphAttributes[t] = e
                    }
                    this.morphTargetsRelative = source.morphTargetsRelative;
                    const n = source.groups;
                    for (let i = 0, t = n.length; i < t; i++) {
                        const t = n[i];
                        this.addGroup(t.start, t.count, t.materialIndex)
                    }
                    const o = source.boundingBox;
                    null !== o && (this.boundingBox = o.clone());
                    const h = source.boundingSphere;
                    return null !== h && (this.boundingSphere = h.clone()), this.drawRange.start = source.drawRange.start, this.drawRange.count = source.drawRange.count, this.userData = source.userData, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            ii.prototype.isBufferGeometry = !0;
            const ri = new Jt,
                ni = new Yt,
                si = new Ot,
                ai = new vt,
                oi = new vt,
                hi = new vt,
                ci = new vt,
                pi = new vt,
                ui = new vt,
                di = new vt,
                mi = new vt,
                fi = new vt,
                gi = new at,
                yi = new at,
                vi = new at,
                xi = new vt,
                _i = new vt;
            class bi extends _e {
                constructor(t = new ii, e = new Ge) {
                    super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
                }
                copy(source) {
                    return super.copy(source), void 0 !== source.morphTargetInfluences && (this.morphTargetInfluences = source.morphTargetInfluences.slice()), void 0 !== source.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary)), this.material = source.material, this.geometry = source.geometry, this
                }
                updateMorphTargets() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            r = Object.keys(e);
                        if (r.length > 0) {
                            const t = e[r[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
                raycast(t, e) {
                    const r = this.geometry,
                        n = this.material,
                        o = this.matrixWorld;
                    if (void 0 === n) return;
                    if (null === r.boundingSphere && r.computeBoundingSphere(), si.copy(r.boundingSphere), si.applyMatrix4(o), !1 === t.ray.intersectsSphere(si)) return;
                    if (ri.copy(o).invert(), ni.copy(t.ray).applyMatrix4(ri), null !== r.boundingBox && !1 === ni.intersectsBox(r.boundingBox)) return;
                    let h;
                    if (r.isBufferGeometry) {
                        const o = r.index,
                            l = r.attributes.position,
                            c = r.morphAttributes.position,
                            d = r.morphTargetsRelative,
                            m = r.attributes.uv,
                            f = r.attributes.uv2,
                            y = r.groups,
                            v = r.drawRange;
                        if (null !== o)
                            if (Array.isArray(n))
                                for (let i = 0, r = y.length; i < r; i++) {
                                    const r = y[i],
                                        x = n[r.materialIndex];
                                    for (let n = Math.max(r.start, v.start), y = Math.min(r.start + r.count, v.start + v.count); n < y; n += 3) {
                                        const a = o.getX(n),
                                            b = o.getX(n + 1),
                                            y = o.getX(n + 2);
                                        h = Mi(this, x, t, ni, l, c, d, m, f, a, b, y), h && (h.faceIndex = Math.floor(n / 3), h.face.materialIndex = r.materialIndex, e.push(h))
                                    }
                                } else {
                                    for (let i = Math.max(0, v.start), r = Math.min(o.count, v.start + v.count); i < r; i += 3) {
                                        const a = o.getX(i),
                                            b = o.getX(i + 1),
                                            r = o.getX(i + 2);
                                        h = Mi(this, n, t, ni, l, c, d, m, f, a, b, r), h && (h.faceIndex = Math.floor(i / 3), e.push(h))
                                    }
                                } else if (void 0 !== l)
                                    if (Array.isArray(n))
                                        for (let i = 0, r = y.length; i < r; i++) {
                                            const r = y[i],
                                                o = n[r.materialIndex];
                                            for (let n = Math.max(r.start, v.start), y = Math.min(r.start + r.count, v.start + v.count); n < y; n += 3) {
                                                h = Mi(this, o, t, ni, l, c, d, m, f, n, n + 1, n + 2), h && (h.faceIndex = Math.floor(n / 3), h.face.materialIndex = r.materialIndex, e.push(h))
                                            }
                                        } else {
                                            for (let i = Math.max(0, v.start), r = Math.min(l.count, v.start + v.count); i < r; i += 3) {
                                                h = Mi(this, n, t, ni, l, c, d, m, f, i, i + 1, i + 2), h && (h.faceIndex = Math.floor(i / 3), e.push(h))
                                            }
                                        }
                    } else r.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            }

            function Mi(object, t, e, r, n, o, h, l, c, a, b, d) {
                ai.fromBufferAttribute(n, a), oi.fromBufferAttribute(n, b), hi.fromBufferAttribute(n, d);
                const m = object.morphTargetInfluences;
                if (t.morphTargets && o && m) {
                    di.set(0, 0, 0), mi.set(0, 0, 0), fi.set(0, 0, 0);
                    for (let i = 0, t = o.length; i < t; i++) {
                        const t = m[i],
                            e = o[i];
                        0 !== t && (ci.fromBufferAttribute(e, a), pi.fromBufferAttribute(e, b), ui.fromBufferAttribute(e, d), h ? (di.addScaledVector(ci, t), mi.addScaledVector(pi, t), fi.addScaledVector(ui, t)) : (di.addScaledVector(ci.sub(ai), t), mi.addScaledVector(pi.sub(oi), t), fi.addScaledVector(ui.sub(hi), t)))
                    }
                    ai.add(di), oi.add(mi), hi.add(fi)
                }
                object.isSkinnedMesh && (object.boneTransform(a, ai), object.boneTransform(b, oi), object.boneTransform(d, hi));
                const f = function (object, t, e, r, n, o, h, l) {
                    let c;
                    if (c = 1 === t.side ? r.intersectTriangle(h, o, n, !0, l) : r.intersectTriangle(n, o, h, 2 !== t.side, l), null === c) return null;
                    _i.copy(l), _i.applyMatrix4(object.matrixWorld);
                    const d = e.ray.origin.distanceTo(_i);
                    return d < e.near || d > e.far ? null : {
                        distance: d,
                        point: _i.clone(),
                        object: object
                    }
                }(object, t, e, r, ai, oi, hi, xi);
                if (f) {
                    l && (gi.fromBufferAttribute(l, a), yi.fromBufferAttribute(l, b), vi.fromBufferAttribute(l, d), f.uv = De.getUV(xi, ai, oi, hi, gi, yi, vi, new at)), c && (gi.fromBufferAttribute(c, a), yi.fromBufferAttribute(c, b), vi.fromBufferAttribute(c, d), f.uv2 = De.getUV(xi, ai, oi, hi, gi, yi, vi, new at));
                    const t = {
                        a: a,
                        b: b,
                        c: d,
                        normal: new vt,
                        materialIndex: 0
                    };
                    De.getNormal(ai, oi, hi, t.normal), f.face = t
                }
                return f
            }
            bi.prototype.isMesh = !0;
            class Si extends ii {
                constructor(t = 1, e = 1, r = 1, n = 1, o = 1, h = 1) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: t,
                        height: e,
                        depth: r,
                        widthSegments: n,
                        heightSegments: o,
                        depthSegments: h
                    };
                    const l = this;
                    n = Math.floor(n), o = Math.floor(o), h = Math.floor(h);
                    const c = [],
                        d = [],
                        m = [],
                        f = [];
                    let y = 0,
                        v = 0;

                    function x(u, t, e, r, n, o, h, x, _, M, S) {
                        const w = o / _,
                            E = h / M,
                            T = o / 2,
                            A = h / 2,
                            P = x / 2,
                            C = _ + 1,
                            L = M + 1;
                        let D = 0,
                            R = 0;
                        const I = new vt;
                        for (let o = 0; o < L; o++) {
                            const h = o * E - A;
                            for (let l = 0; l < C; l++) {
                                const c = l * w - T;
                                I[u] = c * r, I[t] = h * n, I[e] = P, d.push(I.x, I.y, I.z), I[u] = 0, I[t] = 0, I[e] = x > 0 ? 1 : -1, m.push(I.x, I.y, I.z), f.push(l / _), f.push(1 - o / M), D += 1
                            }
                        }
                        for (let t = 0; t < M; t++)
                            for (let e = 0; e < _; e++) {
                                const a = y + e + C * t,
                                    b = y + e + C * (t + 1),
                                    r = y + (e + 1) + C * (t + 1),
                                    n = y + (e + 1) + C * t;
                                c.push(a, b, n), c.push(b, r, n), R += 6
                            }
                        l.addGroup(v, R, S), v += R, y += D
                    }
                    x("z", "y", "x", -1, -1, r, e, t, h, o, 0), x("z", "y", "x", 1, -1, r, e, -t, h, o, 1), x("x", "z", "y", 1, 1, t, r, e, n, h, 2), x("x", "z", "y", 1, -1, t, r, -e, n, h, 3), x("x", "y", "z", 1, -1, t, e, r, n, o, 4), x("x", "y", "z", -1, -1, t, e, -r, n, o, 5), this.setIndex(c), this.setAttribute("position", new Xe(d, 3)), this.setAttribute("normal", new Xe(m, 3)), this.setAttribute("uv", new Xe(f, 2))
                }
                static fromJSON(data) {
                    return new Si(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments)
                }
            }

            function wi(t) {
                const e = {};
                for (const u in t) {
                    e[u] = {};
                    for (const p in t[u]) {
                        const r = t[u][p];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[u][p] = r.clone() : Array.isArray(r) ? e[u][p] = r.slice() : e[u][p] = r
                    }
                }
                return e
            }

            function Ei(t) {
                const e = {};
                for (let u = 0; u < t.length; u++) {
                    const r = wi(t[u]);
                    for (const p in r) e[p] = r[p]
                }
                return e
            }
            const Ti = {
                clone: wi,
                merge: Ei
            };
            class Ai extends Ie {
                constructor(t) {
                    super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                        derivatives: !1,
                        fragDepth: !1,
                        drawBuffers: !1,
                        shaderTextureLOD: !1
                    }, this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv2: [0, 0]
                    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
                }
                copy(source) {
                    return super.copy(source), this.fragmentShader = source.fragmentShader, this.vertexShader = source.vertexShader, this.uniforms = wi(source.uniforms), this.defines = Object.assign({}, source.defines), this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.lights = source.lights, this.clipping = source.clipping, this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, this.extensions = Object.assign({}, source.extensions), this.glslVersion = source.glslVersion, this
                }
                toJSON(meta) {
                    const data = super.toJSON(meta);
                    data.glslVersion = this.glslVersion, data.uniforms = {};
                    for (const t in this.uniforms) {
                        const e = this.uniforms[t].value;
                        e && e.isTexture ? data.uniforms[t] = {
                            type: "t",
                            value: e.toJSON(meta).uuid
                        } : e && e.isColor ? data.uniforms[t] = {
                            type: "c",
                            value: e.getHex()
                        } : e && e.isVector2 ? data.uniforms[t] = {
                            type: "v2",
                            value: e.toArray()
                        } : e && e.isVector3 ? data.uniforms[t] = {
                            type: "v3",
                            value: e.toArray()
                        } : e && e.isVector4 ? data.uniforms[t] = {
                            type: "v4",
                            value: e.toArray()
                        } : e && e.isMatrix3 ? data.uniforms[t] = {
                            type: "m3",
                            value: e.toArray()
                        } : e && e.isMatrix4 ? data.uniforms[t] = {
                            type: "m4",
                            value: e.toArray()
                        } : data.uniforms[t] = {
                            value: e
                        }
                    }
                    Object.keys(this.defines).length > 0 && (data.defines = this.defines), data.vertexShader = this.vertexShader, data.fragmentShader = this.fragmentShader;
                    const t = {};
                    for (const e in this.extensions) !0 === this.extensions[e] && (t[e] = !0);
                    return Object.keys(t).length > 0 && (data.extensions = t), data
                }
            }
            Ai.prototype.isShaderMaterial = !0;
            class Pi extends _e {
                constructor() {
                    super(), this.type = "Camera", this.matrixWorldInverse = new Jt, this.projectionMatrix = new Jt, this.projectionMatrixInverse = new Jt
                }
                copy(source, t) {
                    return super.copy(source, t), this.matrixWorldInverse.copy(source.matrixWorldInverse), this.projectionMatrix.copy(source.projectionMatrix), this.projectionMatrixInverse.copy(source.projectionMatrixInverse), this
                }
                getWorldDirection(t) {
                    this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                }
                updateMatrixWorld(t) {
                    super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                updateWorldMatrix(t, e) {
                    super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            Pi.prototype.isCamera = !0;
            class Ci extends Pi {
                constructor(t = 50, e = 1, r = .1, n = 2e3) {
                    super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = r, this.far = n, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
                }
                copy(source, t) {
                    return super.copy(source, t), this.fov = source.fov, this.zoom = source.zoom, this.near = source.near, this.far = source.far, this.focus = source.focus, this.aspect = source.aspect, this.view = null === source.view ? null : Object.assign({}, source.view), this.filmGauge = source.filmGauge, this.filmOffset = source.filmOffset, this
                }
                setFocalLength(t) {
                    const e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * Q * Math.atan(e), this.updateProjectionMatrix()
                }
                getFocalLength() {
                    const t = Math.tan(.5 * K * this.fov);
                    return .5 * this.getFilmHeight() / t
                }
                getEffectiveFOV() {
                    return 2 * Q * Math.atan(Math.tan(.5 * K * this.fov) / this.zoom)
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                }
                setViewOffset(t, e, r, n, o, h) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = r, this.view.offsetY = n, this.view.width = o, this.view.height = h, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const t = this.near;
                    let e = t * Math.tan(.5 * K * this.fov) / this.zoom,
                        r = 2 * e,
                        n = this.aspect * r,
                        o = -.5 * n;
                    const view = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const t = view.fullWidth,
                            h = view.fullHeight;
                        o += view.offsetX * n / t, e -= view.offsetY * r / h, n *= view.width / t, r *= view.height / h
                    }
                    const h = this.filmOffset;
                    0 !== h && (o += t * h / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + n, e, e - r, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(meta) {
                    const data = super.toJSON(meta);
                    return data.object.fov = this.fov, data.object.zoom = this.zoom, data.object.near = this.near, data.object.far = this.far, data.object.focus = this.focus, data.object.aspect = this.aspect, null !== this.view && (data.object.view = Object.assign({}, this.view)), data.object.filmGauge = this.filmGauge, data.object.filmOffset = this.filmOffset, data
                }
            }
            Ci.prototype.isPerspectiveCamera = !0;
            const Li = 90;
            class Di extends _e {
                constructor(t, e, r) {
                    if (super(), this.type = "CubeCamera", !0 !== r.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                    this.renderTarget = r;
                    const n = new Ci(Li, 1, t, e);
                    n.layers = this.layers, n.up.set(0, -1, 0), n.lookAt(new vt(1, 0, 0)), this.add(n);
                    const o = new Ci(Li, 1, t, e);
                    o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new vt(-1, 0, 0)), this.add(o);
                    const h = new Ci(Li, 1, t, e);
                    h.layers = this.layers, h.up.set(0, 0, 1), h.lookAt(new vt(0, 1, 0)), this.add(h);
                    const l = new Ci(Li, 1, t, e);
                    l.layers = this.layers, l.up.set(0, 0, -1), l.lookAt(new vt(0, -1, 0)), this.add(l);
                    const c = new Ci(Li, 1, t, e);
                    c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new vt(0, 0, 1)), this.add(c);
                    const d = new Ci(Li, 1, t, e);
                    d.layers = this.layers, d.up.set(0, -1, 0), d.lookAt(new vt(0, 0, -1)), this.add(d)
                }
                update(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    const r = this.renderTarget,
                        [n, o, h, l, c, d] = this.children,
                        m = t.xr.enabled,
                        f = t.getRenderTarget();
                    t.xr.enabled = !1;
                    const y = r.texture.generateMipmaps;
                    r.texture.generateMipmaps = !1, t.setRenderTarget(r, 0), t.render(e, n), t.setRenderTarget(r, 1), t.render(e, o), t.setRenderTarget(r, 2), t.render(e, h), t.setRenderTarget(r, 3), t.render(e, l), t.setRenderTarget(r, 4), t.render(e, c), r.texture.generateMipmaps = y, t.setRenderTarget(r, 5), t.render(e, d), t.setRenderTarget(f), t.xr.enabled = m
                }
            }
            class Ri extends pt {
                constructor(t, e, r, n, h, l, c, d, m, f) {
                    super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : o, r, n, h, l, c = void 0 !== c ? c : C, d, m, f), this._needsFlipEnvMap = !0, this.flipY = !1
                }
                get images() {
                    return this.image
                }
                set images(t) {
                    this.image = t
                }
            }
            Ri.prototype.isCubeTexture = !0;
            class Ii extends ft {
                constructor(t, e, r) {
                    Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = r), super(t, t, e), e = e || {}, this.texture = new Ri(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : _, this.texture._needsFlipEnvMap = !1
                }
                fromEquirectangularTexture(t, e) {
                    this.texture.type = e.type, this.texture.format = L, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                    const r = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                            fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                        },
                        n = new Si(5, 5, 5),
                        o = new Ai({
                            name: "CubemapFromEquirect",
                            uniforms: wi(r.uniforms),
                            vertexShader: r.vertexShader,
                            fragmentShader: r.fragmentShader,
                            side: 1,
                            blending: 0
                        });
                    o.uniforms.tEquirect.value = e;
                    const h = new bi(n, o),
                        l = e.minFilter;
                    e.minFilter === M && (e.minFilter = _);
                    return new Di(1, 10, this).update(t, h), e.minFilter = l, h.geometry.dispose(), h.material.dispose(), this
                }
                clear(t, e, r, n) {
                    const o = t.getRenderTarget();
                    for (let i = 0; i < 6; i++) t.setRenderTarget(this, i), t.clear(e, r, n);
                    t.setRenderTarget(o)
                }
            }
            Ii.prototype.isWebGLCubeRenderTarget = !0;
            const Fi = new vt,
                ki = new vt,
                Ni = new ot;
            class Bi {
                constructor(t = new vt(1, 0, 0), e = 0) {
                    this.normal = t, this.constant = e
                }
                set(t, e) {
                    return this.normal.copy(t), this.constant = e, this
                }
                setComponents(t, e, r, n) {
                    return this.normal.set(t, e, r), this.constant = n, this
                }
                setFromNormalAndCoplanarPoint(t, e) {
                    return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                }
                setFromCoplanarPoints(a, b, t) {
                    const e = Fi.subVectors(t, b).cross(ki.subVectors(a, b)).normalize();
                    return this.setFromNormalAndCoplanarPoint(e, a), this
                }
                copy(t) {
                    return this.normal.copy(t.normal), this.constant = t.constant, this
                }
                normalize() {
                    const t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), this.constant *= t, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(t) {
                    return this.normal.dot(t) + this.constant
                }
                distanceToSphere(t) {
                    return this.distanceToPoint(t.center) - t.radius
                }
                projectPoint(t, e) {
                    return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                }
                intersectLine(line, t) {
                    const e = line.delta(Fi),
                        r = this.normal.dot(e);
                    if (0 === r) return 0 === this.distanceToPoint(line.start) ? t.copy(line.start) : null;
                    const n = -(line.start.dot(this.normal) + this.constant) / r;
                    return n < 0 || n > 1 ? null : t.copy(e).multiplyScalar(n).add(line.start)
                }
                intersectsLine(line) {
                    const t = this.distanceToPoint(line.start),
                        e = this.distanceToPoint(line.end);
                    return t < 0 && e > 0 || e < 0 && t > 0
                }
                intersectsBox(t) {
                    return t.intersectsPlane(this)
                }
                intersectsSphere(t) {
                    return t.intersectsPlane(this)
                }
                coplanarPoint(t) {
                    return t.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(t, e) {
                    const r = e || Ni.getNormalMatrix(t),
                        n = this.coplanarPoint(Fi).applyMatrix4(t),
                        o = this.normal.applyMatrix3(r).normalize();
                    return this.constant = -n.dot(o), this
                }
                translate(t) {
                    return this.constant -= t.dot(this.normal), this
                }
                equals(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            Bi.prototype.isPlane = !0;
            const zi = new Ot,
                Vi = new vt;
            class Oi {
                constructor(t = new Bi, e = new Bi, r = new Bi, n = new Bi, o = new Bi, h = new Bi) {
                    this.planes = [t, e, r, n, o, h]
                }
                set(t, e, r, n, o, h) {
                    const l = this.planes;
                    return l[0].copy(t), l[1].copy(e), l[2].copy(r), l[3].copy(n), l[4].copy(o), l[5].copy(h), this
                }
                copy(t) {
                    const e = this.planes;
                    for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                    return this
                }
                setFromProjectionMatrix(t) {
                    const e = this.planes,
                        r = t.elements,
                        n = r[0],
                        o = r[1],
                        h = r[2],
                        l = r[3],
                        c = r[4],
                        d = r[5],
                        m = r[6],
                        f = r[7],
                        y = r[8],
                        v = r[9],
                        x = r[10],
                        _ = r[11],
                        M = r[12],
                        S = r[13],
                        w = r[14],
                        E = r[15];
                    return e[0].setComponents(l - n, f - c, _ - y, E - M).normalize(), e[1].setComponents(l + n, f + c, _ + y, E + M).normalize(), e[2].setComponents(l + o, f + d, _ + v, E + S).normalize(), e[3].setComponents(l - o, f - d, _ - v, E - S).normalize(), e[4].setComponents(l - h, f - m, _ - x, E - w).normalize(), e[5].setComponents(l + h, f + m, _ + x, E + w).normalize(), this
                }
                intersectsObject(object) {
                    const t = object.geometry;
                    return null === t.boundingSphere && t.computeBoundingSphere(), zi.copy(t.boundingSphere).applyMatrix4(object.matrixWorld), this.intersectsSphere(zi)
                }
                intersectsSprite(t) {
                    return zi.center.set(0, 0, 0), zi.radius = .7071067811865476, zi.applyMatrix4(t.matrixWorld), this.intersectsSphere(zi)
                }
                intersectsSphere(t) {
                    const e = this.planes,
                        r = t.center,
                        n = -t.radius;
                    for (let i = 0; i < 6; i++) {
                        if (e[i].distanceToPoint(r) < n) return !1
                    }
                    return !0
                }
                intersectsBox(t) {
                    const e = this.planes;
                    for (let i = 0; i < 6; i++) {
                        const r = e[i];
                        if (Vi.x = r.normal.x > 0 ? t.max.x : t.min.x, Vi.y = r.normal.y > 0 ? t.max.y : t.min.y, Vi.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(Vi) < 0) return !1
                    }
                    return !0
                }
                containsPoint(t) {
                    const e = this.planes;
                    for (let i = 0; i < 6; i++)
                        if (e[i].distanceToPoint(t) < 0) return !1;
                    return !0
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }

            function Gi() {
                let t = null,
                    e = !1,
                    r = null,
                    n = null;

                function o(time, e) {
                    r(time, e), n = t.requestAnimationFrame(o)
                }
                return {
                    start: function () {
                        !0 !== e && null !== r && (n = t.requestAnimationFrame(o), e = !0)
                    },
                    stop: function () {
                        t.cancelAnimationFrame(n), e = !1
                    },
                    setAnimationLoop: function (t) {
                        r = t
                    },
                    setContext: function (e) {
                        t = e
                    }
                }
            }

            function Hi(t, e) {
                const r = e.isWebGL2,
                    n = new WeakMap;
                return {
                    get: function (t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), n.get(t)
                    },
                    remove: function (e) {
                        e.isInterleavedBufferAttribute && (e = e.data);
                        const data = n.get(e);
                        data && (t.deleteBuffer(data.buffer), n.delete(e))
                    },
                    update: function (e, o) {
                        if (e.isGLBufferAttribute) {
                            const t = n.get(e);
                            return void((!t || t.version < e.version) && n.set(e, {
                                buffer: e.buffer,
                                type: e.type,
                                bytesPerElement: e.elementSize,
                                version: e.version
                            }))
                        }
                        e.isInterleavedBufferAttribute && (e = e.data);
                        const data = n.get(e);
                        void 0 === data ? n.set(e, function (e, n) {
                            const o = e.array,
                                h = e.usage,
                                l = t.createBuffer();
                            t.bindBuffer(n, l), t.bufferData(n, o, h), e.onUploadCallback();
                            let c = 5126;
                            return o instanceof Float32Array ? c = 5126 : o instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : o instanceof Uint16Array ? e.isFloat16BufferAttribute ? r ? c = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : c = 5123 : o instanceof Int16Array ? c = 5122 : o instanceof Uint32Array ? c = 5125 : o instanceof Int32Array ? c = 5124 : o instanceof Int8Array ? c = 5120 : (o instanceof Uint8Array || o instanceof Uint8ClampedArray) && (c = 5121), {
                                buffer: l,
                                type: c,
                                bytesPerElement: o.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(e, o)) : data.version < e.version && (! function (e, n, o) {
                            const h = n.array,
                                l = n.updateRange;
                            t.bindBuffer(o, e), -1 === l.count ? t.bufferSubData(o, 0, h) : (r ? t.bufferSubData(o, l.offset * h.BYTES_PER_ELEMENT, h, l.offset, l.count) : t.bufferSubData(o, l.offset * h.BYTES_PER_ELEMENT, h.subarray(l.offset, l.offset + l.count)), l.count = -1)
                        }(data.buffer, e, o), data.version = e.version)
                    }
                }
            }
            class Ui extends ii {
                constructor(t = 1, e = 1, r = 1, n = 1) {
                    super(), this.type = "PlaneGeometry", this.parameters = {
                        width: t,
                        height: e,
                        widthSegments: r,
                        heightSegments: n
                    };
                    const o = t / 2,
                        h = e / 2,
                        l = Math.floor(r),
                        c = Math.floor(n),
                        d = l + 1,
                        m = c + 1,
                        f = t / l,
                        y = e / c,
                        v = [],
                        x = [],
                        _ = [],
                        M = [];
                    for (let t = 0; t < m; t++) {
                        const e = t * y - h;
                        for (let r = 0; r < d; r++) {
                            const n = r * f - o;
                            x.push(n, -e, 0), _.push(0, 0, 1), M.push(r / l), M.push(1 - t / c)
                        }
                    }
                    for (let t = 0; t < c; t++)
                        for (let e = 0; e < l; e++) {
                            const a = e + d * t,
                                b = e + d * (t + 1),
                                r = e + 1 + d * (t + 1),
                                n = e + 1 + d * t;
                            v.push(a, b, n), v.push(b, r, n)
                        }
                    this.setIndex(v), this.setAttribute("position", new Xe(x, 3)), this.setAttribute("normal", new Xe(_, 3)), this.setAttribute("uv", new Xe(M, 2))
                }
                static fromJSON(data) {
                    return new Ui(data.width, data.height, data.widthSegments, data.heightSegments)
                }
            }
            const Wi = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSNMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tnormal, v, roughnessFactor, material.diffuseColor, totalSpecular,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif",
                    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform vec3 attenuationColor;\n\tuniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}",
                    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
                },
                ji = {
                    common: {
                        diffuse: {
                            value: new Oe(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new ot
                        },
                        uv2Transform: {
                            value: new ot
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new at(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new Oe(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new Oe(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new ot
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new Oe(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new at(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new ot
                        }
                    }
                },
                qi = {
                    basic: {
                        uniforms: Ei([ji.common, ji.specularmap, ji.envmap, ji.aomap, ji.lightmap, ji.fog]),
                        vertexShader: Wi.meshbasic_vert,
                        fragmentShader: Wi.meshbasic_frag
                    },
                    lambert: {
                        uniforms: Ei([ji.common, ji.specularmap, ji.envmap, ji.aomap, ji.lightmap, ji.emissivemap, ji.fog, ji.lights, {
                            emissive: {
                                value: new Oe(0)
                            }
                        }]),
                        vertexShader: Wi.meshlambert_vert,
                        fragmentShader: Wi.meshlambert_frag
                    },
                    phong: {
                        uniforms: Ei([ji.common, ji.specularmap, ji.envmap, ji.aomap, ji.lightmap, ji.emissivemap, ji.bumpmap, ji.normalmap, ji.displacementmap, ji.fog, ji.lights, {
                            emissive: {
                                value: new Oe(0)
                            },
                            specular: {
                                value: new Oe(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: Wi.meshphong_vert,
                        fragmentShader: Wi.meshphong_frag
                    },
                    standard: {
                        uniforms: Ei([ji.common, ji.envmap, ji.aomap, ji.lightmap, ji.emissivemap, ji.bumpmap, ji.normalmap, ji.displacementmap, ji.roughnessmap, ji.metalnessmap, ji.fog, ji.lights, {
                            emissive: {
                                value: new Oe(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Wi.meshphysical_vert,
                        fragmentShader: Wi.meshphysical_frag
                    },
                    toon: {
                        uniforms: Ei([ji.common, ji.aomap, ji.lightmap, ji.emissivemap, ji.bumpmap, ji.normalmap, ji.displacementmap, ji.gradientmap, ji.fog, ji.lights, {
                            emissive: {
                                value: new Oe(0)
                            }
                        }]),
                        vertexShader: Wi.meshtoon_vert,
                        fragmentShader: Wi.meshtoon_frag
                    },
                    matcap: {
                        uniforms: Ei([ji.common, ji.bumpmap, ji.normalmap, ji.displacementmap, ji.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: Wi.meshmatcap_vert,
                        fragmentShader: Wi.meshmatcap_frag
                    },
                    points: {
                        uniforms: Ei([ji.points, ji.fog]),
                        vertexShader: Wi.points_vert,
                        fragmentShader: Wi.points_frag
                    },
                    dashed: {
                        uniforms: Ei([ji.common, ji.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: Wi.linedashed_vert,
                        fragmentShader: Wi.linedashed_frag
                    },
                    depth: {
                        uniforms: Ei([ji.common, ji.displacementmap]),
                        vertexShader: Wi.depth_vert,
                        fragmentShader: Wi.depth_frag
                    },
                    normal: {
                        uniforms: Ei([ji.common, ji.bumpmap, ji.normalmap, ji.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Wi.normal_vert,
                        fragmentShader: Wi.normal_frag
                    },
                    sprite: {
                        uniforms: Ei([ji.sprite, ji.fog]),
                        vertexShader: Wi.sprite_vert,
                        fragmentShader: Wi.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new ot
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: Wi.background_vert,
                        fragmentShader: Wi.background_frag
                    },
                    cube: {
                        uniforms: Ei([ji.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Wi.cube_vert,
                        fragmentShader: Wi.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: Wi.equirect_vert,
                        fragmentShader: Wi.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: Ei([ji.common, ji.displacementmap, {
                            referencePosition: {
                                value: new vt
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: Wi.distanceRGBA_vert,
                        fragmentShader: Wi.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: Ei([ji.lights, ji.fog, {
                            color: {
                                value: new Oe(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Wi.shadow_vert,
                        fragmentShader: Wi.shadow_frag
                    }
                };

            function Xi(t, e, r, n, o) {
                const h = new Oe(0);
                let c, d, m = 0,
                    f = null,
                    y = 0,
                    v = null;

                function x(t, e) {
                    r.buffers.color.setClear(t.r, t.g, t.b, e, o)
                }
                return {
                    getClearColor: function () {
                        return h
                    },
                    setClearColor: function (t, e = 1) {
                        h.set(t), m = e, x(h, m)
                    },
                    getClearAlpha: function () {
                        return m
                    },
                    setClearAlpha: function (t) {
                        m = t, x(h, m)
                    },
                    render: function (r, o) {
                        let _ = !1,
                            M = !0 === o.isScene ? o.background : null;
                        M && M.isTexture && (M = e.get(M));
                        const S = t.xr,
                            w = S.getSession && S.getSession();
                        w && "additive" === w.environmentBlendMode && (M = null), null === M ? x(h, m) : M && M.isColor && (x(M, 1), _ = !0), (t.autoClear || _) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), M && (M.isCubeTexture || M.mapping === l) ? (void 0 === d && (d = new bi(new Si(1, 1, 1), new Ai({
                            name: "BackgroundCubeMaterial",
                            uniforms: wi(qi.cube.uniforms),
                            vertexShader: qi.cube.vertexShader,
                            fragmentShader: qi.cube.fragmentShader,
                            side: 1,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), d.geometry.deleteAttribute("normal"), d.geometry.deleteAttribute("uv"), d.onBeforeRender = function (t, e, r) {
                            this.matrixWorld.copyPosition(r.matrixWorld)
                        }, Object.defineProperty(d.material, "envMap", {
                            get: function () {
                                return this.uniforms.envMap.value
                            }
                        }), n.update(d)), d.material.uniforms.envMap.value = M, d.material.uniforms.flipEnvMap.value = M.isCubeTexture && M._needsFlipEnvMap ? -1 : 1, f === M && y === M.version && v === t.toneMapping || (d.material.needsUpdate = !0, f = M, y = M.version, v = t.toneMapping), r.unshift(d, d.geometry, d.material, 0, 0, null)) : M && M.isTexture && (void 0 === c && (c = new bi(new Ui(2, 2), new Ai({
                            name: "BackgroundMaterial",
                            uniforms: wi(qi.background.uniforms),
                            vertexShader: qi.background.vertexShader,
                            fragmentShader: qi.background.fragmentShader,
                            side: 0,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
                            get: function () {
                                return this.uniforms.t2D.value
                            }
                        }), n.update(c)), c.material.uniforms.t2D.value = M, !0 === M.matrixAutoUpdate && M.updateMatrix(), c.material.uniforms.uvTransform.value.copy(M.matrix), f === M && y === M.version && v === t.toneMapping || (c.material.needsUpdate = !0, f = M, y = M.version, v = t.toneMapping), r.unshift(c, c.geometry, c.material, 0, 0, null))
                    }
                }
            }

            function Yi(t, e, r, n) {
                const o = t.getParameter(34921),
                    h = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                    l = n.isWebGL2 || null !== h,
                    c = {},
                    d = v(null);
                let m = d;

                function f(e) {
                    return n.isWebGL2 ? t.bindVertexArray(e) : h.bindVertexArrayOES(e)
                }

                function y(e) {
                    return n.isWebGL2 ? t.deleteVertexArray(e) : h.deleteVertexArrayOES(e)
                }

                function v(t) {
                    const e = [],
                        r = [],
                        n = [];
                    for (let i = 0; i < o; i++) e[i] = 0, r[i] = 0, n[i] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: e,
                        enabledAttributes: r,
                        attributeDivisors: n,
                        object: t,
                        attributes: {},
                        index: null
                    }
                }

                function x() {
                    const t = m.newAttributes;
                    for (let i = 0, e = t.length; i < e; i++) t[i] = 0
                }

                function _(t) {
                    M(t, 0)
                }

                function M(r, o) {
                    const h = m.newAttributes,
                        l = m.enabledAttributes,
                        c = m.attributeDivisors;
                    if (h[r] = 1, 0 === l[r] && (t.enableVertexAttribArray(r), l[r] = 1), c[r] !== o) {
                        (n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](r, o), c[r] = o
                    }
                }

                function S() {
                    const e = m.newAttributes,
                        r = m.enabledAttributes;
                    for (let i = 0, n = r.length; i < n; i++) r[i] !== e[i] && (t.disableVertexAttribArray(i), r[i] = 0)
                }

                function w(e, r, o, h, l, c) {
                    !0 !== n.isWebGL2 || 5124 !== o && 5125 !== o ? t.vertexAttribPointer(e, r, o, h, l, c) : t.vertexAttribIPointer(e, r, o, l, c)
                }

                function E() {
                    T(), m !== d && (m = d, f(m.object))
                }

                function T() {
                    d.geometry = null, d.program = null, d.wireframe = !1
                }
                return {
                    setup: function (object, o, d, y, E) {
                        let T = !1;
                        if (l) {
                            const e = function (e, r, o) {
                                const l = !0 === o.wireframe;
                                let d = c[e.id];
                                void 0 === d && (d = {}, c[e.id] = d);
                                let m = d[r.id];
                                void 0 === m && (m = {}, d[r.id] = m);
                                let f = m[l];
                                void 0 === f && (f = v(n.isWebGL2 ? t.createVertexArray() : h.createVertexArrayOES()), m[l] = f);
                                return f
                            }(y, d, o);
                            m !== e && (m = e, f(m.object)), T = function (t, e) {
                                const r = m.attributes,
                                    n = t.attributes;
                                let o = 0;
                                for (const t in n) {
                                    const e = r[t],
                                        h = n[t];
                                    if (void 0 === e) return !0;
                                    if (e.attribute !== h) return !0;
                                    if (e.data !== h.data) return !0;
                                    o++
                                }
                                return m.attributesNum !== o || m.index !== e
                            }(y, E), T && function (t, e) {
                                const r = {},
                                    n = t.attributes;
                                let o = 0;
                                for (const t in n) {
                                    const e = n[t],
                                        data = {};
                                    data.attribute = e, e.data && (data.data = e.data), r[t] = data, o++
                                }
                                m.attributes = r, m.attributesNum = o, m.index = e
                            }(y, E)
                        } else {
                            const t = !0 === o.wireframe;
                            m.geometry === y.id && m.program === d.id && m.wireframe === t || (m.geometry = y.id, m.program = d.id, m.wireframe = t, T = !0)
                        }!0 === object.isInstancedMesh && (T = !0), null !== E && r.update(E, 34963), T && (! function (object, o, h, l) {
                            if (!1 === n.isWebGL2 && (object.isInstancedMesh || l.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                            x();
                            const c = l.attributes,
                                d = h.getAttributes(),
                                m = o.defaultAttributeValues;
                            for (const e in d) {
                                const n = d[e];
                                if (n >= 0) {
                                    const o = c[e];
                                    if (void 0 !== o) {
                                        const e = o.normalized,
                                            h = o.itemSize,
                                            c = r.get(o);
                                        if (void 0 === c) continue;
                                        const d = c.buffer,
                                            m = c.type,
                                            f = c.bytesPerElement;
                                        if (o.isInterleavedBufferAttribute) {
                                            const data = o.data,
                                                r = data.stride,
                                                c = o.offset;
                                            data && data.isInstancedInterleavedBuffer ? (M(n, data.meshPerAttribute), void 0 === l._maxInstanceCount && (l._maxInstanceCount = data.meshPerAttribute * data.count)) : _(n), t.bindBuffer(34962, d), w(n, h, m, e, r * f, c * f)
                                        } else o.isInstancedBufferAttribute ? (M(n, o.meshPerAttribute), void 0 === l._maxInstanceCount && (l._maxInstanceCount = o.meshPerAttribute * o.count)) : _(n), t.bindBuffer(34962, d), w(n, h, m, e, 0, 0)
                                    } else if ("instanceMatrix" === e) {
                                        const e = r.get(object.instanceMatrix);
                                        if (void 0 === e) continue;
                                        const o = e.buffer,
                                            h = e.type;
                                        M(n + 0, 1), M(n + 1, 1), M(n + 2, 1), M(n + 3, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(n + 0, 4, h, !1, 64, 0), t.vertexAttribPointer(n + 1, 4, h, !1, 64, 16), t.vertexAttribPointer(n + 2, 4, h, !1, 64, 32), t.vertexAttribPointer(n + 3, 4, h, !1, 64, 48)
                                    } else if ("instanceColor" === e) {
                                        const e = r.get(object.instanceColor);
                                        if (void 0 === e) continue;
                                        const o = e.buffer,
                                            h = e.type;
                                        M(n, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(n, 3, h, !1, 12, 0)
                                    } else if (void 0 !== m) {
                                        const r = m[e];
                                        if (void 0 !== r) switch (r.length) {
                                            case 2:
                                                t.vertexAttrib2fv(n, r);
                                                break;
                                            case 3:
                                                t.vertexAttrib3fv(n, r);
                                                break;
                                            case 4:
                                                t.vertexAttrib4fv(n, r);
                                                break;
                                            default:
                                                t.vertexAttrib1fv(n, r)
                                        }
                                    }
                                }
                            }
                            S()
                        }(object, o, d, y), null !== E && t.bindBuffer(34963, r.get(E).buffer))
                    },
                    reset: E,
                    resetDefaultState: T,
                    dispose: function () {
                        E();
                        for (const t in c) {
                            const e = c[t];
                            for (const t in e) {
                                const r = e[t];
                                for (const t in r) y(r[t].object), delete r[t];
                                delete e[t]
                            }
                            delete c[t]
                        }
                    },
                    releaseStatesOfGeometry: function (t) {
                        if (void 0 === c[t.id]) return;
                        const e = c[t.id];
                        for (const t in e) {
                            const r = e[t];
                            for (const t in r) y(r[t].object), delete r[t];
                            delete e[t]
                        }
                        delete c[t.id]
                    },
                    releaseStatesOfProgram: function (t) {
                        for (const e in c) {
                            const r = c[e];
                            if (void 0 === r[t.id]) continue;
                            const n = r[t.id];
                            for (const t in n) y(n[t].object), delete n[t];
                            delete r[t.id]
                        }
                    },
                    initAttributes: x,
                    enableAttribute: _,
                    disableUnusedAttributes: S
                }
            }

            function Ji(t, e, r, n) {
                const o = n.isWebGL2;
                let h;
                this.setMode = function (t) {
                    h = t
                }, this.render = function (e, n) {
                    t.drawArrays(h, e, n), r.update(n, h, 1)
                }, this.renderInstances = function (n, l, c) {
                    if (0 === c) return;
                    let d, m;
                    if (o) d = t, m = "drawArraysInstanced";
                    else if (d = e.get("ANGLE_instanced_arrays"), m = "drawArraysInstancedANGLE", null === d) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    d[m](h, n, l, c), r.update(l, h, c)
                }
            }

            function Zi(t, e, r) {
                let n;

                function o(e) {
                    if ("highp" === e) {
                        if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                const h = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
                let l = void 0 !== r.precision ? r.precision : "highp";
                const c = o(l);
                c !== l && (console.warn("THREE.WebGLRenderer:", l, "not supported, using", c, "instead."), l = c);
                const d = h || e.has("WEBGL_draw_buffers"),
                    m = !0 === r.logarithmicDepthBuffer,
                    f = t.getParameter(34930),
                    y = t.getParameter(35660),
                    v = t.getParameter(3379),
                    x = t.getParameter(34076),
                    _ = t.getParameter(34921),
                    M = t.getParameter(36347),
                    S = t.getParameter(36348),
                    w = t.getParameter(36349),
                    E = y > 0,
                    T = h || e.has("OES_texture_float");
                return {
                    isWebGL2: h,
                    drawBuffers: d,
                    getMaxAnisotropy: function () {
                        if (void 0 !== n) return n;
                        if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                            const r = e.get("EXT_texture_filter_anisotropic");
                            n = t.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else n = 0;
                        return n
                    },
                    getMaxPrecision: o,
                    precision: l,
                    logarithmicDepthBuffer: m,
                    maxTextures: f,
                    maxVertexTextures: y,
                    maxTextureSize: v,
                    maxCubemapSize: x,
                    maxAttributes: _,
                    maxVertexUniforms: M,
                    maxVaryings: S,
                    maxFragmentUniforms: w,
                    vertexTextures: E,
                    floatFragmentTextures: T,
                    floatVertexTextures: E && T,
                    maxSamples: h ? t.getParameter(36183) : 0
                }
            }

            function Ki(t) {
                const e = this;
                let r = null,
                    n = 0,
                    o = !1,
                    h = !1;
                const l = new Bi,
                    c = new ot,
                    d = {
                        value: null,
                        needsUpdate: !1
                    };

                function m() {
                    d.value !== r && (d.value = r, d.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0
                }

                function f(t, r, n, o) {
                    const h = null !== t ? t.length : 0;
                    let m = null;
                    if (0 !== h) {
                        if (m = d.value, !0 !== o || null === m) {
                            const e = n + 4 * h,
                                o = r.matrixWorldInverse;
                            c.getNormalMatrix(o), (null === m || m.length < e) && (m = new Float32Array(e));
                            for (let i = 0, e = n; i !== h; ++i, e += 4) l.copy(t[i]).applyMatrix4(o, c), l.normal.toArray(m, e), m[e + 3] = l.constant
                        }
                        d.value = m, d.needsUpdate = !0
                    }
                    return e.numPlanes = h, e.numIntersection = 0, m
                }
                this.uniform = d, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, h) {
                    const l = 0 !== t.length || e || 0 !== n || o;
                    return o = e, r = f(t, h, 0), n = t.length, l
                }, this.beginShadows = function () {
                    h = !0, f(null)
                }, this.endShadows = function () {
                    h = !1, m()
                }, this.setState = function (e, l, c) {
                    const y = e.clippingPlanes,
                        v = e.clipIntersection,
                        x = e.clipShadows,
                        _ = t.get(e);
                    if (!o || null === y || 0 === y.length || h && !x) h ? f(null) : m();
                    else {
                        const t = h ? 0 : n,
                            e = 4 * t;
                        let o = _.clippingState || null;
                        d.value = o, o = f(y, l, e, c);
                        for (let i = 0; i !== e; ++i) o[i] = r[i];
                        _.clippingState = o, this.numIntersection = v ? this.numPlanes : 0, this.numPlanes += t
                    }
                }
            }

            function Qi(t) {
                let e = new WeakMap;

                function r(t, e) {
                    return 303 === e ? t.mapping = o : 304 === e && (t.mapping = h), t
                }

                function n(t) {
                    const r = t.target;
                    r.removeEventListener("dispose", n);
                    const o = e.get(r);
                    void 0 !== o && (e.delete(r), o.dispose())
                }
                return {
                    get: function (o) {
                        if (o && o.isTexture) {
                            const h = o.mapping;
                            if (303 === h || 304 === h) {
                                if (e.has(o)) {
                                    return r(e.get(o).texture, o.mapping)
                                } {
                                    const image = o.image;
                                    if (image && image.height > 0) {
                                        const h = t.getRenderTarget(),
                                            l = new Ii(image.height / 2);
                                        return l.fromEquirectangularTexture(t, o), e.set(o, l), t.setRenderTarget(h), o.addEventListener("dispose", n), r(l.texture, o.mapping)
                                    }
                                    return null
                                }
                            }
                        }
                        return o
                    },
                    dispose: function () {
                        e = new WeakMap
                    }
                }
            }

            function $i(t) {
                const e = {};

                function r(r) {
                    if (void 0 !== e[r]) return e[r];
                    let n;
                    switch (r) {
                        case "WEBGL_depth_texture":
                            n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            n = t.getExtension(r)
                    }
                    return e[r] = n, n
                }
                return {
                    has: function (t) {
                        return null !== r(t)
                    },
                    init: function (t) {
                        t.isWebGL2 ? r("EXT_color_buffer_float") : (r("WEBGL_depth_texture"), r("OES_texture_float"), r("OES_texture_half_float"), r("OES_texture_half_float_linear"), r("OES_standard_derivatives"), r("OES_element_index_uint"), r("OES_vertex_array_object"), r("ANGLE_instanced_arrays")), r("OES_texture_float_linear"), r("EXT_color_buffer_half_float")
                    },
                    get: function (t) {
                        const e = r(t);
                        return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                    }
                }
            }

            function er(t, e, r, n) {
                const o = {},
                    h = new WeakMap;

                function l(t) {
                    const c = t.target;
                    null !== c.index && e.remove(c.index);
                    for (const t in c.attributes) e.remove(c.attributes[t]);
                    c.removeEventListener("dispose", l), delete o[c.id];
                    const d = h.get(c);
                    d && (e.remove(d), h.delete(c)), n.releaseStatesOfGeometry(c), !0 === c.isInstancedBufferGeometry && delete c._maxInstanceCount, r.memory.geometries--
                }

                function c(t) {
                    const r = [],
                        n = t.index,
                        o = t.attributes.position;
                    let l = 0;
                    if (null !== n) {
                        const t = n.array;
                        l = n.version;
                        for (let i = 0, e = t.length; i < e; i += 3) {
                            const a = t[i + 0],
                                b = t[i + 1],
                                e = t[i + 2];
                            r.push(a, b, b, e, e, a)
                        }
                    } else {
                        const t = o.array;
                        l = o.version;
                        for (let i = 0, e = t.length / 3 - 1; i < e; i += 3) {
                            const a = i + 0,
                                b = i + 1,
                                t = i + 2;
                            r.push(a, b, b, t, t, a)
                        }
                    }
                    const c = new(Ye(r) > 65535 ? qe : je)(r, 1);
                    c.version = l;
                    const d = h.get(t);
                    d && e.remove(d), h.set(t, c)
                }
                return {
                    get: function (object, t) {
                        return !0 === o[t.id] || (t.addEventListener("dispose", l), o[t.id] = !0, r.memory.geometries++), t
                    },
                    update: function (t) {
                        const r = t.attributes;
                        for (const t in r) e.update(r[t], 34962);
                        const n = t.morphAttributes;
                        for (const t in n) {
                            const r = n[t];
                            for (let i = 0, t = r.length; i < t; i++) e.update(r[i], 34962)
                        }
                    },
                    getWireframeAttribute: function (t) {
                        const e = h.get(t);
                        if (e) {
                            const r = t.index;
                            null !== r && e.version < r.version && c(t)
                        } else c(t);
                        return h.get(t)
                    }
                }
            }

            function ir(t, e, r, n) {
                const o = n.isWebGL2;
                let h, l, c;
                this.setMode = function (t) {
                    h = t
                }, this.setIndex = function (t) {
                    l = t.type, c = t.bytesPerElement
                }, this.render = function (e, n) {
                    t.drawElements(h, n, l, e * c), r.update(n, h, 1)
                }, this.renderInstances = function (n, d, m) {
                    if (0 === m) return;
                    let f, y;
                    if (o) f = t, y = "drawElementsInstanced";
                    else if (f = e.get("ANGLE_instanced_arrays"), y = "drawElementsInstancedANGLE", null === f) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    f[y](h, d, l, n * c, m), r.update(d, h, m)
                }
            }

            function rr(t) {
                const e = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: e,
                    programs: null,
                    autoReset: !0,
                    reset: function () {
                        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                    },
                    update: function (t, r, n) {
                        switch (e.calls++, r) {
                            case 4:
                                e.triangles += n * (t / 3);
                                break;
                            case 1:
                                e.lines += n * (t / 2);
                                break;
                            case 3:
                                e.lines += n * (t - 1);
                                break;
                            case 2:
                                e.lines += n * t;
                                break;
                            case 0:
                                e.points += n * t;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                        }
                    }
                }
            }

            function nr(a, b) {
                return a[0] - b[0]
            }

            function sr(a, b) {
                return Math.abs(b[1]) - Math.abs(a[1])
            }

            function ar(t) {
                const e = {},
                    r = new Float32Array(8),
                    n = [];
                for (let i = 0; i < 8; i++) n[i] = [i, 0];
                return {
                    update: function (object, o, h, l) {
                        const c = object.morphTargetInfluences,
                            d = void 0 === c ? 0 : c.length;
                        let m = e[o.id];
                        if (void 0 === m || m.length !== d) {
                            m = [];
                            for (let i = 0; i < d; i++) m[i] = [i, 0];
                            e[o.id] = m
                        }
                        for (let i = 0; i < d; i++) {
                            const t = m[i];
                            t[0] = i, t[1] = c[i]
                        }
                        m.sort(sr);
                        for (let i = 0; i < 8; i++) i < d && m[i][1] ? (n[i][0] = m[i][0], n[i][1] = m[i][1]) : (n[i][0] = Number.MAX_SAFE_INTEGER, n[i][1] = 0);
                        n.sort(nr);
                        const f = h.morphTargets && o.morphAttributes.position,
                            y = h.morphNormals && o.morphAttributes.normal;
                        let v = 0;
                        for (let i = 0; i < 8; i++) {
                            const t = n[i],
                                e = t[0],
                                h = t[1];
                            e !== Number.MAX_SAFE_INTEGER && h ? (f && o.getAttribute("morphTarget" + i) !== f[e] && o.setAttribute("morphTarget" + i, f[e]), y && o.getAttribute("morphNormal" + i) !== y[e] && o.setAttribute("morphNormal" + i, y[e]), r[i] = h, v += h) : (f && !0 === o.hasAttribute("morphTarget" + i) && o.deleteAttribute("morphTarget" + i), y && !0 === o.hasAttribute("morphNormal" + i) && o.deleteAttribute("morphNormal" + i), r[i] = 0)
                        }
                        const x = o.morphTargetsRelative ? 1 : 1 - v;
                        l.getUniforms().setValue(t, "morphTargetBaseInfluence", x), l.getUniforms().setValue(t, "morphTargetInfluences", r)
                    }
                }
            }

            function or(t, e, r, n) {
                let o = new WeakMap;

                function h(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", h), r.remove(e.instanceMatrix), null !== e.instanceColor && r.remove(e.instanceColor)
                }
                return {
                    update: function (object) {
                        const t = n.render.frame,
                            l = object.geometry,
                            c = e.get(object, l);
                        return o.get(c) !== t && (e.update(c), o.set(c, t)), object.isInstancedMesh && (!1 === object.hasEventListener("dispose", h) && object.addEventListener("dispose", h), r.update(object.instanceMatrix, 34962), null !== object.instanceColor && r.update(object.instanceColor, 34962)), c
                    },
                    dispose: function () {
                        o = new WeakMap
                    }
                }
            }
            qi.physical = {
                uniforms: Ei([qi.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new at(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    sheen: {
                        value: new Oe(0)
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionSamplerSize: {
                        value: new at
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new Oe(0)
                    }
                }]),
                vertexShader: Wi.meshphysical_vert,
                fragmentShader: Wi.meshphysical_frag
            };
            class lr extends pt {
                constructor(data = null, t = 1, e = 1, r = 1) {
                    super(null), this.image = {
                        data: data,
                        width: t,
                        height: e,
                        depth: r
                    }, this.magFilter = y, this.minFilter = y, this.wrapR = m, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
                }
            }
            lr.prototype.isDataTexture2DArray = !0;
            class cr extends pt {
                constructor(data = null, t = 1, e = 1, r = 1) {
                    super(null), this.image = {
                        data: data,
                        width: t,
                        height: e,
                        depth: r
                    }, this.magFilter = y, this.minFilter = y, this.wrapR = m, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
                }
            }
            cr.prototype.isDataTexture3D = !0;
            const pr = new pt,
                ur = new lr,
                dr = new cr,
                mr = new Ri,
                fr = [],
                gr = [],
                yr = new Float32Array(16),
                vr = new Float32Array(9),
                xr = new Float32Array(4);

            function _r(t, e, r) {
                const n = t[0];
                if (n <= 0 || n > 0) return t;
                const o = e * r;
                let h = fr[o];
                if (void 0 === h && (h = new Float32Array(o), fr[o] = h), 0 !== e) {
                    n.toArray(h, 0);
                    for (let i = 1, n = 0; i !== e; ++i) n += r, t[i].toArray(h, n)
                }
                return h
            }

            function Mr(a, b) {
                if (a.length !== b.length) return !1;
                for (let i = 0, t = a.length; i < t; i++)
                    if (a[i] !== b[i]) return !1;
                return !0
            }

            function Sr(a, b) {
                for (let i = 0, t = b.length; i < t; i++) a[i] = b[i]
            }

            function wr(t, e) {
                let r = gr[e];
                void 0 === r && (r = new Int32Array(e), gr[e] = r);
                for (let i = 0; i !== e; ++i) r[i] = t.allocateTextureUnit();
                return r
            }

            function Er(t, e) {
                const r = this.cache;
                r[0] !== e && (t.uniform1f(this.addr, e), r[0] = e)
            }

            function Tr(t, e) {
                const r = this.cache;
                if (void 0 !== e.x) r[0] === e.x && r[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), r[0] = e.x, r[1] = e.y);
                else {
                    if (Mr(r, e)) return;
                    t.uniform2fv(this.addr, e), Sr(r, e)
                }
            }

            function Ar(t, e) {
                const r = this.cache;
                if (void 0 !== e.x) r[0] === e.x && r[1] === e.y && r[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), r[0] = e.x, r[1] = e.y, r[2] = e.z);
                else if (void 0 !== e.r) r[0] === e.r && r[1] === e.g && r[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), r[0] = e.r, r[1] = e.g, r[2] = e.b);
                else {
                    if (Mr(r, e)) return;
                    t.uniform3fv(this.addr, e), Sr(r, e)
                }
            }

            function Pr(t, e) {
                const r = this.cache;
                if (void 0 !== e.x) r[0] === e.x && r[1] === e.y && r[2] === e.z && r[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), r[0] = e.x, r[1] = e.y, r[2] = e.z, r[3] = e.w);
                else {
                    if (Mr(r, e)) return;
                    t.uniform4fv(this.addr, e), Sr(r, e)
                }
            }

            function Cr(t, e) {
                const r = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (Mr(r, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), Sr(r, e)
                } else {
                    if (Mr(r, n)) return;
                    xr.set(n), t.uniformMatrix2fv(this.addr, !1, xr), Sr(r, n)
                }
            }

            function Lr(t, e) {
                const r = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (Mr(r, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), Sr(r, e)
                } else {
                    if (Mr(r, n)) return;
                    vr.set(n), t.uniformMatrix3fv(this.addr, !1, vr), Sr(r, n)
                }
            }

            function Dr(t, e) {
                const r = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (Mr(r, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), Sr(r, e)
                } else {
                    if (Mr(r, n)) return;
                    yr.set(n), t.uniformMatrix4fv(this.addr, !1, yr), Sr(r, n)
                }
            }

            function Rr(t, e) {
                const r = this.cache;
                r[0] !== e && (t.uniform1i(this.addr, e), r[0] = e)
            }

            function Ir(t, e) {
                const r = this.cache;
                Mr(r, e) || (t.uniform2iv(this.addr, e), Sr(r, e))
            }

            function Fr(t, e) {
                const r = this.cache;
                Mr(r, e) || (t.uniform3iv(this.addr, e), Sr(r, e))
            }

            function kr(t, e) {
                const r = this.cache;
                Mr(r, e) || (t.uniform4iv(this.addr, e), Sr(r, e))
            }

            function Nr(t, e) {
                const r = this.cache;
                r[0] !== e && (t.uniform1ui(this.addr, e), r[0] = e)
            }

            function Br(t, e) {
                const r = this.cache;
                Mr(r, e) || (t.uniform2uiv(this.addr, e), Sr(r, e))
            }

            function zr(t, e) {
                const r = this.cache;
                Mr(r, e) || (t.uniform3uiv(this.addr, e), Sr(r, e))
            }

            function Vr(t, e) {
                const r = this.cache;
                Mr(r, e) || (t.uniform4uiv(this.addr, e), Sr(r, e))
            }

            function Or(t, e, r) {
                const n = this.cache,
                    o = r.allocateTextureUnit();
                n[0] !== o && (t.uniform1i(this.addr, o), n[0] = o), r.safeSetTexture2D(e || pr, o)
            }

            function Gr(t, e, r) {
                const n = this.cache,
                    o = r.allocateTextureUnit();
                n[0] !== o && (t.uniform1i(this.addr, o), n[0] = o), r.setTexture3D(e || dr, o)
            }

            function Hr(t, e, r) {
                const n = this.cache,
                    o = r.allocateTextureUnit();
                n[0] !== o && (t.uniform1i(this.addr, o), n[0] = o), r.safeSetTextureCube(e || mr, o)
            }

            function Ur(t, e, r) {
                const n = this.cache,
                    o = r.allocateTextureUnit();
                n[0] !== o && (t.uniform1i(this.addr, o), n[0] = o), r.setTexture2DArray(e || ur, o)
            }

            function Wr(t, e) {
                t.uniform1fv(this.addr, e)
            }

            function jr(t, e) {
                const data = _r(e, this.size, 2);
                t.uniform2fv(this.addr, data)
            }

            function qr(t, e) {
                const data = _r(e, this.size, 3);
                t.uniform3fv(this.addr, data)
            }

            function Xr(t, e) {
                const data = _r(e, this.size, 4);
                t.uniform4fv(this.addr, data)
            }

            function Yr(t, e) {
                const data = _r(e, this.size, 4);
                t.uniformMatrix2fv(this.addr, !1, data)
            }

            function Jr(t, e) {
                const data = _r(e, this.size, 9);
                t.uniformMatrix3fv(this.addr, !1, data)
            }

            function Zr(t, e) {
                const data = _r(e, this.size, 16);
                t.uniformMatrix4fv(this.addr, !1, data)
            }

            function Kr(t, e) {
                t.uniform1iv(this.addr, e)
            }

            function Qr(t, e) {
                t.uniform2iv(this.addr, e)
            }

            function $r(t, e) {
                t.uniform3iv(this.addr, e)
            }

            function tn(t, e) {
                t.uniform4iv(this.addr, e)
            }

            function en(t, e) {
                t.uniform1uiv(this.addr, e)
            }

            function rn(t, e) {
                t.uniform2uiv(this.addr, e)
            }

            function nn(t, e) {
                t.uniform3uiv(this.addr, e)
            }

            function sn(t, e) {
                t.uniform4uiv(this.addr, e)
            }

            function an(t, e, r) {
                const n = e.length,
                    o = wr(r, n);
                t.uniform1iv(this.addr, o);
                for (let i = 0; i !== n; ++i) r.safeSetTexture2D(e[i] || pr, o[i])
            }

            function on(t, e, r) {
                const n = e.length,
                    o = wr(r, n);
                t.uniform1iv(this.addr, o);
                for (let i = 0; i !== n; ++i) r.safeSetTextureCube(e[i] || mr, o[i])
            }

            function hn(t, e, r) {
                this.id = t, this.addr = r, this.cache = [], this.setValue = function (t) {
                    switch (t) {
                        case 5126:
                            return Er;
                        case 35664:
                            return Tr;
                        case 35665:
                            return Ar;
                        case 35666:
                            return Pr;
                        case 35674:
                            return Cr;
                        case 35675:
                            return Lr;
                        case 35676:
                            return Dr;
                        case 5124:
                        case 35670:
                            return Rr;
                        case 35667:
                        case 35671:
                            return Ir;
                        case 35668:
                        case 35672:
                            return Fr;
                        case 35669:
                        case 35673:
                            return kr;
                        case 5125:
                            return Nr;
                        case 36294:
                            return Br;
                        case 36295:
                            return zr;
                        case 36296:
                            return Vr;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Or;
                        case 35679:
                        case 36299:
                        case 36307:
                            return Gr;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Hr;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return Ur
                    }
                }(e.type)
            }

            function ln(t, e, r) {
                this.id = t, this.addr = r, this.cache = [], this.size = e.size, this.setValue = function (t) {
                    switch (t) {
                        case 5126:
                            return Wr;
                        case 35664:
                            return jr;
                        case 35665:
                            return qr;
                        case 35666:
                            return Xr;
                        case 35674:
                            return Yr;
                        case 35675:
                            return Jr;
                        case 35676:
                            return Zr;
                        case 5124:
                        case 35670:
                            return Kr;
                        case 35667:
                        case 35671:
                            return Qr;
                        case 35668:
                        case 35672:
                            return $r;
                        case 35669:
                        case 35673:
                            return tn;
                        case 5125:
                            return en;
                        case 36294:
                            return rn;
                        case 36295:
                            return nn;
                        case 36296:
                            return sn;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return an;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return on
                    }
                }(e.type)
            }

            function cn(t) {
                this.id = t, this.seq = [], this.map = {}
            }
            ln.prototype.updateCache = function (data) {
                const t = this.cache;
                data instanceof Float32Array && t.length !== data.length && (this.cache = new Float32Array(data.length)), Sr(t, data)
            }, cn.prototype.setValue = function (t, e, r) {
                const n = this.seq;
                for (let i = 0, o = n.length; i !== o; ++i) {
                    const u = n[i];
                    u.setValue(t, e[u.id], r)
                }
            };
            const pn = /(\w+)(\])?(\[|\.)?/g;

            function un(t, e) {
                t.seq.push(e), t.map[e.id] = e
            }

            function dn(t, e, r) {
                const path = t.name,
                    n = path.length;
                for (pn.lastIndex = 0;;) {
                    const o = pn.exec(path),
                        h = pn.lastIndex;
                    let l = o[1];
                    const c = "]" === o[2],
                        d = o[3];
                    if (c && (l |= 0), void 0 === d || "[" === d && h + 2 === n) {
                        un(r, void 0 === d ? new hn(l, t, e) : new ln(l, t, e));
                        break
                    } {
                        let t = r.map[l];
                        void 0 === t && (t = new cn(l), un(r, t)), r = t
                    }
                }
            }

            function mn(t, e) {
                this.seq = [], this.map = {};
                const r = t.getProgramParameter(e, 35718);
                for (let i = 0; i < r; ++i) {
                    const r = t.getActiveUniform(e, i);
                    dn(r, t.getUniformLocation(e, r.name), this)
                }
            }

            function fn(t, e, r) {
                const n = t.createShader(e);
                return t.shaderSource(n, r), t.compileShader(n), n
            }
            mn.prototype.setValue = function (t, e, r, n) {
                const u = this.map[e];
                void 0 !== u && u.setValue(t, r, n)
            }, mn.prototype.setOptional = function (t, object, e) {
                const r = object[e];
                void 0 !== r && this.setValue(t, e, r)
            }, mn.upload = function (t, e, r, n) {
                for (let i = 0, o = e.length; i !== o; ++i) {
                    const u = e[i],
                        o = r[u.id];
                    !1 !== o.needsUpdate && u.setValue(t, o.value, n)
                }
            }, mn.seqWithValue = function (t, e) {
                const r = [];
                for (let i = 0, n = t.length; i !== n; ++i) {
                    const u = t[i];
                    u.id in e && r.push(u)
                }
                return r
            };
            let gn = 0;

            function yn(t) {
                switch (t) {
                    case O:
                        return ["Linear", "( value )"];
                    case G:
                        return ["sRGB", "( value )"];
                    case U:
                        return ["RGBE", "( value )"];
                    case 3004:
                        return ["RGBM", "( value, 7.0 )"];
                    case 3005:
                        return ["RGBM", "( value, 16.0 )"];
                    case 3006:
                        return ["RGBD", "( value, 256.0 )"];
                    case H:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    case 3003:
                        return ["LogLuv", "( value )"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                }
            }

            function vn(t, e, r) {
                const n = t.getShaderParameter(e, 35713),
                    o = t.getShaderInfoLog(e).trim();
                if (n && "" === o) return "";
                return "THREE.WebGLShader: gl.getShaderInfoLog() " + r + "\n" + o + function (t) {
                    const e = t.split("\n");
                    for (let i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
                    return e.join("\n")
                }(t.getShaderSource(e))
            }

            function xn(t, e) {
                const r = yn(e);
                return "vec4 " + t + "( vec4 value ) { return " + r[0] + "ToLinear" + r[1] + "; }"
            }

            function _n(t, e) {
                const r = yn(e);
                return "vec4 " + t + "( vec4 value ) { return LinearTo" + r[0] + r[1] + "; }"
            }

            function bn(t, e) {
                let r;
                switch (e) {
                    case 1:
                        r = "Linear";
                        break;
                    case 2:
                        r = "Reinhard";
                        break;
                    case 3:
                        r = "OptimizedCineon";
                        break;
                    case 4:
                        r = "ACESFilmic";
                        break;
                    case 5:
                        r = "Custom";
                        break;
                    default:
                        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), r = "Linear"
                }
                return "vec3 " + t + "( vec3 color ) { return " + r + "ToneMapping( color ); }"
            }

            function Mn(t) {
                return "" !== t
            }

            function Sn(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
            }

            function wn(t, e) {
                return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
            }
            const En = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function Tn(t) {
                return t.replace(En, An)
            }

            function An(t, e) {
                const r = Wi[e];
                if (void 0 === r) throw new Error("Can not resolve #include <" + e + ">");
                return Tn(r)
            }
            const Pn = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                Cn = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function Ln(t) {
                return t.replace(Cn, Rn).replace(Pn, Dn)
            }

            function Dn(t, e, r, n) {
                return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Rn(t, e, r, n)
            }

            function Rn(t, e, r, n) {
                let o = "";
                for (let i = parseInt(e); i < parseInt(r); i++) o += n.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
                return o
            }

            function In(t) {
                let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
            }

            function Fn(t, e, r, n) {
                const d = t.getContext(),
                    m = r.defines;
                let f = r.vertexShader,
                    y = r.fragmentShader;
                const v = function (t) {
                        let e = "SHADOWMAP_TYPE_BASIC";
                        return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
                    }(r),
                    x = function (t) {
                        let e = "ENVMAP_TYPE_CUBE";
                        if (t.envMap) switch (t.envMapMode) {
                            case o:
                            case h:
                                e = "ENVMAP_TYPE_CUBE";
                                break;
                            case l:
                            case c:
                                e = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return e
                    }(r),
                    _ = function (t) {
                        let e = "ENVMAP_MODE_REFLECTION";
                        if (t.envMap) switch (t.envMapMode) {
                            case h:
                            case c:
                                e = "ENVMAP_MODE_REFRACTION"
                        }
                        return e
                    }(r),
                    M = function (t) {
                        let e = "ENVMAP_BLENDING_NONE";
                        if (t.envMap) switch (t.combine) {
                            case 0:
                                e = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case 1:
                                e = "ENVMAP_BLENDING_MIX";
                                break;
                            case 2:
                                e = "ENVMAP_BLENDING_ADD"
                        }
                        return e
                    }(r),
                    S = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    w = r.isWebGL2 ? "" : function (t) {
                        return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission > 0) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Mn).join("\n")
                    }(r),
                    E = function (t) {
                        const e = [];
                        for (const r in t) {
                            const n = t[r];
                            !1 !== n && e.push("#define " + r + " " + n)
                        }
                        return e.join("\n")
                    }(m),
                    T = d.createProgram();
                let A, P, C = r.glslVersion ? "#version " + r.glslVersion + "\n" : "";
                r.isRawShaderMaterial ? (A = [E].filter(Mn).join("\n"), A.length > 0 && (A += "\n"), P = [w, E].filter(Mn).join("\n"), P.length > 0 && (P += "\n")) : (A = [In(r), "#define SHADER_NAME " + r.shaderName, E, r.instancing ? "#define USE_INSTANCING" : "", r.instancingColor ? "#define USE_INSTANCING_COLOR" : "", r.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + S, "#define MAX_BONES " + r.maxBones, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + _ : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.displacementMap && r.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.transmission ? "#define USE_TRANSMISSION" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.thicknessMap ? "#define USE_THICKNESSMAP" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors ? "#define USE_COLOR" : "", r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.skinning ? "#define USE_SKINNING" : "", r.useVertexTexture ? "#define BONE_TEXTURE" : "", r.morphTargets ? "#define USE_MORPHTARGETS" : "", r.morphNormals && !1 === r.flatShading ? "#define USE_MORPHNORMALS" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + v : "", r.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Mn).join("\n"), P = [w, In(r), "#define SHADER_NAME " + r.shaderName, E, r.alphaTest ? "#define ALPHATEST " + r.alphaTest + (r.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + S, r.useFog && r.fog ? "#define USE_FOG" : "", r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "", r.map ? "#define USE_MAP" : "", r.matcap ? "#define USE_MATCAP" : "", r.envMap ? "#define USE_ENVMAP" : "", r.envMap ? "#define " + x : "", r.envMap ? "#define " + _ : "", r.envMap ? "#define " + M : "", r.lightMap ? "#define USE_LIGHTMAP" : "", r.aoMap ? "#define USE_AOMAP" : "", r.emissiveMap ? "#define USE_EMISSIVEMAP" : "", r.bumpMap ? "#define USE_BUMPMAP" : "", r.normalMap ? "#define USE_NORMALMAP" : "", r.normalMap && r.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", r.normalMap && r.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", r.specularMap ? "#define USE_SPECULARMAP" : "", r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", r.metalnessMap ? "#define USE_METALNESSMAP" : "", r.alphaMap ? "#define USE_ALPHAMAP" : "", r.sheen ? "#define USE_SHEEN" : "", r.transmission ? "#define USE_TRANSMISSION" : "", r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", r.thicknessMap ? "#define USE_THICKNESSMAP" : "", r.vertexTangents ? "#define USE_TANGENT" : "", r.vertexColors || r.instancingColor ? "#define USE_COLOR" : "", r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", r.vertexUvs ? "#define USE_UV" : "", r.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", r.gradientMap ? "#define USE_GRADIENTMAP" : "", r.flatShading ? "#define FLAT_SHADED" : "", r.doubleSided ? "#define DOUBLE_SIDED" : "", r.flipSided ? "#define FLIP_SIDED" : "", r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", r.shadowMapEnabled ? "#define " + v : "", r.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", r.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", r.logarithmicDepthBuffer && r.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (r.extensionShaderTextureLOD || r.envMap) && r.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== r.toneMapping ? "#define TONE_MAPPING" : "", 0 !== r.toneMapping ? Wi.tonemapping_pars_fragment : "", 0 !== r.toneMapping ? bn("toneMapping", r.toneMapping) : "", r.dithering ? "#define DITHERING" : "", Wi.encodings_pars_fragment, r.map ? xn("mapTexelToLinear", r.mapEncoding) : "", r.matcap ? xn("matcapTexelToLinear", r.matcapEncoding) : "", r.envMap ? xn("envMapTexelToLinear", r.envMapEncoding) : "", r.emissiveMap ? xn("emissiveMapTexelToLinear", r.emissiveMapEncoding) : "", r.lightMap ? xn("lightMapTexelToLinear", r.lightMapEncoding) : "", _n("linearToOutputTexel", r.outputEncoding), r.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(Mn).join("\n")), f = Tn(f), f = Sn(f, r), f = wn(f, r), y = Tn(y), y = Sn(y, r), y = wn(y, r), f = Ln(f), y = Ln(y), r.isWebGL2 && !0 !== r.isRawShaderMaterial && (C = "#version 300 es\n", A = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + A, P = ["#define varying in", r.glslVersion === Y ? "" : "out highp vec4 pc_fragColor;", r.glslVersion === Y ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + P);
                const L = C + P + y,
                    D = fn(d, 35633, C + A + f),
                    R = fn(d, 35632, L);
                if (d.attachShader(T, D), d.attachShader(T, R), void 0 !== r.index0AttributeName ? d.bindAttribLocation(T, 0, r.index0AttributeName) : !0 === r.morphTargets && d.bindAttribLocation(T, 0, "position"), d.linkProgram(T), t.debug.checkShaderErrors) {
                    const t = d.getProgramInfoLog(T).trim(),
                        e = d.getShaderInfoLog(D).trim(),
                        r = d.getShaderInfoLog(R).trim();
                    let n = !0,
                        o = !0;
                    if (!1 === d.getProgramParameter(T, 35714)) {
                        n = !1;
                        const e = vn(d, D, "vertex"),
                            r = vn(d, R, "fragment");
                        console.error("THREE.WebGLProgram: shader error: ", d.getError(), "35715", d.getProgramParameter(T, 35715), "gl.getProgramInfoLog", t, e, r)
                    } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== r || (o = !1);
                    o && (this.diagnostics = {
                        runnable: n,
                        programLog: t,
                        vertexShader: {
                            log: e,
                            prefix: A
                        },
                        fragmentShader: {
                            log: r,
                            prefix: P
                        }
                    })
                }
                let I, F;
                return d.deleteShader(D), d.deleteShader(R), this.getUniforms = function () {
                    return void 0 === I && (I = new mn(d, T)), I
                }, this.getAttributes = function () {
                    return void 0 === F && (F = function (t, e) {
                        const r = {},
                            n = t.getProgramParameter(e, 35721);
                        for (let i = 0; i < n; i++) {
                            const n = t.getActiveAttrib(e, i).name;
                            r[n] = t.getAttribLocation(e, n)
                        }
                        return r
                    }(d, T)), F
                }, this.destroy = function () {
                    n.releaseStatesOfProgram(this), d.deleteProgram(T), this.program = void 0
                }, this.name = r.shaderName, this.id = gn++, this.cacheKey = e, this.usedTimes = 1, this.program = T, this.vertexShader = D, this.fragmentShader = R, this
            }

            function kn(t, e, r, n, o, h) {
                const d = [],
                    m = n.isWebGL2,
                    f = n.logarithmicDepthBuffer,
                    y = n.floatVertexTextures,
                    v = n.maxVertexUniforms,
                    x = n.vertexTextures;
                let _ = n.precision;
                const M = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    S = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"];

                function w(map) {
                    let t;
                    return map && map.isTexture ? t = map.encoding : map && map.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = map.texture.encoding) : t = O, t
                }
                return {
                    getParameters: function (o, d, S, E, object) {
                        const T = E.fog,
                            A = o.isMeshStandardMaterial ? E.environment : null,
                            P = e.get(o.envMap || A),
                            C = M[o.type],
                            L = object.isSkinnedMesh ? function (object) {
                                const t = object.skeleton.bones;
                                if (y) return 1024; {
                                    const e = v,
                                        r = Math.floor((e - 20) / 4),
                                        n = Math.min(r, t.length);
                                    return n < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + n + "."), 0) : n
                                }
                            }(object) : 0;
                        let D, R;
                        if (null !== o.precision && (_ = n.getMaxPrecision(o.precision), _ !== o.precision && console.warn("THREE.WebGLProgram.getParameters:", o.precision, "not supported, using", _, "instead.")), C) {
                            const t = qi[C];
                            D = t.vertexShader, R = t.fragmentShader
                        } else D = o.vertexShader, R = o.fragmentShader;
                        const I = t.getRenderTarget();
                        return {
                            isWebGL2: m,
                            shaderID: C,
                            shaderName: o.type,
                            vertexShader: D,
                            fragmentShader: R,
                            defines: o.defines,
                            isRawShaderMaterial: !0 === o.isRawShaderMaterial,
                            glslVersion: o.glslVersion,
                            precision: _,
                            instancing: !0 === object.isInstancedMesh,
                            instancingColor: !0 === object.isInstancedMesh && null !== object.instanceColor,
                            supportsVertexTextures: x,
                            outputEncoding: null !== I ? w(I.texture) : t.outputEncoding,
                            map: !!o.map,
                            mapEncoding: w(o.map),
                            matcap: !!o.matcap,
                            matcapEncoding: w(o.matcap),
                            envMap: !!P,
                            envMapMode: P && P.mapping,
                            envMapEncoding: w(P),
                            envMapCubeUV: !!P && (P.mapping === l || P.mapping === c),
                            lightMap: !!o.lightMap,
                            lightMapEncoding: w(o.lightMap),
                            aoMap: !!o.aoMap,
                            emissiveMap: !!o.emissiveMap,
                            emissiveMapEncoding: w(o.emissiveMap),
                            bumpMap: !!o.bumpMap,
                            normalMap: !!o.normalMap,
                            objectSpaceNormalMap: 1 === o.normalMapType,
                            tangentSpaceNormalMap: 0 === o.normalMapType,
                            clearcoatMap: !!o.clearcoatMap,
                            clearcoatRoughnessMap: !!o.clearcoatRoughnessMap,
                            clearcoatNormalMap: !!o.clearcoatNormalMap,
                            displacementMap: !!o.displacementMap,
                            roughnessMap: !!o.roughnessMap,
                            metalnessMap: !!o.metalnessMap,
                            specularMap: !!o.specularMap,
                            alphaMap: !!o.alphaMap,
                            gradientMap: !!o.gradientMap,
                            sheen: !!o.sheen,
                            transmission: !!o.transmission,
                            transmissionMap: !!o.transmissionMap,
                            thicknessMap: !!o.thicknessMap,
                            combine: o.combine,
                            vertexTangents: o.normalMap && o.vertexTangents,
                            vertexColors: o.vertexColors,
                            vertexAlphas: !0 === o.vertexColors && object.geometry && object.geometry.attributes.color && 4 === object.geometry.attributes.color.itemSize,
                            vertexUvs: !!(o.map || o.bumpMap || o.normalMap || o.specularMap || o.alphaMap || o.emissiveMap || o.roughnessMap || o.metalnessMap || o.clearcoatMap || o.clearcoatRoughnessMap || o.clearcoatNormalMap || o.displacementMap || o.transmissionMap || o.thicknessMap),
                            uvsVertexOnly: !(o.map || o.bumpMap || o.normalMap || o.specularMap || o.alphaMap || o.emissiveMap || o.roughnessMap || o.metalnessMap || o.clearcoatNormalMap || o.transmission || o.transmissionMap || o.thicknessMap || !o.displacementMap),
                            fog: !!T,
                            useFog: o.fog,
                            fogExp2: T && T.isFogExp2,
                            flatShading: !!o.flatShading,
                            sizeAttenuation: o.sizeAttenuation,
                            logarithmicDepthBuffer: f,
                            skinning: !0 === object.isSkinnedMesh && L > 0,
                            maxBones: L,
                            useVertexTexture: y,
                            morphTargets: o.morphTargets,
                            morphNormals: o.morphNormals,
                            numDirLights: d.directional.length,
                            numPointLights: d.point.length,
                            numSpotLights: d.spot.length,
                            numRectAreaLights: d.rectArea.length,
                            numHemiLights: d.hemi.length,
                            numDirLightShadows: d.directionalShadowMap.length,
                            numPointLightShadows: d.pointShadowMap.length,
                            numSpotLightShadows: d.spotShadowMap.length,
                            numClippingPlanes: h.numPlanes,
                            numClipIntersection: h.numIntersection,
                            dithering: o.dithering,
                            shadowMapEnabled: t.shadowMap.enabled && S.length > 0,
                            shadowMapType: t.shadowMap.type,
                            toneMapping: o.toneMapped ? t.toneMapping : 0,
                            physicallyCorrectLights: t.physicallyCorrectLights,
                            premultipliedAlpha: o.premultipliedAlpha,
                            alphaTest: o.alphaTest,
                            doubleSided: 2 === o.side,
                            flipSided: 1 === o.side,
                            depthPacking: void 0 !== o.depthPacking && o.depthPacking,
                            index0AttributeName: o.index0AttributeName,
                            extensionDerivatives: o.extensions && o.extensions.derivatives,
                            extensionFragDepth: o.extensions && o.extensions.fragDepth,
                            extensionDrawBuffers: o.extensions && o.extensions.drawBuffers,
                            extensionShaderTextureLOD: o.extensions && o.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: m || r.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: m || r.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: m || r.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: o.customProgramCacheKey()
                        }
                    },
                    getProgramCacheKey: function (e) {
                        const r = [];
                        if (e.shaderID ? r.push(e.shaderID) : (r.push(e.fragmentShader), r.push(e.vertexShader)), void 0 !== e.defines)
                            for (const t in e.defines) r.push(t), r.push(e.defines[t]);
                        if (!1 === e.isRawShaderMaterial) {
                            for (let i = 0; i < S.length; i++) r.push(e[S[i]]);
                            r.push(t.outputEncoding), r.push(t.gammaFactor)
                        }
                        return r.push(e.customProgramCacheKey), r.join()
                    },
                    getUniforms: function (t) {
                        const e = M[t.type];
                        let r;
                        if (e) {
                            const t = qi[e];
                            r = Ti.clone(t.uniforms)
                        } else r = t.uniforms;
                        return r
                    },
                    acquireProgram: function (e, r) {
                        let n;
                        for (let p = 0, t = d.length; p < t; p++) {
                            const t = d[p];
                            if (t.cacheKey === r) {
                                n = t, ++n.usedTimes;
                                break
                            }
                        }
                        return void 0 === n && (n = new Fn(t, r, e, o), d.push(n)), n
                    },
                    releaseProgram: function (t) {
                        if (0 == --t.usedTimes) {
                            const i = d.indexOf(t);
                            d[i] = d[d.length - 1], d.pop(), t.destroy()
                        }
                    },
                    programs: d
                }
            }

            function Nn() {
                let t = new WeakMap;
                return {
                    get: function (object) {
                        let map = t.get(object);
                        return void 0 === map && (map = {}, t.set(object, map)), map
                    },
                    remove: function (object) {
                        t.delete(object)
                    },
                    update: function (object, e, r) {
                        t.get(object)[e] = r
                    },
                    dispose: function () {
                        t = new WeakMap
                    }
                }
            }

            function Bn(a, b) {
                return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
            }

            function zn(a, b) {
                return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
            }

            function Vn(t) {
                const e = [];
                let r = 0;
                const n = [],
                    o = [],
                    h = [],
                    l = {
                        id: -1
                    };

                function c(object, n, o, h, c, d) {
                    let m = e[r];
                    const f = t.get(o);
                    return void 0 === m ? (m = {
                        id: object.id,
                        object: object,
                        geometry: n,
                        material: o,
                        program: f.program || l,
                        groupOrder: h,
                        renderOrder: object.renderOrder,
                        z: c,
                        group: d
                    }, e[r] = m) : (m.id = object.id, m.object = object, m.geometry = n, m.material = o, m.program = f.program || l, m.groupOrder = h, m.renderOrder = object.renderOrder, m.z = c, m.group = d), r++, m
                }
                return {
                    opaque: n,
                    transmissive: o,
                    transparent: h,
                    init: function () {
                        r = 0, n.length = 0, o.length = 0, h.length = 0
                    },
                    push: function (object, t, e, r, l, d) {
                        const m = c(object, t, e, r, l, d);
                        e.transmission > 0 ? o.push(m) : !0 === e.transparent ? h.push(m) : n.push(m)
                    },
                    unshift: function (object, t, e, r, l, d) {
                        const m = c(object, t, e, r, l, d);
                        e.transmission > 0 ? o.unshift(m) : !0 === e.transparent ? h.unshift(m) : n.unshift(m)
                    },
                    finish: function () {
                        for (let i = r, t = e.length; i < t; i++) {
                            const t = e[i];
                            if (null === t.id) break;
                            t.id = null, t.object = null, t.geometry = null, t.material = null, t.program = null, t.group = null
                        }
                    },
                    sort: function (t, e) {
                        n.length > 1 && n.sort(t || Bn), o.length > 1 && o.sort(e || zn), h.length > 1 && h.sort(e || zn)
                    }
                }
            }

            function On(t) {
                let e = new WeakMap;
                return {
                    get: function (r, n) {
                        let o;
                        return !1 === e.has(r) ? (o = new Vn(t), e.set(r, [o])) : n >= e.get(r).length ? (o = new Vn(t), e.get(r).push(o)) : o = e.get(r)[n], o
                    },
                    dispose: function () {
                        e = new WeakMap
                    }
                }
            }

            function Gn() {
                const t = {};
                return {
                    get: function (e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        let r;
                        switch (e.type) {
                            case "DirectionalLight":
                                r = {
                                    direction: new vt,
                                    color: new Oe
                                };
                                break;
                            case "SpotLight":
                                r = {
                                    position: new vt,
                                    direction: new vt,
                                    color: new Oe,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                r = {
                                    position: new vt,
                                    color: new Oe,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                r = {
                                    direction: new vt,
                                    skyColor: new Oe,
                                    groundColor: new Oe
                                };
                                break;
                            case "RectAreaLight":
                                r = {
                                    color: new Oe,
                                    position: new vt,
                                    halfWidth: new vt,
                                    halfHeight: new vt
                                }
                        }
                        return t[e.id] = r, r
                    }
                }
            }
            let Hn = 0;

            function Un(t, e) {
                return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
            }

            function Wn(t, e) {
                const r = new Gn,
                    n = function () {
                        const t = {};
                        return {
                            get: function (e) {
                                if (void 0 !== t[e.id]) return t[e.id];
                                let r;
                                switch (e.type) {
                                    case "DirectionalLight":
                                    case "SpotLight":
                                        r = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new at
                                        };
                                        break;
                                    case "PointLight":
                                        r = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new at,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        }
                                }
                                return t[e.id] = r, r
                            }
                        }
                    }(),
                    o = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    };
                for (let i = 0; i < 9; i++) o.probe.push(new vt);
                const h = new vt,
                    l = new Jt,
                    c = new Jt;
                return {
                    setup: function (h) {
                        let l = 0,
                            g = 0,
                            b = 0;
                        for (let i = 0; i < 9; i++) o.probe[i].set(0, 0, 0);
                        let c = 0,
                            d = 0,
                            m = 0,
                            f = 0,
                            y = 0,
                            v = 0,
                            x = 0,
                            _ = 0;
                        h.sort(Un);
                        for (let i = 0, t = h.length; i < t; i++) {
                            const t = h[i],
                                e = t.color,
                                M = t.intensity,
                                S = t.distance,
                                w = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                            if (t.isAmbientLight) l += e.r * M, g += e.g * M, b += e.b * M;
                            else if (t.isLightProbe)
                                for (let e = 0; e < 9; e++) o.probe[e].addScaledVector(t.sh.coefficients[e], M);
                            else if (t.isDirectionalLight) {
                                const e = r.get(t);
                                if (e.color.copy(t.color).multiplyScalar(t.intensity), t.castShadow) {
                                    const shadow = t.shadow,
                                        e = n.get(t);
                                    e.shadowBias = shadow.bias, e.shadowNormalBias = shadow.normalBias, e.shadowRadius = shadow.radius, e.shadowMapSize = shadow.mapSize, o.directionalShadow[c] = e, o.directionalShadowMap[c] = w, o.directionalShadowMatrix[c] = t.shadow.matrix, v++
                                }
                                o.directional[c] = e, c++
                            } else if (t.isSpotLight) {
                                const h = r.get(t);
                                if (h.position.setFromMatrixPosition(t.matrixWorld), h.color.copy(e).multiplyScalar(M), h.distance = S, h.coneCos = Math.cos(t.angle), h.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), h.decay = t.decay, t.castShadow) {
                                    const shadow = t.shadow,
                                        e = n.get(t);
                                    e.shadowBias = shadow.bias, e.shadowNormalBias = shadow.normalBias, e.shadowRadius = shadow.radius, e.shadowMapSize = shadow.mapSize, o.spotShadow[m] = e, o.spotShadowMap[m] = w, o.spotShadowMatrix[m] = t.shadow.matrix, _++
                                }
                                o.spot[m] = h, m++
                            } else if (t.isRectAreaLight) {
                                const n = r.get(t);
                                n.color.copy(e).multiplyScalar(M), n.halfWidth.set(.5 * t.width, 0, 0), n.halfHeight.set(0, .5 * t.height, 0), o.rectArea[f] = n, f++
                            } else if (t.isPointLight) {
                                const e = r.get(t);
                                if (e.color.copy(t.color).multiplyScalar(t.intensity), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
                                    const shadow = t.shadow,
                                        e = n.get(t);
                                    e.shadowBias = shadow.bias, e.shadowNormalBias = shadow.normalBias, e.shadowRadius = shadow.radius, e.shadowMapSize = shadow.mapSize, e.shadowCameraNear = shadow.camera.near, e.shadowCameraFar = shadow.camera.far, o.pointShadow[d] = e, o.pointShadowMap[d] = w, o.pointShadowMatrix[d] = t.shadow.matrix, x++
                                }
                                o.point[d] = e, d++
                            } else if (t.isHemisphereLight) {
                                const e = r.get(t);
                                e.skyColor.copy(t.color).multiplyScalar(M), e.groundColor.copy(t.groundColor).multiplyScalar(M), o.hemi[y] = e, y++
                            }
                        }
                        f > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (o.rectAreaLTC1 = ji.LTC_FLOAT_1, o.rectAreaLTC2 = ji.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (o.rectAreaLTC1 = ji.LTC_HALF_1, o.rectAreaLTC2 = ji.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), o.ambient[0] = l, o.ambient[1] = g, o.ambient[2] = b;
                        const M = o.hash;
                        M.directionalLength === c && M.pointLength === d && M.spotLength === m && M.rectAreaLength === f && M.hemiLength === y && M.numDirectionalShadows === v && M.numPointShadows === x && M.numSpotShadows === _ || (o.directional.length = c, o.spot.length = m, o.rectArea.length = f, o.point.length = d, o.hemi.length = y, o.directionalShadow.length = v, o.directionalShadowMap.length = v, o.pointShadow.length = x, o.pointShadowMap.length = x, o.spotShadow.length = _, o.spotShadowMap.length = _, o.directionalShadowMatrix.length = v, o.pointShadowMatrix.length = x, o.spotShadowMatrix.length = _, M.directionalLength = c, M.pointLength = d, M.spotLength = m, M.rectAreaLength = f, M.hemiLength = y, M.numDirectionalShadows = v, M.numPointShadows = x, M.numSpotShadows = _, o.version = Hn++)
                    },
                    setupView: function (t, e) {
                        let r = 0,
                            n = 0,
                            d = 0,
                            m = 0,
                            f = 0;
                        const y = e.matrixWorldInverse;
                        for (let i = 0, e = t.length; i < e; i++) {
                            const e = t[i];
                            if (e.isDirectionalLight) {
                                const t = o.directional[r];
                                t.direction.setFromMatrixPosition(e.matrixWorld), h.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(h), t.direction.transformDirection(y), r++
                            } else if (e.isSpotLight) {
                                const t = o.spot[d];
                                t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(y), t.direction.setFromMatrixPosition(e.matrixWorld), h.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(h), t.direction.transformDirection(y), d++
                            } else if (e.isRectAreaLight) {
                                const t = o.rectArea[m];
                                t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(y), c.identity(), l.copy(e.matrixWorld), l.premultiply(y), c.extractRotation(l), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), t.halfWidth.applyMatrix4(c), t.halfHeight.applyMatrix4(c), m++
                            } else if (e.isPointLight) {
                                const t = o.point[n];
                                t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(y), n++
                            } else if (e.isHemisphereLight) {
                                const t = o.hemi[f];
                                t.direction.setFromMatrixPosition(e.matrixWorld), t.direction.transformDirection(y), t.direction.normalize(), f++
                            }
                        }
                    },
                    state: o
                }
            }

            function jn(t, e) {
                const r = new Wn(t, e),
                    n = [],
                    o = [];
                return {
                    init: function () {
                        n.length = 0, o.length = 0
                    },
                    state: {
                        lightsArray: n,
                        shadowsArray: o,
                        lights: r
                    },
                    setupLights: function () {
                        r.setup(n)
                    },
                    setupLightsView: function (t) {
                        r.setupView(n, t)
                    },
                    pushLight: function (t) {
                        n.push(t)
                    },
                    pushShadow: function (t) {
                        o.push(t)
                    }
                }
            }

            function qn(t, e) {
                let r = new WeakMap;
                return {
                    get: function (n, o = 0) {
                        let h;
                        return !1 === r.has(n) ? (h = new jn(t, e), r.set(n, [h])) : o >= r.get(n).length ? (h = new jn(t, e), r.get(n).push(h)) : h = r.get(n)[o], h
                    },
                    dispose: function () {
                        r = new WeakMap
                    }
                }
            }
            class Xn extends Ie {
                constructor(t) {
                    super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.depthPacking = source.depthPacking, this.morphTargets = source.morphTargets, this.map = source.map, this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this
                }
            }
            Xn.prototype.isMeshDepthMaterial = !0;
            class Yn extends Ie {
                constructor(t) {
                    super(), this.type = "MeshDistanceMaterial", this.referencePosition = new vt, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.referencePosition.copy(source.referencePosition), this.nearDistance = source.nearDistance, this.farDistance = source.farDistance, this.morphTargets = source.morphTargets, this.map = source.map, this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this
                }
            }
            Yn.prototype.isMeshDistanceMaterial = !0;

            function Jn(t, e, r) {
                let n = new Oi;
                const o = new at,
                    h = new at,
                    l = new mt,
                    c = [],
                    d = [],
                    m = {},
                    f = r.maxTextureSize,
                    v = {
                        0: 1,
                        1: 0,
                        2: 2
                    },
                    x = new Ai({
                        defines: {
                            SAMPLE_RATE: 2 / 8,
                            HALF_SAMPLE_RATE: 1 / 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new at
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                    }),
                    M = x.clone();
                M.defines.HORIZONTAL_PASS = 1;
                const S = new ii;
                S.setAttribute("position", new We(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                const w = new bi(S, x),
                    E = this;

                function T(shadow, r) {
                    const n = e.update(w);
                    x.uniforms.shadow_pass.value = shadow.map.texture, x.uniforms.resolution.value = shadow.mapSize, x.uniforms.radius.value = shadow.radius, t.setRenderTarget(shadow.mapPass), t.clear(), t.renderBufferDirect(r, null, n, x, w, null), M.uniforms.shadow_pass.value = shadow.mapPass.texture, M.uniforms.resolution.value = shadow.mapSize, M.uniforms.radius.value = shadow.radius, t.setRenderTarget(shadow.map), t.clear(), t.renderBufferDirect(r, null, n, M, w, null)
                }

                function A(t) {
                    const e = t << 0;
                    let r = c[e];
                    return void 0 === r && (r = new Xn({
                        depthPacking: 3201,
                        morphTargets: t
                    }), c[e] = r), r
                }

                function P(t) {
                    const e = t << 0;
                    let r = d[e];
                    return void 0 === r && (r = new Yn({
                        morphTargets: t
                    }), d[e] = r), r
                }

                function C(object, e, r, n, o, h, l) {
                    let c = null,
                        d = A,
                        f = object.customDepthMaterial;
                    if (!0 === n.isPointLight && (d = P, f = object.customDistanceMaterial), void 0 === f) {
                        let t = !1;
                        !0 === r.morphTargets && (t = e.morphAttributes && e.morphAttributes.position && e.morphAttributes.position.length > 0), c = d(t)
                    } else c = f;
                    if (t.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) {
                        const t = c.uuid,
                            e = r.uuid;
                        let n = m[t];
                        void 0 === n && (n = {}, m[t] = n);
                        let o = n[e];
                        void 0 === o && (o = c.clone(), n[e] = o), c = o
                    }
                    return c.visible = r.visible, c.wireframe = r.wireframe, c.side = 3 === l ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : v[r.side], c.clipShadows = r.clipShadows, c.clippingPlanes = r.clippingPlanes, c.clipIntersection = r.clipIntersection, c.wireframeLinewidth = r.wireframeLinewidth, c.linewidth = r.linewidth, !0 === n.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(n.matrixWorld), c.nearDistance = o, c.farDistance = h), c
                }

                function D(object, r, o, h, l) {
                    if (!1 === object.visible) return;
                    if (object.layers.test(r.layers) && (object.isMesh || object.isLine || object.isPoints) && (object.castShadow || object.receiveShadow && 3 === l) && (!object.frustumCulled || n.intersectsObject(object))) {
                        object.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, object.matrixWorld);
                        const r = e.update(object),
                            n = object.material;
                        if (Array.isArray(n)) {
                            const e = r.groups;
                            for (let c = 0, d = e.length; c < d; c++) {
                                const d = e[c],
                                    m = n[d.materialIndex];
                                if (m && m.visible) {
                                    const e = C(object, r, m, h, o.near, o.far, l);
                                    t.renderBufferDirect(o, null, r, e, object, d)
                                }
                            }
                        } else if (n.visible) {
                            const e = C(object, r, n, h, o.near, o.far, l);
                            t.renderBufferDirect(o, null, r, e, object, null)
                        }
                    }
                    const c = object.children;
                    for (let i = 0, t = c.length; i < t; i++) D(c[i], r, o, h, l)
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, r, c) {
                    if (!1 === E.enabled) return;
                    if (!1 === E.autoUpdate && !1 === E.needsUpdate) return;
                    if (0 === e.length) return;
                    const d = t.getRenderTarget(),
                        m = t.getActiveCubeFace(),
                        v = t.getActiveMipmapLevel(),
                        x = t.state;
                    x.setBlending(0), x.buffers.color.setClear(1, 1, 1, 1), x.buffers.depth.setTest(!0), x.setScissorTest(!1);
                    for (let i = 0, d = e.length; i < d; i++) {
                        const d = e[i],
                            shadow = d.shadow;
                        if (void 0 === shadow) {
                            console.warn("THREE.WebGLShadowMap:", d, "has no shadow.");
                            continue
                        }
                        if (!1 === shadow.autoUpdate && !1 === shadow.needsUpdate) continue;
                        o.copy(shadow.mapSize);
                        const m = shadow.getFrameExtents();
                        if (o.multiply(m), h.copy(shadow.mapSize), (o.x > f || o.y > f) && (o.x > f && (h.x = Math.floor(f / m.x), o.x = h.x * m.x, shadow.mapSize.x = h.x), o.y > f && (h.y = Math.floor(f / m.y), o.y = h.y * m.y, shadow.mapSize.y = h.y)), null === shadow.map && !shadow.isPointLightShadow && 3 === this.type) {
                            const t = {
                                minFilter: _,
                                magFilter: _,
                                format: L
                            };
                            shadow.map = new ft(o.x, o.y, t), shadow.map.texture.name = d.name + ".shadowMap", shadow.mapPass = new ft(o.x, o.y, t), shadow.camera.updateProjectionMatrix()
                        }
                        if (null === shadow.map) {
                            const t = {
                                minFilter: y,
                                magFilter: y,
                                format: L
                            };
                            shadow.map = new ft(o.x, o.y, t), shadow.map.texture.name = d.name + ".shadowMap", shadow.camera.updateProjectionMatrix()
                        }
                        t.setRenderTarget(shadow.map), t.clear();
                        const v = shadow.getViewportCount();
                        for (let t = 0; t < v; t++) {
                            const e = shadow.getViewport(t);
                            l.set(h.x * e.x, h.y * e.y, h.x * e.z, h.y * e.w), x.viewport(l), shadow.updateMatrices(d, t), n = shadow.getFrustum(), D(r, c, shadow.camera, d, this.type)
                        }
                        shadow.isPointLightShadow || 3 !== this.type || T(shadow, c), shadow.needsUpdate = !1
                    }
                    E.needsUpdate = !1, t.setRenderTarget(d, m, v)
                }
            }

            function Zn(t, e, r) {
                const o = r.isWebGL2;
                const h = new function () {
                        let e = !1;
                        const r = new mt;
                        let n = null;
                        const o = new mt(0, 0, 0, 0);
                        return {
                            setMask: function (r) {
                                n === r || e || (t.colorMask(r, r, r, r), n = r)
                            },
                            setLocked: function (t) {
                                e = t
                            },
                            setClear: function (e, g, b, a, n) {
                                !0 === n && (e *= a, g *= a, b *= a), r.set(e, g, b, a), !1 === o.equals(r) && (t.clearColor(e, g, b, a), o.copy(r))
                            },
                            reset: function () {
                                e = !1, n = null, o.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    l = new function () {
                        let e = !1,
                            r = null,
                            n = null,
                            o = null;
                        return {
                            setTest: function (t) {
                                t ? j(2929) : X(2929)
                            },
                            setMask: function (n) {
                                r === n || e || (t.depthMask(n), r = n)
                            },
                            setFunc: function (e) {
                                if (n !== e) {
                                    if (e) switch (e) {
                                        case 0:
                                            t.depthFunc(512);
                                            break;
                                        case 1:
                                            t.depthFunc(519);
                                            break;
                                        case 2:
                                            t.depthFunc(513);
                                            break;
                                        case 3:
                                            t.depthFunc(515);
                                            break;
                                        case 4:
                                            t.depthFunc(514);
                                            break;
                                        case 5:
                                            t.depthFunc(518);
                                            break;
                                        case 6:
                                            t.depthFunc(516);
                                            break;
                                        case 7:
                                            t.depthFunc(517);
                                            break;
                                        default:
                                            t.depthFunc(515)
                                    } else t.depthFunc(515);
                                    n = e
                                }
                            },
                            setLocked: function (t) {
                                e = t
                            },
                            setClear: function (e) {
                                o !== e && (t.clearDepth(e), o = e)
                            },
                            reset: function () {
                                e = !1, r = null, n = null, o = null
                            }
                        }
                    },
                    c = new function () {
                        let e = !1,
                            r = null,
                            n = null,
                            o = null,
                            h = null,
                            l = null,
                            c = null,
                            d = null,
                            m = null;
                        return {
                            setTest: function (t) {
                                e || (t ? j(2960) : X(2960))
                            },
                            setMask: function (n) {
                                r === n || e || (t.stencilMask(n), r = n)
                            },
                            setFunc: function (e, r, l) {
                                n === e && o === r && h === l || (t.stencilFunc(e, r, l), n = e, o = r, h = l)
                            },
                            setOp: function (e, r, n) {
                                l === e && c === r && d === n || (t.stencilOp(e, r, n), l = e, c = r, d = n)
                            },
                            setLocked: function (t) {
                                e = t
                            },
                            setClear: function (e) {
                                m !== e && (t.clearStencil(e), m = e)
                            },
                            reset: function () {
                                e = !1, r = null, n = null, o = null, h = null, l = null, c = null, d = null, m = null
                            }
                        }
                    };
                let d = {},
                    m = null,
                    f = {},
                    y = null,
                    v = !1,
                    x = null,
                    _ = null,
                    M = null,
                    S = null,
                    w = null,
                    E = null,
                    T = null,
                    A = !1,
                    P = null,
                    C = null,
                    L = null,
                    D = null,
                    R = null;
                const I = t.getParameter(35661);
                let F = !1,
                    k = 0;
                const N = t.getParameter(7938); - 1 !== N.indexOf("WebGL") ? (k = parseFloat(/^WebGL (\d)/.exec(N)[1]), F = k >= 1) : -1 !== N.indexOf("OpenGL ES") && (k = parseFloat(/^OpenGL ES (\d)/.exec(N)[1]), F = k >= 2);
                let B = null,
                    z = {};
                const V = t.getParameter(3088),
                    O = t.getParameter(2978),
                    G = (new mt).fromArray(V),
                    H = (new mt).fromArray(O);

                function U(e, r, n) {
                    const data = new Uint8Array(4),
                        o = t.createTexture();
                    t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                    for (let i = 0; i < n; i++) t.texImage2D(r + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
                    return o
                }
                const W = {};

                function j(e) {
                    !0 !== d[e] && (t.enable(e), d[e] = !0)
                }

                function X(e) {
                    !1 !== d[e] && (t.disable(e), d[e] = !1)
                }
                W[3553] = U(3553, 3553, 1), W[34067] = U(34067, 34069, 6), h.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), j(2929), l.setFunc(3), K(!1), Q(1), j(2884), Z(0);
                const Y = {
                    [n]: 32774,
                    101: 32778,
                    102: 32779
                };
                if (o) Y[103] = 32775, Y[104] = 32776;
                else {
                    const t = e.get("EXT_blend_minmax");
                    null !== t && (Y[103] = t.MIN_EXT, Y[104] = t.MAX_EXT)
                }
                const J = {
                    200: 0,
                    201: 1,
                    202: 768,
                    204: 770,
                    210: 776,
                    208: 774,
                    206: 772,
                    203: 769,
                    205: 771,
                    209: 775,
                    207: 773
                };

                function Z(e, r, o, h, l, c, d, m) {
                    if (0 !== e) {
                        if (!1 === v && (j(3042), v = !0), 5 === e) l = l || r, c = c || o, d = d || h, r === _ && l === w || (t.blendEquationSeparate(Y[r], Y[l]), _ = r, w = l), o === M && h === S && c === E && d === T || (t.blendFuncSeparate(J[o], J[h], J[c], J[d]), M = o, S = h, E = c, T = d), x = e, A = null;
                        else if (e !== x || m !== A) {
                            if (_ === n && w === n || (t.blendEquation(32774), _ = n, w = n), m) switch (e) {
                                case 1:
                                    t.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case 2:
                                    t.blendFunc(1, 1);
                                    break;
                                case 3:
                                    t.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case 4:
                                    t.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            } else switch (e) {
                                case 1:
                                    t.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case 2:
                                    t.blendFunc(770, 1);
                                    break;
                                case 3:
                                    t.blendFunc(0, 769);
                                    break;
                                case 4:
                                    t.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                            M = null, S = null, E = null, T = null, x = e, A = m
                        }
                    } else !0 === v && (X(3042), v = !1)
                }

                function K(e) {
                    P !== e && (e ? t.frontFace(2304) : t.frontFace(2305), P = e)
                }

                function Q(e) {
                    0 !== e ? (j(2884), e !== C && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : X(2884), C = e
                }

                function $(e, r, n) {
                    e ? (j(32823), D === r && R === n || (t.polygonOffset(r, n), D = r, R = n)) : X(32823)
                }

                function tt(e) {
                    void 0 === e && (e = 33984 + I - 1), B !== e && (t.activeTexture(e), B = e)
                }
                return {
                    buffers: {
                        color: h,
                        depth: l,
                        stencil: c
                    },
                    enable: j,
                    disable: X,
                    bindFramebuffer: function (e, r) {
                        return null === r && null !== m && (r = m), f[e] !== r && (t.bindFramebuffer(e, r), f[e] = r, o && (36009 === e && (f[36160] = r), 36160 === e && (f[36009] = r)), !0)
                    },
                    bindXRFramebuffer: function (e) {
                        e !== m && (t.bindFramebuffer(36160, e), m = e)
                    },
                    useProgram: function (e) {
                        return y !== e && (t.useProgram(e), y = e, !0)
                    },
                    setBlending: Z,
                    setMaterial: function (t, e) {
                        2 === t.side ? X(2884) : j(2884);
                        let r = 1 === t.side;
                        e && (r = !r), K(r), 1 === t.blending && !1 === t.transparent ? Z(0) : Z(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), l.setFunc(t.depthFunc), l.setTest(t.depthTest), l.setMask(t.depthWrite), h.setMask(t.colorWrite);
                        const n = t.stencilWrite;
                        c.setTest(n), n && (c.setMask(t.stencilWriteMask), c.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), c.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), $(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? j(32926) : X(32926)
                    },
                    setFlipSided: K,
                    setCullFace: Q,
                    setLineWidth: function (e) {
                        e !== L && (F && t.lineWidth(e), L = e)
                    },
                    setPolygonOffset: $,
                    setScissorTest: function (t) {
                        t ? j(3089) : X(3089)
                    },
                    activeTexture: tt,
                    bindTexture: function (e, r) {
                        null === B && tt();
                        let n = z[B];
                        void 0 === n && (n = {
                            type: void 0,
                            texture: void 0
                        }, z[B] = n), n.type === e && n.texture === r || (t.bindTexture(e, r || W[e]), n.type = e, n.texture = r)
                    },
                    unbindTexture: function () {
                        const e = z[B];
                        void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                    },
                    compressedTexImage2D: function () {
                        try {
                            t.compressedTexImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage2D: function () {
                        try {
                            t.texImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage3D: function () {
                        try {
                            t.texImage3D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    scissor: function (e) {
                        !1 === G.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), G.copy(e))
                    },
                    viewport: function (e) {
                        !1 === H.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), H.copy(e))
                    },
                    reset: function () {
                        t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === o && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), d = {}, B = null, z = {}, m = null, f = {}, y = null, v = !1, x = null, _ = null, M = null, S = null, w = null, E = null, T = null, A = !1, P = null, C = null, L = null, D = null, R = null, G.set(0, 0, t.canvas.width, t.canvas.height), H.set(0, 0, t.canvas.width, t.canvas.height), h.reset(), l.reset(), c.reset()
                    }
                }
            }

            function Kn(t, e, r, n, o, h, l) {
                const c = o.isWebGL2,
                    S = o.maxTextures,
                    I = o.maxCubemapSize,
                    F = o.maxTextureSize,
                    k = o.maxSamples,
                    N = new WeakMap;
                let B, z = !1;
                try {
                    z = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (t) {}

                function V(t, e) {
                    return z ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                }

                function O(image, t, e, r) {
                    let n = 1;
                    if ((image.width > r || image.height > r) && (n = r / Math.max(image.width, image.height)), n < 1 || !0 === t) {
                        if ("undefined" != typeof HTMLImageElement && image instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && image instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && image instanceof ImageBitmap) {
                            const r = t ? st : Math.floor,
                                o = r(n * image.width),
                                h = r(n * image.height);
                            void 0 === B && (B = V(o, h));
                            const canvas = e ? V(o, h) : B;
                            canvas.width = o, canvas.height = h;
                            return canvas.getContext("2d").drawImage(image, 0, 0, o, h), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + o + "x" + h + ")."), canvas
                        }
                        return "data" in image && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ")."), image
                    }
                    return image
                }

                function G(image) {
                    return nt(image.width) && nt(image.height)
                }

                function H(t, e) {
                    return t.generateMipmaps && e && t.minFilter !== y && t.minFilter !== _
                }

                function U(e, r, o, h, l = 1) {
                    t.generateMipmap(e);
                    n.get(r).__maxMipLevel = Math.log2(Math.max(o, h, l))
                }

                function W(r, n, o) {
                    if (!1 === c) return n;
                    if (null !== r) {
                        if (void 0 !== t[r]) return t[r];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + r + "'")
                    }
                    let h = n;
                    return 6403 === n && (5126 === o && (h = 33326), 5131 === o && (h = 33325), 5121 === o && (h = 33321)), 6407 === n && (5126 === o && (h = 34837), 5131 === o && (h = 34843), 5121 === o && (h = 32849)), 6408 === n && (5126 === o && (h = 34836), 5131 === o && (h = 34842), 5121 === o && (h = 32856)), 33325 !== h && 33326 !== h && 34842 !== h && 34836 !== h || e.get("EXT_color_buffer_float"), h
                }

                function j(t) {
                    return t === y || t === v || t === x ? 9728 : 9729
                }

                function X(e) {
                    const r = e.target;
                    r.removeEventListener("dispose", X),
                        function (e) {
                            const r = n.get(e);
                            if (void 0 === r.__webglInit) return;
                            t.deleteTexture(r.__webglTexture), n.remove(e)
                        }(r), r.isVideoTexture && N.delete(r), l.memory.textures--
                }

                function Y(e) {
                    const r = e.target;
                    r.removeEventListener("dispose", Y),
                        function (e) {
                            const r = e.texture,
                                o = n.get(e),
                                h = n.get(r);
                            if (!e) return;
                            void 0 !== h.__webglTexture && (t.deleteTexture(h.__webglTexture), l.memory.textures--);
                            e.depthTexture && e.depthTexture.dispose();
                            if (e.isWebGLCubeRenderTarget)
                                for (let i = 0; i < 6; i++) t.deleteFramebuffer(o.__webglFramebuffer[i]), o.__webglDepthbuffer && t.deleteRenderbuffer(o.__webglDepthbuffer[i]);
                            else t.deleteFramebuffer(o.__webglFramebuffer), o.__webglDepthbuffer && t.deleteRenderbuffer(o.__webglDepthbuffer), o.__webglMultisampledFramebuffer && t.deleteFramebuffer(o.__webglMultisampledFramebuffer), o.__webglColorRenderbuffer && t.deleteRenderbuffer(o.__webglColorRenderbuffer), o.__webglDepthRenderbuffer && t.deleteRenderbuffer(o.__webglDepthRenderbuffer);
                            if (e.isWebGLMultipleRenderTargets)
                                for (let i = 0, e = r.length; i < e; i++) {
                                    const e = n.get(r[i]);
                                    e.__webglTexture && (t.deleteTexture(e.__webglTexture), l.memory.textures--), n.remove(r[i])
                                }
                            n.remove(r), n.remove(e)
                        }(r)
                }
                let J = 0;

                function Z(t, slot) {
                    const e = n.get(t);
                    if (t.isVideoTexture && function (t) {
                            const e = l.render.frame;
                            N.get(t) !== e && (N.set(t, e), t.update())
                        }(t), t.version > 0 && e.__version !== t.version) {
                        const image = t.image;
                        if (void 0 === image) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== image.complete) return void it(e, t, slot);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    r.activeTexture(33984 + slot), r.bindTexture(3553, e.__webglTexture)
                }

                function K(e, slot) {
                    const o = n.get(e);
                    e.version > 0 && o.__version !== e.version ? function (e, n, slot) {
                        if (6 !== n.image.length) return;
                        et(e, n), r.activeTexture(33984 + slot), r.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), t.pixelStorei(37443, 0);
                        const o = n && (n.isCompressedTexture || n.image[0].isCompressedTexture),
                            l = n.image[0] && n.image[0].isDataTexture,
                            d = [];
                        for (let i = 0; i < 6; i++) d[i] = o || l ? l ? n.image[i].image : n.image[i] : O(n.image[i], !1, !0, I);
                        const image = d[0],
                            m = G(image) || c,
                            f = h.convert(n.format),
                            y = h.convert(n.type),
                            v = W(n.internalFormat, f, y);
                        let x;
                        if (tt(34067, n, m), o) {
                            for (let i = 0; i < 6; i++) {
                                x = d[i].mipmaps;
                                for (let t = 0; t < x.length; t++) {
                                    const e = x[t];
                                    n.format !== L && n.format !== C ? null !== f ? r.compressedTexImage2D(34069 + i, t, v, e.width, e.height, 0, e.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : r.texImage2D(34069 + i, t, v, e.width, e.height, 0, f, y, e.data)
                                }
                            }
                            e.__maxMipLevel = x.length - 1
                        } else {
                            x = n.mipmaps;
                            for (let i = 0; i < 6; i++)
                                if (l) {
                                    r.texImage2D(34069 + i, 0, v, d[i].width, d[i].height, 0, f, y, d[i].data);
                                    for (let t = 0; t < x.length; t++) {
                                        const e = x[t].image[i].image;
                                        r.texImage2D(34069 + i, t + 1, v, e.width, e.height, 0, f, y, e.data)
                                    }
                                } else {
                                    r.texImage2D(34069 + i, 0, v, f, y, d[i]);
                                    for (let t = 0; t < x.length; t++) {
                                        const e = x[t];
                                        r.texImage2D(34069 + i, t + 1, v, f, y, e.image[i])
                                    }
                                } e.__maxMipLevel = x.length
                        }
                        H(n, m) && U(34067, n, image.width, image.height);
                        e.__version = n.version, n.onUpdate && n.onUpdate(n)
                    }(o, e, slot) : (r.activeTexture(33984 + slot), r.bindTexture(34067, o.__webglTexture))
                }
                const Q = {
                        [d]: 10497,
                        [m]: 33071,
                        [f]: 33648
                    },
                    $ = {
                        [y]: 9728,
                        [v]: 9984,
                        [x]: 9986,
                        [_]: 9729,
                        1007: 9985,
                        [M]: 9987
                    };

                function tt(r, h, l) {
                    if (l ? (t.texParameteri(r, 10242, Q[h.wrapS]), t.texParameteri(r, 10243, Q[h.wrapT]), 32879 !== r && 35866 !== r || t.texParameteri(r, 32882, Q[h.wrapR]), t.texParameteri(r, 10240, $[h.magFilter]), t.texParameteri(r, 10241, $[h.minFilter])) : (t.texParameteri(r, 10242, 33071), t.texParameteri(r, 10243, 33071), 32879 !== r && 35866 !== r || t.texParameteri(r, 32882, 33071), h.wrapS === m && h.wrapT === m || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(r, 10240, j(h.magFilter)), t.texParameteri(r, 10241, j(h.minFilter)), h.minFilter !== y && h.minFilter !== _ && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                        const l = e.get("EXT_texture_filter_anisotropic");
                        if (h.type === T && !1 === e.has("OES_texture_float_linear")) return;
                        if (!1 === c && h.type === A && !1 === e.has("OES_texture_half_float_linear")) return;
                        (h.anisotropy > 1 || n.get(h).__currentAnisotropy) && (t.texParameterf(r, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(h.anisotropy, o.getMaxAnisotropy())), n.get(h).__currentAnisotropy = h.anisotropy)
                    }
                }

                function et(e, r) {
                    void 0 === e.__webglInit && (e.__webglInit = !0, r.addEventListener("dispose", X), e.__webglTexture = t.createTexture(), l.memory.textures++)
                }

                function it(e, n, slot) {
                    let o = 3553;
                    n.isDataTexture2DArray && (o = 35866), n.isDataTexture3D && (o = 32879), et(e, n), r.activeTexture(33984 + slot), r.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), t.pixelStorei(37443, 0);
                    const l = function (t) {
                            return !c && (t.wrapS !== m || t.wrapT !== m || t.minFilter !== y && t.minFilter !== _)
                        }(n) && !1 === G(n.image),
                        image = O(n.image, l, !1, F),
                        d = G(image) || c,
                        f = h.convert(n.format);
                    let v, x = h.convert(n.type),
                        M = W(n.internalFormat, f, x);
                    tt(o, n, d);
                    const S = n.mipmaps;
                    if (n.isDepthTexture) M = 6402, c ? M = n.type === T ? 36012 : n.type === E ? 33190 : n.type === P ? 35056 : 33189 : n.type === T && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), n.format === D && 6402 === M && n.type !== w && n.type !== E && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = w, x = h.convert(n.type)), n.format === R && 6402 === M && (M = 34041, n.type !== P && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = P, x = h.convert(n.type))), r.texImage2D(3553, 0, M, image.width, image.height, 0, f, x, null);
                    else if (n.isDataTexture)
                        if (S.length > 0 && d) {
                            for (let i = 0, t = S.length; i < t; i++) v = S[i], r.texImage2D(3553, i, M, v.width, v.height, 0, f, x, v.data);
                            n.generateMipmaps = !1, e.__maxMipLevel = S.length - 1
                        } else r.texImage2D(3553, 0, M, image.width, image.height, 0, f, x, image.data), e.__maxMipLevel = 0;
                    else if (n.isCompressedTexture) {
                        for (let i = 0, t = S.length; i < t; i++) v = S[i], n.format !== L && n.format !== C ? null !== f ? r.compressedTexImage2D(3553, i, M, v.width, v.height, 0, v.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : r.texImage2D(3553, i, M, v.width, v.height, 0, f, x, v.data);
                        e.__maxMipLevel = S.length - 1
                    } else if (n.isDataTexture2DArray) r.texImage3D(35866, 0, M, image.width, image.height, image.depth, 0, f, x, image.data), e.__maxMipLevel = 0;
                    else if (n.isDataTexture3D) r.texImage3D(32879, 0, M, image.width, image.height, image.depth, 0, f, x, image.data), e.__maxMipLevel = 0;
                    else if (S.length > 0 && d) {
                        for (let i = 0, t = S.length; i < t; i++) v = S[i], r.texImage2D(3553, i, M, f, x, v);
                        n.generateMipmaps = !1, e.__maxMipLevel = S.length - 1
                    } else r.texImage2D(3553, 0, M, f, x, image), e.__maxMipLevel = 0;
                    H(n, d) && U(o, n, image.width, image.height), e.__version = n.version, n.onUpdate && n.onUpdate(n)
                }

                function at(e, o, l, c, d) {
                    const m = h.convert(l.format),
                        f = h.convert(l.type),
                        y = W(l.internalFormat, m, f);
                    32879 === d || 35866 === d ? r.texImage3D(d, 0, y, o.width, o.height, o.depth, 0, m, f, null) : r.texImage2D(d, 0, y, o.width, o.height, 0, m, f, null), r.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, c, d, n.get(l).__webglTexture, 0), r.bindFramebuffer(36160, null)
                }

                function ot(e, r, n) {
                    if (t.bindRenderbuffer(36161, e), r.depthBuffer && !r.stencilBuffer) {
                        let o = 33189;
                        if (n) {
                            const e = r.depthTexture;
                            e && e.isDepthTexture && (e.type === T ? o = 36012 : e.type === E && (o = 33190));
                            const n = lt(r);
                            t.renderbufferStorageMultisample(36161, n, o, r.width, r.height)
                        } else t.renderbufferStorage(36161, o, r.width, r.height);
                        t.framebufferRenderbuffer(36160, 36096, 36161, e)
                    } else if (r.depthBuffer && r.stencilBuffer) {
                        if (n) {
                            const e = lt(r);
                            t.renderbufferStorageMultisample(36161, e, 35056, r.width, r.height)
                        } else t.renderbufferStorage(36161, 34041, r.width, r.height);
                        t.framebufferRenderbuffer(36160, 33306, 36161, e)
                    } else {
                        const e = !0 === r.isWebGLMultipleRenderTargets ? r.texture[0] : r.texture,
                            o = h.convert(e.format),
                            l = h.convert(e.type),
                            c = W(e.internalFormat, o, l);
                        if (n) {
                            const e = lt(r);
                            t.renderbufferStorageMultisample(36161, e, c, r.width, r.height)
                        } else t.renderbufferStorage(36161, c, r.width, r.height)
                    }
                    t.bindRenderbuffer(36161, null)
                }

                function ht(e) {
                    const o = n.get(e),
                        h = !0 === e.isWebGLCubeRenderTarget;
                    if (e.depthTexture) {
                        if (h) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function (e, o) {
                            if (o && o.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                            if (r.bindFramebuffer(36160, e), !o.depthTexture || !o.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            n.get(o.depthTexture).__webglTexture && o.depthTexture.image.width === o.width && o.depthTexture.image.height === o.height || (o.depthTexture.image.width = o.width, o.depthTexture.image.height = o.height, o.depthTexture.needsUpdate = !0), Z(o.depthTexture, 0);
                            const h = n.get(o.depthTexture).__webglTexture;
                            if (o.depthTexture.format === D) t.framebufferTexture2D(36160, 36096, 3553, h, 0);
                            else {
                                if (o.depthTexture.format !== R) throw new Error("Unknown depthTexture format");
                                t.framebufferTexture2D(36160, 33306, 3553, h, 0)
                            }
                        }(o.__webglFramebuffer, e)
                    } else if (h) {
                        o.__webglDepthbuffer = [];
                        for (let i = 0; i < 6; i++) r.bindFramebuffer(36160, o.__webglFramebuffer[i]), o.__webglDepthbuffer[i] = t.createRenderbuffer(), ot(o.__webglDepthbuffer[i], e, !1)
                    } else r.bindFramebuffer(36160, o.__webglFramebuffer), o.__webglDepthbuffer = t.createRenderbuffer(), ot(o.__webglDepthbuffer, e, !1);
                    r.bindFramebuffer(36160, null)
                }

                function lt(t) {
                    return c && t.isWebGLMultisampleRenderTarget ? Math.min(k, t.samples) : 0
                }
                let ct = !1,
                    pt = !1;
                this.allocateTextureUnit = function () {
                    const t = J;
                    return t >= S && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + S), J += 1, t
                }, this.resetTextureUnits = function () {
                    J = 0
                }, this.setTexture2D = Z, this.setTexture2DArray = function (t, slot) {
                    const e = n.get(t);
                    t.version > 0 && e.__version !== t.version ? it(e, t, slot) : (r.activeTexture(33984 + slot), r.bindTexture(35866, e.__webglTexture))
                }, this.setTexture3D = function (t, slot) {
                    const e = n.get(t);
                    t.version > 0 && e.__version !== t.version ? it(e, t, slot) : (r.activeTexture(33984 + slot), r.bindTexture(32879, e.__webglTexture))
                }, this.setTextureCube = K, this.setupRenderTarget = function (e) {
                    const d = e.texture,
                        m = n.get(e),
                        f = n.get(d);
                    e.addEventListener("dispose", Y), !0 !== e.isWebGLMultipleRenderTargets && (f.__webglTexture = t.createTexture(), f.__version = d.version, l.memory.textures++);
                    const y = !0 === e.isWebGLCubeRenderTarget,
                        v = !0 === e.isWebGLMultipleRenderTargets,
                        x = !0 === e.isWebGLMultisampleRenderTarget,
                        _ = d.isDataTexture3D || d.isDataTexture2DArray,
                        M = G(e) || c;
                    if (!c || d.format !== C || d.type !== T && d.type !== A || (d.format = L, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), y) {
                        m.__webglFramebuffer = [];
                        for (let i = 0; i < 6; i++) m.__webglFramebuffer[i] = t.createFramebuffer()
                    } else if (m.__webglFramebuffer = t.createFramebuffer(), v)
                        if (o.drawBuffers) {
                            const r = e.texture;
                            for (let i = 0, e = r.length; i < e; i++) {
                                const e = n.get(r[i]);
                                void 0 === e.__webglTexture && (e.__webglTexture = t.createTexture(), l.memory.textures++)
                            }
                        } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    else if (x)
                        if (c) {
                            m.__webglMultisampledFramebuffer = t.createFramebuffer(), m.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, m.__webglColorRenderbuffer);
                            const n = h.convert(d.format),
                                o = h.convert(d.type),
                                l = W(d.internalFormat, n, o),
                                c = lt(e);
                            t.renderbufferStorageMultisample(36161, c, l, e.width, e.height), r.bindFramebuffer(36160, m.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, m.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (m.__webglDepthRenderbuffer = t.createRenderbuffer(), ot(m.__webglDepthRenderbuffer, e, !0)), r.bindFramebuffer(36160, null)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                    if (y) {
                        r.bindTexture(34067, f.__webglTexture), tt(34067, d, M);
                        for (let i = 0; i < 6; i++) at(m.__webglFramebuffer[i], e, d, 36064, 34069 + i);
                        H(d, M) && U(34067, d, e.width, e.height), r.bindTexture(34067, null)
                    } else if (v) {
                        const t = e.texture;
                        for (let i = 0, o = t.length; i < o; i++) {
                            const o = t[i],
                                h = n.get(o);
                            r.bindTexture(3553, h.__webglTexture), tt(3553, o, M), at(m.__webglFramebuffer, e, o, 36064 + i, 3553), H(o, M) && U(3553, o, e.width, e.height)
                        }
                        r.bindTexture(3553, null)
                    } else {
                        let t = 3553;
                        if (_)
                            if (c) {
                                t = d.isDataTexture3D ? 32879 : 35866
                            } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
                        r.bindTexture(t, f.__webglTexture), tt(t, d, M), at(m.__webglFramebuffer, e, d, 36064, t), H(d, M) && U(t, d, e.width, e.height, e.depth), r.bindTexture(t, null)
                    }
                    e.depthBuffer && ht(e)
                }, this.updateRenderTargetMipmap = function (t) {
                    const e = G(t) || c,
                        o = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                    for (let i = 0, h = o.length; i < h; i++) {
                        const h = o[i];
                        if (H(h, e)) {
                            const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                                o = n.get(h).__webglTexture;
                            r.bindTexture(e, o), U(e, h, t.width, t.height), r.bindTexture(e, null)
                        }
                    }
                }, this.updateMultisampleRenderTarget = function (e) {
                    if (e.isWebGLMultisampleRenderTarget)
                        if (c) {
                            const o = e.width,
                                h = e.height;
                            let mask = 16384;
                            e.depthBuffer && (mask |= 256), e.stencilBuffer && (mask |= 1024);
                            const l = n.get(e);
                            r.bindFramebuffer(36008, l.__webglMultisampledFramebuffer), r.bindFramebuffer(36009, l.__webglFramebuffer), t.blitFramebuffer(0, 0, o, h, 0, 0, o, h, mask, 9728), r.bindFramebuffer(36008, null), r.bindFramebuffer(36009, l.__webglMultisampledFramebuffer)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                }, this.safeSetTexture2D = function (t, slot) {
                    t && t.isWebGLRenderTarget && (!1 === ct && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), ct = !0), t = t.texture), Z(t, slot)
                }, this.safeSetTextureCube = function (t, slot) {
                    t && t.isWebGLCubeRenderTarget && (!1 === pt && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), pt = !0), t = t.texture), K(t, slot)
                }
            }

            function Qn(t, e, r) {
                const n = r.isWebGL2;
                return {
                    convert: function (p) {
                        let t;
                        if (p === S) return 5121;
                        if (1017 === p) return 32819;
                        if (1018 === p) return 32820;
                        if (1019 === p) return 33635;
                        if (1010 === p) return 5120;
                        if (1011 === p) return 5122;
                        if (p === w) return 5123;
                        if (1013 === p) return 5124;
                        if (p === E) return 5125;
                        if (p === T) return 5126;
                        if (p === A) return n ? 5131 : (t = e.get("OES_texture_half_float"), null !== t ? t.HALF_FLOAT_OES : null);
                        if (1021 === p) return 6406;
                        if (p === C) return 6407;
                        if (p === L) return 6408;
                        if (1024 === p) return 6409;
                        if (1025 === p) return 6410;
                        if (p === D) return 6402;
                        if (p === R) return 34041;
                        if (1028 === p) return 6403;
                        if (1029 === p) return 36244;
                        if (1030 === p) return 33319;
                        if (1031 === p) return 33320;
                        if (1032 === p) return 36248;
                        if (1033 === p) return 36249;
                        if (33776 === p || 33777 === p || 33778 === p || 33779 === p) {
                            if (t = e.get("WEBGL_compressed_texture_s3tc"), null === t) return null;
                            if (33776 === p) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (33777 === p) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (33778 === p) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (33779 === p) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if (35840 === p || 35841 === p || 35842 === p || 35843 === p) {
                            if (t = e.get("WEBGL_compressed_texture_pvrtc"), null === t) return null;
                            if (35840 === p) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (35841 === p) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (35842 === p) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (35843 === p) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (36196 === p) return t = e.get("WEBGL_compressed_texture_etc1"), null !== t ? t.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if ((37492 === p || 37496 === p) && (t = e.get("WEBGL_compressed_texture_etc"), null !== t)) {
                            if (37492 === p) return t.COMPRESSED_RGB8_ETC2;
                            if (37496 === p) return t.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        return 37808 === p || 37809 === p || 37810 === p || 37811 === p || 37812 === p || 37813 === p || 37814 === p || 37815 === p || 37816 === p || 37817 === p || 37818 === p || 37819 === p || 37820 === p || 37821 === p || 37840 === p || 37841 === p || 37842 === p || 37843 === p || 37844 === p || 37845 === p || 37846 === p || 37847 === p || 37848 === p || 37849 === p || 37850 === p || 37851 === p || 37852 === p || 37853 === p ? (t = e.get("WEBGL_compressed_texture_astc"), null !== t ? p : null) : 36492 === p ? (t = e.get("EXT_texture_compression_bptc"), null !== t ? p : null) : p === P ? n ? 34042 : (t = e.get("WEBGL_depth_texture"), null !== t ? t.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                    }
                }
            }
            class $n extends Ci {
                constructor(t = []) {
                    super(), this.cameras = t
                }
            }
            $n.prototype.isArrayCamera = !0;
            class ts extends _e {
                constructor() {
                    super(), this.type = "Group"
                }
            }
            ts.prototype.isGroup = !0;
            const es = {
                type: "move"
            };
            class is {
                constructor() {
                    this._targetRay = null, this._grip = null, this._hand = null
                }
                getHandSpace() {
                    return null === this._hand && (this._hand = new ts, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                        pinching: !1
                    }), this._hand
                }
                getTargetRaySpace() {
                    return null === this._targetRay && (this._targetRay = new ts, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new vt, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new vt), this._targetRay
                }
                getGripSpace() {
                    return null === this._grip && (this._grip = new ts, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new vt, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new vt), this._grip
                }
                dispatchEvent(t) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                }
                disconnect(t) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: t
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                }
                update(t, e, r) {
                    let n = null,
                        o = null,
                        h = null;
                    const l = this._targetRay,
                        c = this._grip,
                        d = this._hand;
                    if (t && "visible-blurred" !== e.session.visibilityState)
                        if (null !== l && (n = e.getPose(t.targetRaySpace, r), null !== n && (l.matrix.fromArray(n.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), n.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(n.linearVelocity)) : l.hasLinearVelocity = !1, n.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(n.angularVelocity)) : l.hasAngularVelocity = !1, this.dispatchEvent(es))), d && t.hand) {
                            h = !0;
                            for (const n of t.hand.values()) {
                                const t = e.getJointPose(n, r);
                                if (void 0 === d.joints[n.jointName]) {
                                    const t = new ts;
                                    t.matrixAutoUpdate = !1, t.visible = !1, d.joints[n.jointName] = t, d.add(t)
                                }
                                const o = d.joints[n.jointName];
                                null !== t && (o.matrix.fromArray(t.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.jointRadius = t.radius), o.visible = null !== t
                            }
                            const n = d.joints["index-finger-tip"],
                                o = d.joints["thumb-tip"],
                                l = n.position.distanceTo(o.position),
                                c = .02,
                                m = .005;
                            d.inputState.pinching && l > c + m ? (d.inputState.pinching = !1, this.dispatchEvent({
                                type: "pinchend",
                                handedness: t.handedness,
                                target: this
                            })) : !d.inputState.pinching && l <= c - m && (d.inputState.pinching = !0, this.dispatchEvent({
                                type: "pinchstart",
                                handedness: t.handedness,
                                target: this
                            }))
                        } else null !== c && t.gripSpace && (o = e.getPose(t.gripSpace, r), null !== o && (c.matrix.fromArray(o.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), o.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(o.linearVelocity)) : c.hasLinearVelocity = !1, o.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(o.angularVelocity)) : c.hasAngularVelocity = !1));
                    return null !== l && (l.visible = null !== n), null !== c && (c.visible = null !== o), null !== d && (d.visible = null !== h), this
                }
            }
            class rs extends J {
                constructor(t, e) {
                    super();
                    const r = this,
                        n = t.state;
                    let o = null,
                        h = 1,
                        l = null,
                        c = "local-floor",
                        d = null,
                        m = null,
                        f = null,
                        y = null;
                    const v = [],
                        x = new Map,
                        _ = new Ci;
                    _.layers.enable(1), _.viewport = new mt;
                    const M = new Ci;
                    M.layers.enable(2), M.viewport = new mt;
                    const S = [_, M],
                        w = new $n;
                    w.layers.enable(1), w.layers.enable(2);
                    let E = null,
                        T = null;

                    function A(t) {
                        const e = x.get(t.inputSource);
                        e && e.dispatchEvent({
                            type: t.type,
                            data: t.inputSource
                        })
                    }

                    function P() {
                        x.forEach((function (t, e) {
                            t.disconnect(e)
                        })), x.clear(), E = null, T = null, n.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), F.stop(), r.isPresenting = !1, r.dispatchEvent({
                            type: "sessionend"
                        })
                    }

                    function C(t) {
                        const e = o.inputSources;
                        for (let i = 0; i < v.length; i++) x.set(e[i], v[i]);
                        for (let i = 0; i < t.removed.length; i++) {
                            const e = t.removed[i],
                                r = x.get(e);
                            r && (r.dispatchEvent({
                                type: "disconnected",
                                data: e
                            }), x.delete(e))
                        }
                        for (let i = 0; i < t.added.length; i++) {
                            const e = t.added[i],
                                r = x.get(e);
                            r && r.dispatchEvent({
                                type: "connected",
                                data: e
                            })
                        }
                    }
                    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (t) {
                        let e = v[t];
                        return void 0 === e && (e = new is, v[t] = e), e.getTargetRaySpace()
                    }, this.getControllerGrip = function (t) {
                        let e = v[t];
                        return void 0 === e && (e = new is, v[t] = e), e.getGripSpace()
                    }, this.getHand = function (t) {
                        let e = v[t];
                        return void 0 === e && (e = new is, v[t] = e), e.getHandSpace()
                    }, this.setFramebufferScaleFactor = function (t) {
                        h = t, !0 === r.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                    }, this.setReferenceSpaceType = function (t) {
                        c = t, !0 === r.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                    }, this.getReferenceSpace = function () {
                        return l
                    }, this.getSession = function () {
                        return o
                    }, this.setSession = async function (t) {
                        if (o = t, null !== o) {
                            o.addEventListener("select", A), o.addEventListener("selectstart", A), o.addEventListener("selectend", A), o.addEventListener("squeeze", A), o.addEventListener("squeezestart", A), o.addEventListener("squeezeend", A), o.addEventListener("end", P), o.addEventListener("inputsourceschange", C);
                            const t = e.getContextAttributes();
                            if (!0 !== t.xrCompatible && await e.makeXRCompatible(), void 0 === o.renderState.layers) {
                                const r = {
                                        antialias: t.antialias,
                                        alpha: t.alpha,
                                        depth: t.depth,
                                        stencil: t.stencil,
                                        framebufferScaleFactor: h
                                    },
                                    n = new XRWebGLLayer(o, e, r);
                                o.updateRenderState({
                                    baseLayer: n
                                })
                            } else {
                                let r = 0;
                                t.depth && (r = t.stencil ? 34041 : 6402);
                                const n = {
                                    colorFormat: t.alpha ? 6408 : 6407,
                                    depthFormat: r,
                                    scaleFactor: h
                                };
                                m = new XRWebGLBinding(o, e), y = m.createProjectionLayer(n), f = e.createFramebuffer(), o.updateRenderState({
                                    layers: [y]
                                })
                            }
                            l = await o.requestReferenceSpace(c), F.setContext(o), F.start(), r.isPresenting = !0, r.dispatchEvent({
                                type: "sessionstart"
                            })
                        }
                    };
                    const L = new vt,
                        D = new vt;

                    function R(t, e) {
                        null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                    }
                    this.updateCamera = function (t) {
                        if (null === o) return;
                        w.near = M.near = _.near = t.near, w.far = M.far = _.far = t.far, E === w.near && T === w.far || (o.updateRenderState({
                            depthNear: w.near,
                            depthFar: w.far
                        }), E = w.near, T = w.far);
                        const e = t.parent,
                            r = w.cameras;
                        R(w, e);
                        for (let i = 0; i < r.length; i++) R(r[i], e);
                        w.matrixWorld.decompose(w.position, w.quaternion, w.scale), t.position.copy(w.position), t.quaternion.copy(w.quaternion), t.scale.copy(w.scale), t.matrix.copy(w.matrix), t.matrixWorld.copy(w.matrixWorld);
                        const n = t.children;
                        for (let i = 0, t = n.length; i < t; i++) n[i].updateMatrixWorld(!0);
                        2 === r.length ? function (t, e, r) {
                            L.setFromMatrixPosition(e.matrixWorld), D.setFromMatrixPosition(r.matrixWorld);
                            const n = L.distanceTo(D),
                                o = e.projectionMatrix.elements,
                                h = r.projectionMatrix.elements,
                                l = o[14] / (o[10] - 1),
                                c = o[14] / (o[10] + 1),
                                d = (o[9] + 1) / o[5],
                                m = (o[9] - 1) / o[5],
                                f = (o[8] - 1) / o[0],
                                y = (h[8] + 1) / h[0],
                                v = l * f,
                                x = l * y,
                                _ = n / (-f + y),
                                M = _ * -f;
                            e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(M), t.translateZ(_), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                            const S = l + _,
                                w = c + _,
                                E = v - M,
                                T = x + (n - M),
                                A = d * c / w * S,
                                P = m * c / w * S;
                            t.projectionMatrix.makePerspective(E, T, A, P, S, w)
                        }(w, _, M) : w.projectionMatrix.copy(_.projectionMatrix)
                    }, this.getCamera = function () {
                        return w
                    };
                    let I = null;
                    const F = new Gi;
                    F.setAnimationLoop((function (time, t) {
                        if (d = t.getViewerPose(l), null !== d) {
                            const t = d.views,
                                r = o.renderState.baseLayer;
                            void 0 === o.renderState.layers && n.bindXRFramebuffer(r.framebuffer);
                            let h = !1;
                            t.length !== w.cameras.length && (w.cameras.length = 0, h = !0);
                            for (let i = 0; i < t.length; i++) {
                                const view = t[i];
                                let l = null;
                                if (void 0 === o.renderState.layers) l = r.getViewport(view);
                                else {
                                    const t = m.getViewSubImage(y, view);
                                    n.bindXRFramebuffer(f), e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0), void 0 !== t.depthStencilTexture && e.framebufferTexture2D(36160, 36096, 3553, t.depthStencilTexture, 0), l = t.viewport
                                }
                                const c = S[i];
                                c.matrix.fromArray(view.transform.matrix), c.projectionMatrix.fromArray(view.projectionMatrix), c.viewport.set(l.x, l.y, l.width, l.height), 0 === i && w.matrix.copy(c.matrix), !0 === h && w.cameras.push(c)
                            }
                        }
                        const r = o.inputSources;
                        for (let i = 0; i < v.length; i++) {
                            const e = v[i],
                                n = r[i];
                            e.update(n, t, l)
                        }
                        I && I(time, t)
                    })), this.setAnimationLoop = function (t) {
                        I = t
                    }, this.dispose = function () {}
                }
            }

            function ns(t) {
                function e(e, r) {
                    e.opacity.value = r.opacity, r.color && e.diffuse.value.copy(r.color), r.emissive && e.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (e.map.value = r.map), r.alphaMap && (e.alphaMap.value = r.alphaMap), r.specularMap && (e.specularMap.value = r.specularMap);
                    const n = t.get(r).envMap;
                    if (n) {
                        e.envMap.value = n, e.flipEnvMap.value = n.isCubeTexture && n._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = r.reflectivity, e.refractionRatio.value = r.refractionRatio;
                        const o = t.get(n).__maxMipLevel;
                        void 0 !== o && (e.maxMipLevel.value = o)
                    }
                    let o, h;
                    r.lightMap && (e.lightMap.value = r.lightMap, e.lightMapIntensity.value = r.lightMapIntensity), r.aoMap && (e.aoMap.value = r.aoMap, e.aoMapIntensity.value = r.aoMapIntensity), r.map ? o = r.map : r.specularMap ? o = r.specularMap : r.displacementMap ? o = r.displacementMap : r.normalMap ? o = r.normalMap : r.bumpMap ? o = r.bumpMap : r.roughnessMap ? o = r.roughnessMap : r.metalnessMap ? o = r.metalnessMap : r.alphaMap ? o = r.alphaMap : r.emissiveMap ? o = r.emissiveMap : r.clearcoatMap ? o = r.clearcoatMap : r.clearcoatNormalMap ? o = r.clearcoatNormalMap : r.clearcoatRoughnessMap && (o = r.clearcoatRoughnessMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), e.uvTransform.value.copy(o.matrix)), r.aoMap ? h = r.aoMap : r.lightMap && (h = r.lightMap), void 0 !== h && (h.isWebGLRenderTarget && (h = h.texture), !0 === h.matrixAutoUpdate && h.updateMatrix(), e.uv2Transform.value.copy(h.matrix))
                }

                function r(e, r) {
                    e.roughness.value = r.roughness, e.metalness.value = r.metalness, r.roughnessMap && (e.roughnessMap.value = r.roughnessMap), r.metalnessMap && (e.metalnessMap.value = r.metalnessMap), r.emissiveMap && (e.emissiveMap.value = r.emissiveMap), r.bumpMap && (e.bumpMap.value = r.bumpMap, e.bumpScale.value = r.bumpScale, 1 === r.side && (e.bumpScale.value *= -1)), r.normalMap && (e.normalMap.value = r.normalMap, e.normalScale.value.copy(r.normalScale), 1 === r.side && e.normalScale.value.negate()), r.displacementMap && (e.displacementMap.value = r.displacementMap, e.displacementScale.value = r.displacementScale, e.displacementBias.value = r.displacementBias);
                    t.get(r).envMap && (e.envMapIntensity.value = r.envMapIntensity)
                }
                return {
                    refreshFogUniforms: function (t, e) {
                        t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                    },
                    refreshMaterialUniforms: function (t, n, o, h, l) {
                        n.isMeshBasicMaterial ? e(t, n) : n.isMeshLambertMaterial ? (e(t, n), function (t, e) {
                            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                        }(t, n)) : n.isMeshToonMaterial ? (e(t, n), function (t, e) {
                            e.gradientMap && (t.gradientMap.value = e.gradientMap);
                            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, n)) : n.isMeshPhongMaterial ? (e(t, n), function (t, e) {
                            t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, n)) : n.isMeshStandardMaterial ? (e(t, n), n.isMeshPhysicalMaterial ? function (t, e, n) {
                            r(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
                            e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                            e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                            e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate());
                            t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap);
                            e.transmission > 0 && (t.transmissionSamplerMap.value = n.texture, t.transmissionSamplerSize.value.set(n.width, n.height));
                            t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap);
                            t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor)
                        }(t, n, l) : r(t, n)) : n.isMeshMatcapMaterial ? (e(t, n), function (t, e) {
                            e.matcap && (t.matcap.value = e.matcap);
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, n)) : n.isMeshDepthMaterial ? (e(t, n), function (t, e) {
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, n)) : n.isMeshDistanceMaterial ? (e(t, n), function (t, e) {
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                            t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                        }(t, n)) : n.isMeshNormalMaterial ? (e(t, n), function (t, e) {
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, n)) : n.isLineBasicMaterial ? (function (t, e) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                        }(t, n), n.isLineDashedMaterial && function (t, e) {
                            t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                        }(t, n)) : n.isPointsMaterial ? function (t, e, r, n) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * r, t.scale.value = .5 * n, e.map && (t.map.value = e.map);
                            e.alphaMap && (t.alphaMap.value = e.alphaMap);
                            let o;
                            e.map ? o = e.map : e.alphaMap && (o = e.alphaMap);
                            void 0 !== o && (!0 === o.matrixAutoUpdate && o.updateMatrix(), t.uvTransform.value.copy(o.matrix))
                        }(t, n, o, h) : n.isSpriteMaterial ? function (t, e) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                            e.alphaMap && (t.alphaMap.value = e.alphaMap);
                            let r;
                            e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
                            void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                        }(t, n) : n.isShadowMaterial ? (t.color.value.copy(n.color), t.opacity.value = n.opacity) : n.isShaderMaterial && (n.uniformsNeedUpdate = !1)
                    }
                }
            }

            function ss(t = {}) {
                const e = void 0 !== t.canvas ? t.canvas : function () {
                        const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        return canvas.style.display = "block", canvas
                    }(),
                    r = void 0 !== t.context ? t.context : null,
                    n = void 0 !== t.alpha && t.alpha,
                    o = void 0 === t.depth || t.depth,
                    h = void 0 === t.stencil || t.stencil,
                    l = void 0 !== t.antialias && t.antialias,
                    c = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    d = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                    f = void 0 !== t.powerPreference ? t.powerPreference : "default",
                    v = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                let x = null,
                    _ = null;
                const w = [],
                    E = [];
                this.domElement = e, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = O, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
                const P = this;
                let C = !1,
                    D = 0,
                    R = 0,
                    I = null,
                    F = -1,
                    k = null;
                const N = new mt,
                    B = new mt;
                let z = null,
                    V = e.width,
                    G = e.height,
                    H = 1,
                    U = null,
                    W = null;
                const j = new mt(0, 0, V, G),
                    X = new mt(0, 0, V, G);
                let Y = !1;
                const J = [],
                    Z = new Oi;
                let K = !1,
                    Q = !1,
                    $ = null;
                const tt = new Jt,
                    et = new vt,
                    it = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function nt() {
                    return null === I ? H : 1
                }
                let st, at, ot, ht, lt, ct, pt, ut, yt, xt, _t, bt, Mt, St, wt, Et, Tt, At, Pt, Ct, Lt, Dt, Rt = r;

                function It(t, r) {
                    for (let i = 0; i < t.length; i++) {
                        const n = t[i],
                            o = e.getContext(n, r);
                        if (null !== o) return o
                    }
                    return null
                }
                try {
                    const t = {
                        alpha: n,
                        depth: o,
                        stencil: h,
                        antialias: l,
                        premultipliedAlpha: c,
                        preserveDrawingBuffer: d,
                        powerPreference: f,
                        failIfMajorPerformanceCaveat: v
                    };
                    if (e.addEventListener("webglcontextlost", Nt, !1), e.addEventListener("webglcontextrestored", Bt, !1), null === Rt) {
                        const e = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === P.isWebGL1Renderer && e.shift(), Rt = It(e, t), null === Rt) throw It(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    void 0 === Rt.getShaderPrecisionFormat && (Rt.getShaderPrecisionFormat = function () {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (t) {
                    throw console.error("THREE.WebGLRenderer: " + t.message), t
                }

                function Ft() {
                    st = new $i(Rt), at = new Zi(Rt, st, t), st.init(at), Lt = new Qn(Rt, st, at), ot = new Zn(Rt, st, at), J[0] = 1029, ht = new rr(Rt), lt = new Nn, ct = new Kn(Rt, st, ot, lt, at, Lt, ht), pt = new Qi(P), ut = new Hi(Rt, at), Dt = new Yi(Rt, st, ut, at), yt = new er(Rt, ut, ht, Dt), xt = new or(Rt, yt, ut, ht), At = new ar(Rt), wt = new Ki(lt), _t = new kn(P, pt, st, at, Dt, wt), bt = new ns(lt), Mt = new On(lt), St = new qn(st, at), Tt = new Xi(P, pt, ot, xt, c), Et = new Jn(P, xt, at), Pt = new Ji(Rt, st, ht, at), Ct = new ir(Rt, st, ht, at), ht.programs = _t.programs, P.capabilities = at, P.extensions = st, P.properties = lt, P.renderLists = Mt, P.shadowMap = Et, P.state = ot, P.info = ht
                }
                Ft();
                const kt = new rs(P, Rt);

                function Nt(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), C = !0
                }

                function Bt() {
                    console.log("THREE.WebGLRenderer: Context Restored."), C = !1;
                    const t = ht.autoReset,
                        e = Et.enabled,
                        r = Et.autoUpdate,
                        n = Et.needsUpdate,
                        o = Et.type;
                    Ft(), ht.autoReset = t, Et.enabled = e, Et.autoUpdate = r, Et.needsUpdate = n, Et.type = o
                }

                function zt(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", zt),
                        function (t) {
                            (function (t) {
                                const e = lt.get(t).programs;
                                void 0 !== e && e.forEach((function (t) {
                                    _t.releaseProgram(t)
                                }))
                            })(t), lt.remove(t)
                        }(e)
                }
                this.xr = kt, this.getContext = function () {
                    return Rt
                }, this.getContextAttributes = function () {
                    return Rt.getContextAttributes()
                }, this.forceContextLoss = function () {
                    const t = st.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function () {
                    const t = st.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function () {
                    return H
                }, this.setPixelRatio = function (t) {
                    void 0 !== t && (H = t, this.setSize(V, G, !1))
                }, this.getSize = function (t) {
                    return t.set(V, G)
                }, this.setSize = function (t, r, n) {
                    kt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (V = t, G = r, e.width = Math.floor(t * H), e.height = Math.floor(r * H), !1 !== n && (e.style.width = t + "px", e.style.height = r + "px"), this.setViewport(0, 0, t, r))
                }, this.getDrawingBufferSize = function (t) {
                    return t.set(V * H, G * H).floor()
                }, this.setDrawingBufferSize = function (t, r, n) {
                    V = t, G = r, H = n, e.width = Math.floor(t * n), e.height = Math.floor(r * n), this.setViewport(0, 0, t, r)
                }, this.getCurrentViewport = function (t) {
                    return t.copy(N)
                }, this.getViewport = function (t) {
                    return t.copy(j)
                }, this.setViewport = function (t, e, r, n) {
                    t.isVector4 ? j.set(t.x, t.y, t.z, t.w) : j.set(t, e, r, n), ot.viewport(N.copy(j).multiplyScalar(H).floor())
                }, this.getScissor = function (t) {
                    return t.copy(X)
                }, this.setScissor = function (t, e, r, n) {
                    t.isVector4 ? X.set(t.x, t.y, t.z, t.w) : X.set(t, e, r, n), ot.scissor(B.copy(X).multiplyScalar(H).floor())
                }, this.getScissorTest = function () {
                    return Y
                }, this.setScissorTest = function (t) {
                    ot.setScissorTest(Y = t)
                }, this.setOpaqueSort = function (t) {
                    U = t
                }, this.setTransparentSort = function (t) {
                    W = t
                }, this.getClearColor = function (t) {
                    return t.copy(Tt.getClearColor())
                }, this.setClearColor = function () {
                    Tt.setClearColor.apply(Tt, arguments)
                }, this.getClearAlpha = function () {
                    return Tt.getClearAlpha()
                }, this.setClearAlpha = function () {
                    Tt.setClearAlpha.apply(Tt, arguments)
                }, this.clear = function (t, e, r) {
                    let n = 0;
                    (void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === r || r) && (n |= 1024), Rt.clear(n)
                }, this.clearColor = function () {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function () {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function () {
                    this.clear(!1, !1, !0)
                }, this.dispose = function () {
                    e.removeEventListener("webglcontextlost", Nt, !1), e.removeEventListener("webglcontextrestored", Bt, !1), Mt.dispose(), St.dispose(), lt.dispose(), pt.dispose(), xt.dispose(), Dt.dispose(), kt.dispose(), kt.removeEventListener("sessionstart", Ot), kt.removeEventListener("sessionend", Gt), $ && ($.dispose(), $ = null), Ht.stop()
                }, this.renderBufferImmediate = function (object, t) {
                    Dt.initAttributes();
                    const e = lt.get(object);
                    object.hasPositions && !e.position && (e.position = Rt.createBuffer()), object.hasNormals && !e.normal && (e.normal = Rt.createBuffer()), object.hasUvs && !e.uv && (e.uv = Rt.createBuffer()), object.hasColors && !e.color && (e.color = Rt.createBuffer());
                    const r = t.getAttributes();
                    object.hasPositions && (Rt.bindBuffer(34962, e.position), Rt.bufferData(34962, object.positionArray, 35048), Dt.enableAttribute(r.position), Rt.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), object.hasNormals && (Rt.bindBuffer(34962, e.normal), Rt.bufferData(34962, object.normalArray, 35048), Dt.enableAttribute(r.normal), Rt.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), object.hasUvs && (Rt.bindBuffer(34962, e.uv), Rt.bufferData(34962, object.uvArray, 35048), Dt.enableAttribute(r.uv), Rt.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), object.hasColors && (Rt.bindBuffer(34962, e.color), Rt.bufferData(34962, object.colorArray, 35048), Dt.enableAttribute(r.color), Rt.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), Dt.disableUnusedAttributes(), Rt.drawArrays(4, 0, object.count), object.count = 0
                }, this.renderBufferDirect = function (t, e, r, n, object, o) {
                    null === e && (e = it);
                    const h = object.isMesh && object.matrixWorld.determinant() < 0,
                        l = Yt(t, e, n, object);
                    ot.setMaterial(n, h);
                    let c = r.index;
                    const d = r.attributes.position;
                    if (null === c) {
                        if (void 0 === d || 0 === d.count) return
                    } else if (0 === c.count) return;
                    let m, f = 1;
                    !0 === n.wireframe && (c = yt.getWireframeAttribute(r), f = 2), (n.morphTargets || n.morphNormals) && At.update(object, r, n, l), Dt.setup(object, n, l, r, c);
                    let y = Pt;
                    null !== c && (m = ut.get(c), y = Ct, y.setIndex(m));
                    const v = null !== c ? c.count : d.count,
                        x = r.drawRange.start * f,
                        _ = r.drawRange.count * f,
                        M = null !== o ? o.start * f : 0,
                        S = null !== o ? o.count * f : 1 / 0,
                        w = Math.max(x, M),
                        E = Math.min(v, x + _, M + S) - 1,
                        T = Math.max(0, E - w + 1);
                    if (0 !== T) {
                        if (object.isMesh) !0 === n.wireframe ? (ot.setLineWidth(n.wireframeLinewidth * nt()), y.setMode(1)) : y.setMode(4);
                        else if (object.isLine) {
                            let t = n.linewidth;
                            void 0 === t && (t = 1), ot.setLineWidth(t * nt()), object.isLineSegments ? y.setMode(1) : object.isLineLoop ? y.setMode(2) : y.setMode(3)
                        } else object.isPoints ? y.setMode(0) : object.isSprite && y.setMode(4);
                        if (object.isInstancedMesh) y.renderInstances(w, T, object.count);
                        else if (r.isInstancedBufferGeometry) {
                            const t = Math.min(r.instanceCount, r._maxInstanceCount);
                            y.renderInstances(w, T, t)
                        } else y.render(w, T)
                    }
                }, this.compile = function (t, e) {
                    _ = St.get(t), _.init(), t.traverseVisible((function (object) {
                        object.isLight && object.layers.test(e.layers) && (_.pushLight(object), object.castShadow && _.pushShadow(object))
                    })), _.setupLights(), t.traverse((function (object) {
                        const e = object.material;
                        if (e)
                            if (Array.isArray(e))
                                for (let i = 0; i < e.length; i++) {
                                    qt(e[i], t, object)
                                } else qt(e, t, object)
                    }))
                };
                let Vt = null;

                function Ot() {
                    Ht.stop()
                }

                function Gt() {
                    Ht.start()
                }
                const Ht = new Gi;

                function Ut(object, t, e, r) {
                    if (!1 === object.visible) return;
                    if (object.layers.test(t.layers))
                        if (object.isGroup) e = object.renderOrder;
                        else if (object.isLOD) !0 === object.autoUpdate && object.update(t);
                    else if (object.isLight) _.pushLight(object), object.castShadow && _.pushShadow(object);
                    else if (object.isSprite) {
                        if (!object.frustumCulled || Z.intersectsSprite(object)) {
                            r && et.setFromMatrixPosition(object.matrixWorld).applyMatrix4(tt);
                            const t = xt.update(object),
                                n = object.material;
                            n.visible && x.push(object, t, n, e, et.z, null)
                        }
                    } else if (object.isImmediateRenderObject) r && et.setFromMatrixPosition(object.matrixWorld).applyMatrix4(tt), x.push(object, null, object.material, e, et.z, null);
                    else if ((object.isMesh || object.isLine || object.isPoints) && (object.isSkinnedMesh && object.skeleton.frame !== ht.render.frame && (object.skeleton.update(), object.skeleton.frame = ht.render.frame), !object.frustumCulled || Z.intersectsObject(object))) {
                        r && et.setFromMatrixPosition(object.matrixWorld).applyMatrix4(tt);
                        const t = xt.update(object),
                            n = object.material;
                        if (Array.isArray(n)) {
                            const r = t.groups;
                            for (let i = 0, o = r.length; i < o; i++) {
                                const o = r[i],
                                    h = n[o.materialIndex];
                                h && h.visible && x.push(object, t, h, e, et.z, o)
                            }
                        } else n.visible && x.push(object, t, n, e, et.z, null)
                    }
                    const n = object.children;
                    for (let i = 0, o = n.length; i < o; i++) Ut(n[i], t, e, r)
                }

                function Wt(t, e, r) {
                    const n = !0 === e.isScene ? e.overrideMaterial : null;
                    for (let i = 0, o = t.length; i < o; i++) {
                        const o = t[i],
                            object = o.object,
                            h = o.geometry,
                            l = null === n ? o.material : n,
                            c = o.group;
                        if (r.isArrayCamera) {
                            const t = r.cameras;
                            for (let r = 0, n = t.length; r < n; r++) {
                                const n = t[r];
                                object.layers.test(n.layers) && (ot.viewport(N.copy(n.viewport)), _.setupLightsView(n), jt(object, e, n, h, l, c))
                            }
                        } else jt(object, e, r, h, l, c)
                    }
                }

                function jt(object, t, e, r, n, o) {
                    if (object.onBeforeRender(P, t, e, r, n, o), object.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, object.matrixWorld), object.normalMatrix.getNormalMatrix(object.modelViewMatrix), object.isImmediateRenderObject) {
                        const r = Yt(e, t, n, object);
                        ot.setMaterial(n), Dt.reset(),
                            function (object, t) {
                                object.render((function (object) {
                                    P.renderBufferImmediate(object, t)
                                }))
                            }(object, r)
                    } else !0 === n.transparent && 2 === n.side ? (n.side = 1, n.needsUpdate = !0, P.renderBufferDirect(e, t, r, n, object, o), n.side = 0, n.needsUpdate = !0, P.renderBufferDirect(e, t, r, n, object, o), n.side = 2) : P.renderBufferDirect(e, t, r, n, object, o);
                    object.onAfterRender(P, t, e, r, n, o)
                }

                function qt(t, e, object) {
                    !0 !== e.isScene && (e = it);
                    const r = lt.get(t),
                        n = _.state.lights,
                        o = _.state.shadowsArray,
                        h = n.state.version,
                        l = _t.getParameters(t, n.state, o, e, object),
                        c = _t.getProgramCacheKey(l);
                    let d = r.programs;
                    r.environment = t.isMeshStandardMaterial ? e.environment : null, r.fog = e.fog, r.envMap = pt.get(t.envMap || r.environment), void 0 === d && (t.addEventListener("dispose", zt), d = new Map, r.programs = d);
                    let m = d.get(c);
                    if (void 0 !== m) {
                        if (r.currentProgram === m && r.lightsStateVersion === h) return Xt(t, l), m
                    } else l.uniforms = _t.getUniforms(t), t.onBuild(l, P), t.onBeforeCompile(l, P), m = _t.acquireProgram(l, c), d.set(c, m), r.uniforms = l.uniforms;
                    const f = r.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (f.clippingPlanes = wt.uniform), Xt(t, l), r.needsLights = function (t) {
                        return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                    }(t), r.lightsStateVersion = h, r.needsLights && (f.ambientLightColor.value = n.state.ambient, f.lightProbe.value = n.state.probe, f.directionalLights.value = n.state.directional, f.directionalLightShadows.value = n.state.directionalShadow, f.spotLights.value = n.state.spot, f.spotLightShadows.value = n.state.spotShadow, f.rectAreaLights.value = n.state.rectArea, f.ltc_1.value = n.state.rectAreaLTC1, f.ltc_2.value = n.state.rectAreaLTC2, f.pointLights.value = n.state.point, f.pointLightShadows.value = n.state.pointShadow, f.hemisphereLights.value = n.state.hemi, f.directionalShadowMap.value = n.state.directionalShadowMap, f.directionalShadowMatrix.value = n.state.directionalShadowMatrix, f.spotShadowMap.value = n.state.spotShadowMap, f.spotShadowMatrix.value = n.state.spotShadowMatrix, f.pointShadowMap.value = n.state.pointShadowMap, f.pointShadowMatrix.value = n.state.pointShadowMatrix);
                    const y = m.getUniforms(),
                        v = mn.seqWithValue(y.seq, f);
                    return r.currentProgram = m, r.uniformsList = v, m
                }

                function Xt(t, e) {
                    const r = lt.get(t);
                    r.outputEncoding = e.outputEncoding, r.instancing = e.instancing, r.skinning = e.skinning, r.numClippingPlanes = e.numClippingPlanes, r.numIntersection = e.numClipIntersection, r.vertexAlphas = e.vertexAlphas
                }

                function Yt(t, e, r, object) {
                    !0 !== e.isScene && (e = it), ct.resetTextureUnits();
                    const n = e.fog,
                        o = r.isMeshStandardMaterial ? e.environment : null,
                        h = null === I ? P.outputEncoding : I.texture.encoding,
                        l = pt.get(r.envMap || o),
                        c = !0 === r.vertexColors && object.geometry && object.geometry.attributes.color && 4 === object.geometry.attributes.color.itemSize,
                        d = lt.get(r),
                        m = _.state.lights;
                    if (!0 === K && (!0 === Q || t !== k)) {
                        const e = t === k && r.id === F;
                        wt.setState(r, t, e)
                    }
                    let f = !1;
                    r.version === d.__version ? d.needsLights && d.lightsStateVersion !== m.state.version || d.outputEncoding !== h || object.isInstancedMesh && !1 === d.instancing ? f = !0 : object.isInstancedMesh || !0 !== d.instancing ? object.isSkinnedMesh && !1 === d.skinning ? f = !0 : object.isSkinnedMesh || !0 !== d.skinning ? d.envMap !== l || r.fog && d.fog !== n ? f = !0 : void 0 === d.numClippingPlanes || d.numClippingPlanes === wt.numPlanes && d.numIntersection === wt.numIntersection ? d.vertexAlphas !== c && (f = !0) : f = !0 : f = !0 : f = !0 : (f = !0, d.__version = r.version);
                    let y = d.currentProgram;
                    !0 === f && (y = qt(r, e, object));
                    let v = !1,
                        x = !1,
                        M = !1;
                    const S = y.getUniforms(),
                        w = d.uniforms;
                    if (ot.useProgram(y.program) && (v = !0, x = !0, M = !0), r.id !== F && (F = r.id, x = !0), v || k !== t) {
                        if (S.setValue(Rt, "projectionMatrix", t.projectionMatrix), at.logarithmicDepthBuffer && S.setValue(Rt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), k !== t && (k = t, x = !0, M = !0), r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshStandardMaterial || r.envMap) {
                            const e = S.map.cameraPosition;
                            void 0 !== e && e.setValue(Rt, et.setFromMatrixPosition(t.matrixWorld))
                        }(r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && S.setValue(Rt, "isOrthographic", !0 === t.isOrthographicCamera), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.isShadowMaterial || object.isSkinnedMesh) && S.setValue(Rt, "viewMatrix", t.matrixWorldInverse)
                    }
                    if (object.isSkinnedMesh) {
                        S.setOptional(Rt, object, "bindMatrix"), S.setOptional(Rt, object, "bindMatrixInverse");
                        const t = object.skeleton;
                        t && (at.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), S.setValue(Rt, "boneTexture", t.boneTexture, ct), S.setValue(Rt, "boneTextureSize", t.boneTextureSize)) : S.setOptional(Rt, t, "boneMatrices"))
                    }
                    var E, T;
                    return (x || d.receiveShadow !== object.receiveShadow) && (d.receiveShadow = object.receiveShadow, S.setValue(Rt, "receiveShadow", object.receiveShadow)), x && (S.setValue(Rt, "toneMappingExposure", P.toneMappingExposure), d.needsLights && (T = M, (E = w).ambientLightColor.needsUpdate = T, E.lightProbe.needsUpdate = T, E.directionalLights.needsUpdate = T, E.directionalLightShadows.needsUpdate = T, E.pointLights.needsUpdate = T, E.pointLightShadows.needsUpdate = T, E.spotLights.needsUpdate = T, E.spotLightShadows.needsUpdate = T, E.rectAreaLights.needsUpdate = T, E.hemisphereLights.needsUpdate = T), n && r.fog && bt.refreshFogUniforms(w, n), bt.refreshMaterialUniforms(w, r, H, G, $), mn.upload(Rt, d.uniformsList, w, ct)), r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (mn.upload(Rt, d.uniformsList, w, ct), r.uniformsNeedUpdate = !1), r.isSpriteMaterial && S.setValue(Rt, "center", object.center), S.setValue(Rt, "modelViewMatrix", object.modelViewMatrix), S.setValue(Rt, "normalMatrix", object.normalMatrix), S.setValue(Rt, "modelMatrix", object.matrixWorld), y
                }
                Ht.setAnimationLoop((function (time) {
                    Vt && Vt(time)
                })), "undefined" != typeof window && Ht.setContext(window), this.setAnimationLoop = function (t) {
                    Vt = t, kt.setAnimationLoop(t), null === t ? Ht.stop() : Ht.start()
                }, kt.addEventListener("sessionstart", Ot), kt.addEventListener("sessionend", Gt), this.render = function (t, e) {
                    if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === C) return;
                    !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === kt.enabled && !0 === kt.isPresenting && (!0 === kt.cameraAutoUpdate && kt.updateCamera(e), e = kt.getCamera()), !0 === t.isScene && t.onBeforeRender(P, t, e, I), _ = St.get(t, E.length), _.init(), E.push(_), tt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), Z.setFromProjectionMatrix(tt), Q = this.localClippingEnabled, K = wt.init(this.clippingPlanes, Q, e), x = Mt.get(t, w.length), x.init(), w.push(x), Ut(t, e, 0, P.sortObjects), x.finish(), !0 === P.sortObjects && x.sort(U, W), !0 === K && wt.beginShadows();
                    const r = _.state.shadowsArray;
                    Et.render(r, t, e), _.setupLights(), _.setupLightsView(e), !0 === K && wt.endShadows(), !0 === this.info.autoReset && this.info.reset(), Tt.render(x, t);
                    const n = x.opaque,
                        o = x.transmissive,
                        h = x.transparent;
                    n.length > 0 && Wt(n, t, e), o.length > 0 && function (t, e, r, n) {
                        if (null === $) {
                            const t = !0 === l && !0 === at.isWebGL2;
                            $ = new(t ? gt : ft)(1024, 1024, {
                                generateMipmaps: !0,
                                type: null !== Lt.convert(A) ? A : S,
                                minFilter: M,
                                magFilter: y,
                                wrapS: m,
                                wrapT: m
                            })
                        }
                        const o = P.getRenderTarget();
                        P.setRenderTarget($), P.clear();
                        const h = P.toneMapping;
                        P.toneMapping = 0, Wt(t, r, n), P.toneMapping = h, ct.updateMultisampleRenderTarget($), ct.updateRenderTargetMipmap($), P.setRenderTarget(o), Wt(e, r, n)
                    }(n, o, t, e), h.length > 0 && Wt(h, t, e), null !== I && (ct.updateMultisampleRenderTarget(I), ct.updateRenderTargetMipmap(I)), !0 === t.isScene && t.onAfterRender(P, t, e), ot.buffers.depth.setTest(!0), ot.buffers.depth.setMask(!0), ot.buffers.color.setMask(!0), ot.setPolygonOffset(!1), Dt.resetDefaultState(), F = -1, k = null, E.pop(), _ = E.length > 0 ? E[E.length - 1] : null, w.pop(), x = w.length > 0 ? w[w.length - 1] : null
                }, this.getActiveCubeFace = function () {
                    return D
                }, this.getActiveMipmapLevel = function () {
                    return R
                }, this.getRenderTarget = function () {
                    return I
                }, this.setRenderTarget = function (t, e = 0, r = 0) {
                    I = t, D = e, R = r, t && void 0 === lt.get(t).__webglFramebuffer && ct.setupRenderTarget(t);
                    let n = null,
                        o = !1,
                        h = !1;
                    if (t) {
                        const r = t.texture;
                        (r.isDataTexture3D || r.isDataTexture2DArray) && (h = !0);
                        const l = lt.get(t).__webglFramebuffer;
                        t.isWebGLCubeRenderTarget ? (n = l[e], o = !0) : n = t.isWebGLMultisampleRenderTarget ? lt.get(t).__webglMultisampledFramebuffer : l, N.copy(t.viewport), B.copy(t.scissor), z = t.scissorTest
                    } else N.copy(j).multiplyScalar(H).floor(), B.copy(X).multiplyScalar(H).floor(), z = Y;
                    if (ot.bindFramebuffer(36160, n) && at.drawBuffers) {
                        let e = !1;
                        if (t)
                            if (t.isWebGLMultipleRenderTargets) {
                                const r = t.texture;
                                if (J.length !== r.length || 36064 !== J[0]) {
                                    for (let i = 0, t = r.length; i < t; i++) J[i] = 36064 + i;
                                    J.length = r.length, e = !0
                                }
                            } else 1 === J.length && 36064 === J[0] || (J[0] = 36064, J.length = 1, e = !0);
                        else 1 === J.length && 1029 === J[0] || (J[0] = 1029, J.length = 1, e = !0);
                        e && (at.isWebGL2 ? Rt.drawBuffers(J) : st.get("WEBGL_draw_buffers").drawBuffersWEBGL(J))
                    }
                    if (ot.viewport(N), ot.scissor(B), ot.setScissorTest(z), o) {
                        const n = lt.get(t.texture);
                        Rt.framebufferTexture2D(36160, 36064, 34069 + e, n.__webglTexture, r)
                    } else if (h) {
                        const n = lt.get(t.texture),
                            o = e || 0;
                        Rt.framebufferTextureLayer(36160, 36064, n.__webglTexture, r || 0, o)
                    }
                }, this.readRenderTargetPixels = function (t, e, r, n, o, h, l) {
                    if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let c = lt.get(t).__webglFramebuffer;
                    if (t.isWebGLCubeRenderTarget && void 0 !== l && (c = c[l]), c) {
                        ot.bindFramebuffer(36160, c);
                        try {
                            const l = t.texture,
                                c = l.format,
                                d = l.type;
                            if (c !== L && Lt.convert(c) !== Rt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const m = d === A && (st.has("EXT_color_buffer_half_float") || at.isWebGL2 && st.has("EXT_color_buffer_float"));
                            if (!(d === S || Lt.convert(d) === Rt.getParameter(35738) || d === T && (at.isWebGL2 || st.has("OES_texture_float") || st.has("WEBGL_color_buffer_float")) || m)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            36053 === Rt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - n && r >= 0 && r <= t.height - o && Rt.readPixels(e, r, n, o, Lt.convert(c), Lt.convert(d), h) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            const t = null !== I ? lt.get(I).__webglFramebuffer : null;
                            ot.bindFramebuffer(36160, t)
                        }
                    }
                }, this.copyFramebufferToTexture = function (t, e, r = 0) {
                    const n = Math.pow(2, -r),
                        o = Math.floor(e.image.width * n),
                        h = Math.floor(e.image.height * n);
                    let l = Lt.convert(e.format);
                    at.isWebGL2 && (6407 === l && (l = 32849), 6408 === l && (l = 32856)), ct.setTexture2D(e, 0), Rt.copyTexImage2D(3553, r, l, t.x, t.y, o, h, 0), ot.unbindTexture()
                }, this.copyTextureToTexture = function (t, e, r, n = 0) {
                    const o = e.image.width,
                        h = e.image.height,
                        l = Lt.convert(r.format),
                        c = Lt.convert(r.type);
                    ct.setTexture2D(r, 0), Rt.pixelStorei(37440, r.flipY), Rt.pixelStorei(37441, r.premultiplyAlpha), Rt.pixelStorei(3317, r.unpackAlignment), e.isDataTexture ? Rt.texSubImage2D(3553, n, t.x, t.y, o, h, l, c, e.image.data) : e.isCompressedTexture ? Rt.compressedTexSubImage2D(3553, n, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, l, e.mipmaps[0].data) : Rt.texSubImage2D(3553, n, t.x, t.y, l, c, e.image), 0 === n && r.generateMipmaps && Rt.generateMipmap(3553), ot.unbindTexture()
                }, this.copyTextureToTexture3D = function (t, e, r, n, o = 0) {
                    if (P.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const h = t.max.x - t.min.x + 1,
                        l = t.max.y - t.min.y + 1,
                        c = t.max.z - t.min.z + 1,
                        d = Lt.convert(n.format),
                        m = Lt.convert(n.type);
                    let f;
                    if (n.isDataTexture3D) ct.setTexture3D(n, 0), f = 32879;
                    else {
                        if (!n.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        ct.setTexture2DArray(n, 0), f = 35866
                    }
                    Rt.pixelStorei(37440, n.flipY), Rt.pixelStorei(37441, n.premultiplyAlpha), Rt.pixelStorei(3317, n.unpackAlignment);
                    const y = Rt.getParameter(3314),
                        v = Rt.getParameter(32878),
                        x = Rt.getParameter(3316),
                        _ = Rt.getParameter(3315),
                        M = Rt.getParameter(32877),
                        image = r.isCompressedTexture ? r.mipmaps[0] : r.image;
                    Rt.pixelStorei(3314, image.width), Rt.pixelStorei(32878, image.height), Rt.pixelStorei(3316, t.min.x), Rt.pixelStorei(3315, t.min.y), Rt.pixelStorei(32877, t.min.z), r.isDataTexture || r.isDataTexture3D ? Rt.texSubImage3D(f, o, e.x, e.y, e.z, h, l, c, d, m, image.data) : r.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Rt.compressedTexSubImage3D(f, o, e.x, e.y, e.z, h, l, c, d, image.data)) : Rt.texSubImage3D(f, o, e.x, e.y, e.z, h, l, c, d, m, image), Rt.pixelStorei(3314, y), Rt.pixelStorei(32878, v), Rt.pixelStorei(3316, x), Rt.pixelStorei(3315, _), Rt.pixelStorei(32877, M), 0 === o && n.generateMipmaps && Rt.generateMipmap(f), ot.unbindTexture()
                }, this.initTexture = function (t) {
                    ct.setTexture2D(t, 0), ot.unbindTexture()
                }, this.resetState = function () {
                    D = 0, R = 0, I = null, ot.reset(), Dt.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }(class extends ss {}).prototype.isWebGL1Renderer = !0;
            class as {
                constructor(t, e = 25e-5) {
                    this.name = "", this.color = new Oe(t), this.density = e
                }
                clone() {
                    return new as(this.color, this.density)
                }
                toJSON() {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }
            as.prototype.isFogExp2 = !0;
            class os {
                constructor(t, e = 1, r = 1e3) {
                    this.name = "", this.color = new Oe(t), this.near = e, this.far = r
                }
                clone() {
                    return new os(this.color, this.near, this.far)
                }
                toJSON() {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }
            os.prototype.isFog = !0;
            class hs extends _e {
                constructor() {
                    super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                copy(source, t) {
                    return super.copy(source, t), null !== source.background && (this.background = source.background.clone()), null !== source.environment && (this.environment = source.environment.clone()), null !== source.fog && (this.fog = source.fog.clone()), null !== source.overrideMaterial && (this.overrideMaterial = source.overrideMaterial.clone()), this.autoUpdate = source.autoUpdate, this.matrixAutoUpdate = source.matrixAutoUpdate, this
                }
                toJSON(meta) {
                    const data = super.toJSON(meta);
                    return null !== this.fog && (data.object.fog = this.fog.toJSON()), data
                }
            }
            hs.prototype.isScene = !0;
            class ls {
                constructor(t, e) {
                    this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = j, this.updateRange = {
                        offset: 0,
                        count: -1
                    }, this.version = 0, this.uuid = $()
                }
                onUploadCallback() {}
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
                setUsage(t) {
                    return this.usage = t, this
                }
                copy(source) {
                    return this.array = new source.array.constructor(source.array), this.count = source.count, this.stride = source.stride, this.usage = source.usage, this
                }
                copyAt(t, e, r) {
                    t *= this.stride, r *= e.stride;
                    for (let i = 0, n = this.stride; i < n; i++) this.array[t + i] = e.array[r + i];
                    return this
                }
                set(t, e = 0) {
                    return this.array.set(t, e), this
                }
                clone(data) {
                    void 0 === data.arrayBuffers && (data.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = $()), void 0 === data.arrayBuffers[this.array.buffer._uuid] && (data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const t = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]),
                        e = new this.constructor(t, this.stride);
                    return e.setUsage(this.usage), e
                }
                onUpload(t) {
                    return this.onUploadCallback = t, this
                }
                toJSON(data) {
                    return void 0 === data.arrayBuffers && (data.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = $()), void 0 === data.arrayBuffers[this.array.buffer._uuid] && (data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            }
            ls.prototype.isInterleavedBuffer = !0;
            const cs = new vt;
            class ps {
                constructor(t, e, r, n = !1) {
                    this.name = "", this.data = t, this.itemSize = e, this.offset = r, this.normalized = !0 === n
                }
                get count() {
                    return this.data.count
                }
                get array() {
                    return this.data.array
                }
                set needsUpdate(t) {
                    this.data.needsUpdate = t
                }
                applyMatrix4(t) {
                    for (let i = 0, e = this.data.count; i < e; i++) cs.x = this.getX(i), cs.y = this.getY(i), cs.z = this.getZ(i), cs.applyMatrix4(t), this.setXYZ(i, cs.x, cs.y, cs.z);
                    return this
                }
                applyNormalMatrix(t) {
                    for (let i = 0, e = this.count; i < e; i++) cs.x = this.getX(i), cs.y = this.getY(i), cs.z = this.getZ(i), cs.applyNormalMatrix(t), this.setXYZ(i, cs.x, cs.y, cs.z);
                    return this
                }
                transformDirection(t) {
                    for (let i = 0, e = this.count; i < e; i++) cs.x = this.getX(i), cs.y = this.getY(i), cs.z = this.getZ(i), cs.transformDirection(t), this.setXYZ(i, cs.x, cs.y, cs.z);
                    return this
                }
                setX(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e, this
                }
                setY(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                }
                setZ(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                }
                setW(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                }
                getX(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                }
                getY(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                }
                getZ(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                }
                getW(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                }
                setXY(t, e, r) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = r, this
                }
                setXYZ(t, e, r, n) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = r, this.data.array[t + 2] = n, this
                }
                setXYZW(t, e, r, n, o) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = r, this.data.array[t + 2] = n, this.data.array[t + 3] = o, this
                }
                clone(data) {
                    if (void 0 === data) {
                        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                        const t = [];
                        for (let i = 0; i < this.count; i++) {
                            const e = i * this.data.stride + this.offset;
                            for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[e + r])
                        }
                        return new We(new this.array.constructor(t), this.itemSize, this.normalized)
                    }
                    return void 0 === data.interleavedBuffers && (data.interleavedBuffers = {}), void 0 === data.interleavedBuffers[this.data.uuid] && (data.interleavedBuffers[this.data.uuid] = this.data.clone(data)), new ps(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                }
                toJSON(data) {
                    if (void 0 === data) {
                        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                        const t = [];
                        for (let i = 0; i < this.count; i++) {
                            const e = i * this.data.stride + this.offset;
                            for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[e + r])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: t,
                            normalized: this.normalized
                        }
                    }
                    return void 0 === data.interleavedBuffers && (data.interleavedBuffers = {}), void 0 === data.interleavedBuffers[this.data.uuid] && (data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }
                }
            }
            ps.prototype.isInterleavedBufferAttribute = !0;
            class us extends Ie {
                constructor(t) {
                    super(), this.type = "SpriteMaterial", this.color = new Oe(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.color.copy(source.color), this.map = source.map, this.alphaMap = source.alphaMap, this.rotation = source.rotation, this.sizeAttenuation = source.sizeAttenuation, this
                }
            }
            let ds;
            us.prototype.isSpriteMaterial = !0;
            const ms = new vt,
                fs = new vt,
                gs = new vt,
                ys = new at,
                vs = new at,
                xs = new Jt,
                _s = new vt,
                bs = new vt,
                Ms = new vt,
                Ss = new at,
                ws = new at,
                Es = new at;
            class Ts extends _e {
                constructor(t) {
                    if (super(), this.type = "Sprite", void 0 === ds) {
                        ds = new ii;
                        const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                            e = new ls(t, 5);
                        ds.setIndex([0, 1, 2, 0, 2, 3]), ds.setAttribute("position", new ps(e, 3, 0, !1)), ds.setAttribute("uv", new ps(e, 2, 3, !1))
                    }
                    this.geometry = ds, this.material = void 0 !== t ? t : new us, this.center = new at(.5, .5)
                }
                raycast(t, e) {
                    null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), fs.setFromMatrixScale(this.matrixWorld), xs.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), gs.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && fs.multiplyScalar(-gs.z);
                    const r = this.material.rotation;
                    let n, o;
                    0 !== r && (o = Math.cos(r), n = Math.sin(r));
                    const h = this.center;
                    As(_s.set(-.5, -.5, 0), gs, h, fs, n, o), As(bs.set(.5, -.5, 0), gs, h, fs, n, o), As(Ms.set(.5, .5, 0), gs, h, fs, n, o), Ss.set(0, 0), ws.set(1, 0), Es.set(1, 1);
                    let l = t.ray.intersectTriangle(_s, bs, Ms, !1, ms);
                    if (null === l && (As(bs.set(-.5, .5, 0), gs, h, fs, n, o), ws.set(0, 1), l = t.ray.intersectTriangle(_s, Ms, bs, !1, ms), null === l)) return;
                    const c = t.ray.origin.distanceTo(ms);
                    c < t.near || c > t.far || e.push({
                        distance: c,
                        point: ms.clone(),
                        uv: De.getUV(ms, _s, bs, Ms, Ss, ws, Es, new at),
                        face: null,
                        object: this
                    })
                }
                copy(source) {
                    return super.copy(source), void 0 !== source.center && this.center.copy(source.center), this.material = source.material, this
                }
            }

            function As(t, e, r, n, o, h) {
                ys.subVectors(t, r).addScalar(.5).multiply(n), void 0 !== o ? (vs.x = h * ys.x - o * ys.y, vs.y = o * ys.x + h * ys.y) : vs.copy(ys), t.copy(e), t.x += vs.x, t.y += vs.y, t.applyMatrix4(xs)
            }
            Ts.prototype.isSprite = !0;
            const Ps = new vt,
                Cs = new mt,
                Ls = new mt,
                Ds = new vt,
                Rs = new Jt;
            class Is extends bi {
                constructor(t, e) {
                    super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Jt, this.bindMatrixInverse = new Jt
                }
                copy(source) {
                    return super.copy(source), this.bindMode = source.bindMode, this.bindMatrix.copy(source.bindMatrix), this.bindMatrixInverse.copy(source.bindMatrixInverse), this.skeleton = source.skeleton, this
                }
                bind(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
                }
                pose() {
                    this.skeleton.pose()
                }
                normalizeSkinWeights() {
                    const t = new mt,
                        e = this.geometry.attributes.skinWeight;
                    for (let i = 0, r = e.count; i < r; i++) {
                        t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
                        const r = 1 / t.manhattanLength();
                        r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
                    }
                }
                updateMatrixWorld(t) {
                    super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                }
                boneTransform(t, e) {
                    const r = this.skeleton,
                        n = this.geometry;
                    Cs.fromBufferAttribute(n.attributes.skinIndex, t), Ls.fromBufferAttribute(n.attributes.skinWeight, t), Ps.fromBufferAttribute(n.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                    for (let i = 0; i < 4; i++) {
                        const t = Ls.getComponent(i);
                        if (0 !== t) {
                            const n = Cs.getComponent(i);
                            Rs.multiplyMatrices(r.bones[n].matrixWorld, r.boneInverses[n]), e.addScaledVector(Ds.copy(Ps).applyMatrix4(Rs), t)
                        }
                    }
                    return e.applyMatrix4(this.bindMatrixInverse)
                }
            }
            Is.prototype.isSkinnedMesh = !0;
            class Fs extends _e {
                constructor() {
                    super(), this.type = "Bone"
                }
            }
            Fs.prototype.isBone = !0;
            class ks extends pt {
                constructor(data = null, t = 1, e = 1, r, n, o, h, l, c = 1003, d = 1003, m, f) {
                    super(null, o, h, l, c, d, r, n, m, f), this.image = {
                        data: data,
                        width: t,
                        height: e
                    }, this.magFilter = c, this.minFilter = d, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
                }
            }
            ks.prototype.isDataTexture = !0;
            const Ns = new Jt,
                Bs = new Jt,
                zs = [],
                Vs = new bi;
            class Os extends bi {
                constructor(t, e, r) {
                    super(t, e), this.instanceMatrix = new We(new Float32Array(16 * r), 16), this.instanceColor = null, this.count = r, this.frustumCulled = !1
                }
                copy(source) {
                    return super.copy(source), this.instanceMatrix.copy(source.instanceMatrix), null !== source.instanceColor && (this.instanceColor = source.instanceColor.clone()), this.count = source.count, this
                }
                getColorAt(t, e) {
                    e.fromArray(this.instanceColor.array, 3 * t)
                }
                getMatrixAt(t, e) {
                    e.fromArray(this.instanceMatrix.array, 16 * t)
                }
                raycast(t, e) {
                    const r = this.matrixWorld,
                        n = this.count;
                    if (Vs.geometry = this.geometry, Vs.material = this.material, void 0 !== Vs.material)
                        for (let o = 0; o < n; o++) {
                            this.getMatrixAt(o, Ns), Bs.multiplyMatrices(r, Ns), Vs.matrixWorld = Bs, Vs.raycast(t, zs);
                            for (let i = 0, t = zs.length; i < t; i++) {
                                const t = zs[i];
                                t.instanceId = o, t.object = this, e.push(t)
                            }
                            zs.length = 0
                        }
                }
                setColorAt(t, e) {
                    null === this.instanceColor && (this.instanceColor = new We(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
                }
                setMatrixAt(t, e) {
                    e.toArray(this.instanceMatrix.array, 16 * t)
                }
                updateMorphTargets() {}
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            Os.prototype.isInstancedMesh = !0;
            class Gs extends Ie {
                constructor(t) {
                    super(), this.type = "LineBasicMaterial", this.color = new Oe(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.color.copy(source.color), this.linewidth = source.linewidth, this.linecap = source.linecap, this.linejoin = source.linejoin, this.morphTargets = source.morphTargets, this
                }
            }
            Gs.prototype.isLineBasicMaterial = !0;
            const Hs = new vt,
                Us = new vt,
                Ws = new Jt,
                js = new Yt,
                qs = new Ot;
            class Xs extends _e {
                constructor(t = new ii, e = new Gs) {
                    super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
                }
                copy(source) {
                    return super.copy(source), this.material = source.material, this.geometry = source.geometry, this
                }
                computeLineDistances() {
                    const t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            const e = t.attributes.position,
                                r = [0];
                            for (let i = 1, t = e.count; i < t; i++) Hs.fromBufferAttribute(e, i - 1), Us.fromBufferAttribute(e, i), r[i] = r[i - 1], r[i] += Hs.distanceTo(Us);
                            t.setAttribute("lineDistance", new Xe(r, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                    return this
                }
                raycast(t, e) {
                    const r = this.geometry,
                        n = this.matrixWorld,
                        o = t.params.Line.threshold,
                        h = r.drawRange;
                    if (null === r.boundingSphere && r.computeBoundingSphere(), qs.copy(r.boundingSphere), qs.applyMatrix4(n), qs.radius += o, !1 === t.ray.intersectsSphere(qs)) return;
                    Ws.copy(n).invert(), js.copy(t.ray).applyMatrix4(Ws);
                    const l = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        c = l * l,
                        d = new vt,
                        m = new vt,
                        f = new vt,
                        y = new vt,
                        v = this.isLineSegments ? 2 : 1;
                    if (r.isBufferGeometry) {
                        const n = r.index,
                            o = r.attributes.position;
                        if (null !== n) {
                            for (let i = Math.max(0, h.start), r = Math.min(n.count, h.start + h.count) - 1; i < r; i += v) {
                                const a = n.getX(i),
                                    b = n.getX(i + 1);
                                d.fromBufferAttribute(o, a), m.fromBufferAttribute(o, b);
                                if (js.distanceSqToSegment(d, m, y, f) > c) continue;
                                y.applyMatrix4(this.matrixWorld);
                                const r = t.ray.origin.distanceTo(y);
                                r < t.near || r > t.far || e.push({
                                    distance: r,
                                    point: f.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        } else {
                            for (let i = Math.max(0, h.start), r = Math.min(o.count, h.start + h.count) - 1; i < r; i += v) {
                                d.fromBufferAttribute(o, i), m.fromBufferAttribute(o, i + 1);
                                if (js.distanceSqToSegment(d, m, y, f) > c) continue;
                                y.applyMatrix4(this.matrixWorld);
                                const r = t.ray.origin.distanceTo(y);
                                r < t.near || r > t.far || e.push({
                                    distance: r,
                                    point: f.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                    } else r.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
                updateMorphTargets() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            r = Object.keys(e);
                        if (r.length > 0) {
                            const t = e[r[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            }
            Xs.prototype.isLine = !0;
            const Ys = new vt,
                Js = new vt;
            class Zs extends Xs {
                constructor(t, e) {
                    super(t, e), this.type = "LineSegments"
                }
                computeLineDistances() {
                    const t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            const e = t.attributes.position,
                                r = [];
                            for (let i = 0, t = e.count; i < t; i += 2) Ys.fromBufferAttribute(e, i), Js.fromBufferAttribute(e, i + 1), r[i] = 0 === i ? 0 : r[i - 1], r[i + 1] = r[i] + Ys.distanceTo(Js);
                            t.setAttribute("lineDistance", new Xe(r, 1))
                        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                    return this
                }
            }
            Zs.prototype.isLineSegments = !0;
            class Ks extends Xs {
                constructor(t, e) {
                    super(t, e), this.type = "LineLoop"
                }
            }
            Ks.prototype.isLineLoop = !0;
            class Qs extends Ie {
                constructor(t) {
                    super(), this.type = "PointsMaterial", this.color = new Oe(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.color.copy(source.color), this.map = source.map, this.alphaMap = source.alphaMap, this.size = source.size, this.sizeAttenuation = source.sizeAttenuation, this.morphTargets = source.morphTargets, this
                }
            }
            Qs.prototype.isPointsMaterial = !0;
            const $s = new Jt,
                ta = new Yt,
                ea = new Ot,
                ia = new vt;
            class ra extends _e {
                constructor(t = new ii, e = new Qs) {
                    super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
                }
                copy(source) {
                    return super.copy(source), this.material = source.material, this.geometry = source.geometry, this
                }
                raycast(t, e) {
                    const r = this.geometry,
                        n = this.matrixWorld,
                        o = t.params.Points.threshold,
                        h = r.drawRange;
                    if (null === r.boundingSphere && r.computeBoundingSphere(), ea.copy(r.boundingSphere), ea.applyMatrix4(n), ea.radius += o, !1 === t.ray.intersectsSphere(ea)) return;
                    $s.copy(n).invert(), ta.copy(t.ray).applyMatrix4($s);
                    const l = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        c = l * l;
                    if (r.isBufferGeometry) {
                        const o = r.index,
                            l = r.attributes.position;
                        if (null !== o) {
                            for (let i = Math.max(0, h.start), r = Math.min(o.count, h.start + h.count); i < r; i++) {
                                const a = o.getX(i);
                                ia.fromBufferAttribute(l, a), na(ia, a, c, n, t, e, this)
                            }
                        } else {
                            for (let i = Math.max(0, h.start), r = Math.min(l.count, h.start + h.count); i < r; i++) ia.fromBufferAttribute(l, i), na(ia, i, c, n, t, e, this)
                        }
                    } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
                updateMorphTargets() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            r = Object.keys(e);
                        if (r.length > 0) {
                            const t = e[r[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, r = t.length; e < r; e++) {
                                    const r = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            }

            function na(t, e, r, n, o, h, object) {
                const l = ta.distanceSqToPoint(t);
                if (l < r) {
                    const r = new vt;
                    ta.closestPointToPoint(t, r), r.applyMatrix4(n);
                    const c = o.ray.origin.distanceTo(r);
                    if (c < o.near || c > o.far) return;
                    h.push({
                        distance: c,
                        distanceToRay: Math.sqrt(l),
                        point: r,
                        index: e,
                        face: null,
                        object: object
                    })
                }
            }
            ra.prototype.isPoints = !0;
            (class extends pt {
                constructor(video, t, e, r, n, o, h, l, c) {
                    super(video, t, e, r, n, o, h, l, c), this.format = void 0 !== h ? h : C, this.minFilter = void 0 !== o ? o : _, this.magFilter = void 0 !== n ? n : _, this.generateMipmaps = !1;
                    const d = this;
                    "requestVideoFrameCallback" in video && video.requestVideoFrameCallback((function t() {
                        d.needsUpdate = !0, video.requestVideoFrameCallback(t)
                    }))
                }
                clone() {
                    return new this.constructor(this.image).copy(this)
                }
                update() {
                    const video = this.image;
                    !1 === "requestVideoFrameCallback" in video && video.readyState >= video.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }).prototype.isVideoTexture = !0;
            class sa extends pt {
                constructor(t, e, r, n, o, h, l, c, d, m, f, y) {
                    super(null, h, l, c, d, m, n, o, f, y), this.image = {
                        width: e,
                        height: r
                    }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
                }
            }
            sa.prototype.isCompressedTexture = !0;
            (class extends pt {
                constructor(canvas, t, e, r, n, o, h, l, c) {
                    super(canvas, t, e, r, n, o, h, l, c), this.needsUpdate = !0
                }
            }).prototype.isCanvasTexture = !0;
            (class extends pt {
                constructor(t, e, r, n, o, h, l, c, d, m) {
                    if ((m = void 0 !== m ? m : D) !== D && m !== R) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    void 0 === r && m === D && (r = w), void 0 === r && m === R && (r = P), super(null, n, o, h, l, c, m, r, d), this.image = {
                        width: t,
                        height: e
                    }, this.magFilter = void 0 !== l ? l : y, this.minFilter = void 0 !== c ? c : y, this.flipY = !1, this.generateMipmaps = !1
                }
            }).prototype.isDepthTexture = !0;
            new vt, new vt, new vt, new De;
            class aa {
                constructor() {
                    this.type = "Curve", this.arcLengthDivisions = 200
                }
                getPoint() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                }
                getPointAt(u, t) {
                    const e = this.getUtoTmapping(u);
                    return this.getPoint(e, t)
                }
                getPoints(t = 5) {
                    const e = [];
                    for (let r = 0; r <= t; r++) e.push(this.getPoint(r / t));
                    return e
                }
                getSpacedPoints(t = 5) {
                    const e = [];
                    for (let r = 0; r <= t; r++) e.push(this.getPointAt(r / t));
                    return e
                }
                getLength() {
                    const t = this.getLengths();
                    return t[t.length - 1]
                }
                getLengths(t = this.arcLengthDivisions) {
                    if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    const e = [];
                    let r, n = this.getPoint(0),
                        o = 0;
                    e.push(0);
                    for (let p = 1; p <= t; p++) r = this.getPoint(p / t), o += r.distanceTo(n), e.push(o), n = r;
                    return this.cacheArcLengths = e, e
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.getLengths()
                }
                getUtoTmapping(u, t) {
                    const e = this.getLengths();
                    let i = 0;
                    const r = e.length;
                    let n;
                    n = t || u * e[r - 1];
                    let o, h = 0,
                        l = r - 1;
                    for (; h <= l;)
                        if (i = Math.floor(h + (l - h) / 2), o = e[i] - n, o < 0) h = i + 1;
                        else {
                            if (!(o > 0)) {
                                l = i;
                                break
                            }
                            l = i - 1
                        } if (i = l, e[i] === n) return i / (r - 1);
                    const c = e[i];
                    return (i + (n - c) / (e[i + 1] - c)) / (r - 1)
                }
                getTangent(t, e) {
                    const r = 1e-4;
                    let n = t - r,
                        o = t + r;
                    n < 0 && (n = 0), o > 1 && (o = 1);
                    const h = this.getPoint(n),
                        l = this.getPoint(o),
                        c = e || (h.isVector2 ? new at : new vt);
                    return c.copy(l).sub(h).normalize(), c
                }
                getTangentAt(u, t) {
                    const e = this.getUtoTmapping(u);
                    return this.getTangent(e, t)
                }
                computeFrenetFrames(t, e) {
                    const r = new vt,
                        n = [],
                        o = [],
                        h = [],
                        l = new vt,
                        c = new Jt;
                    for (let i = 0; i <= t; i++) {
                        const u = i / t;
                        n[i] = this.getTangentAt(u, new vt), n[i].normalize()
                    }
                    o[0] = new vt, h[0] = new vt;
                    let d = Number.MAX_VALUE;
                    const m = Math.abs(n[0].x),
                        f = Math.abs(n[0].y),
                        y = Math.abs(n[0].z);
                    m <= d && (d = m, r.set(1, 0, 0)), f <= d && (d = f, r.set(0, 1, 0)), y <= d && r.set(0, 0, 1), l.crossVectors(n[0], r).normalize(), o[0].crossVectors(n[0], l), h[0].crossVectors(n[0], o[0]);
                    for (let i = 1; i <= t; i++) {
                        if (o[i] = o[i - 1].clone(), h[i] = h[i - 1].clone(), l.crossVectors(n[i - 1], n[i]), l.length() > Number.EPSILON) {
                            l.normalize();
                            const t = Math.acos(tt(n[i - 1].dot(n[i]), -1, 1));
                            o[i].applyMatrix4(c.makeRotationAxis(l, t))
                        }
                        h[i].crossVectors(n[i], o[i])
                    }
                    if (!0 === e) {
                        let e = Math.acos(tt(o[0].dot(o[t]), -1, 1));
                        e /= t, n[0].dot(l.crossVectors(o[0], o[t])) > 0 && (e = -e);
                        for (let i = 1; i <= t; i++) o[i].applyMatrix4(c.makeRotationAxis(n[i], e * i)), h[i].crossVectors(n[i], o[i])
                    }
                    return {
                        tangents: n,
                        normals: o,
                        binormals: h
                    }
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(source) {
                    return this.arcLengthDivisions = source.arcLengthDivisions, this
                }
                toJSON() {
                    const data = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return data.arcLengthDivisions = this.arcLengthDivisions, data.type = this.type, data
                }
                fromJSON(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            }
            class oa extends aa {
                constructor(t = 0, e = 0, r = 1, n = 1, o = 0, h = 2 * Math.PI, l = !1, c = 0) {
                    super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = r, this.yRadius = n, this.aStartAngle = o, this.aEndAngle = h, this.aClockwise = l, this.aRotation = c
                }
                getPoint(t, e) {
                    const r = e || new at,
                        n = 2 * Math.PI;
                    let o = this.aEndAngle - this.aStartAngle;
                    const h = Math.abs(o) < Number.EPSILON;
                    for (; o < 0;) o += n;
                    for (; o > n;) o -= n;
                    o < Number.EPSILON && (o = h ? 0 : n), !0 !== this.aClockwise || h || (o === n ? o = -n : o -= n);
                    const l = this.aStartAngle + t * o;
                    let c = this.aX + this.xRadius * Math.cos(l),
                        d = this.aY + this.yRadius * Math.sin(l);
                    if (0 !== this.aRotation) {
                        const t = Math.cos(this.aRotation),
                            e = Math.sin(this.aRotation),
                            r = c - this.aX,
                            n = d - this.aY;
                        c = r * t - n * e + this.aX, d = r * e + n * t + this.aY
                    }
                    return r.set(c, d)
                }
                copy(source) {
                    return super.copy(source), this.aX = source.aX, this.aY = source.aY, this.xRadius = source.xRadius, this.yRadius = source.yRadius, this.aStartAngle = source.aStartAngle, this.aEndAngle = source.aEndAngle, this.aClockwise = source.aClockwise, this.aRotation = source.aRotation, this
                }
                toJSON() {
                    const data = super.toJSON();
                    return data.aX = this.aX, data.aY = this.aY, data.xRadius = this.xRadius, data.yRadius = this.yRadius, data.aStartAngle = this.aStartAngle, data.aEndAngle = this.aEndAngle, data.aClockwise = this.aClockwise, data.aRotation = this.aRotation, data
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                }
            }
            oa.prototype.isEllipseCurve = !0;
            class ha extends oa {
                constructor(t, e, r, n, o, h) {
                    super(t, e, r, r, n, o, h), this.type = "ArcCurve"
                }
            }

            function la() {
                let t = 0,
                    e = 0,
                    r = 0,
                    n = 0;

                function o(o, h, l, c) {
                    t = o, e = l, r = -3 * o + 3 * h - 2 * l - c, n = 2 * o - 2 * h + l + c
                }
                return {
                    initCatmullRom: function (t, e, r, n, h) {
                        o(e, r, h * (r - t), h * (n - e))
                    },
                    initNonuniformCatmullRom: function (t, e, r, n, h, l, c) {
                        let d = (e - t) / h - (r - t) / (h + l) + (r - e) / l,
                            m = (r - e) / l - (n - e) / (l + c) + (n - r) / c;
                        d *= l, m *= l, o(e, r, d, m)
                    },
                    calc: function (o) {
                        const h = o * o;
                        return t + e * o + r * h + n * (h * o)
                    }
                }
            }
            ha.prototype.isArcCurve = !0;
            const ca = new vt,
                pa = new la,
                ua = new la,
                da = new la;
            class ma extends aa {
                constructor(t = [], e = !1, r = "centripetal", n = .5) {
                    super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = r, this.tension = n
                }
                getPoint(t, e = new vt) {
                    const r = e,
                        n = this.points,
                        o = n.length,
                        p = (o - (this.closed ? 0 : 1)) * t;
                    let h, l, c = Math.floor(p),
                        d = p - c;
                    this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / o) + 1) * o : 0 === d && c === o - 1 && (c = o - 2, d = 1), this.closed || c > 0 ? h = n[(c - 1) % o] : (ca.subVectors(n[0], n[1]).add(n[0]), h = ca);
                    const m = n[c % o],
                        f = n[(c + 1) % o];
                    if (this.closed || c + 2 < o ? l = n[(c + 2) % o] : (ca.subVectors(n[o - 1], n[o - 2]).add(n[o - 1]), l = ca), "centripetal" === this.curveType || "chordal" === this.curveType) {
                        const t = "chordal" === this.curveType ? .5 : .25;
                        let e = Math.pow(h.distanceToSquared(m), t),
                            r = Math.pow(m.distanceToSquared(f), t),
                            n = Math.pow(f.distanceToSquared(l), t);
                        r < 1e-4 && (r = 1), e < 1e-4 && (e = r), n < 1e-4 && (n = r), pa.initNonuniformCatmullRom(h.x, m.x, f.x, l.x, e, r, n), ua.initNonuniformCatmullRom(h.y, m.y, f.y, l.y, e, r, n), da.initNonuniformCatmullRom(h.z, m.z, f.z, l.z, e, r, n)
                    } else "catmullrom" === this.curveType && (pa.initCatmullRom(h.x, m.x, f.x, l.x, this.tension), ua.initCatmullRom(h.y, m.y, f.y, l.y, this.tension), da.initCatmullRom(h.z, m.z, f.z, l.z, this.tension));
                    return r.set(pa.calc(d), ua.calc(d), da.calc(d)), r
                }
                copy(source) {
                    super.copy(source), this.points = [];
                    for (let i = 0, t = source.points.length; i < t; i++) {
                        const t = source.points[i];
                        this.points.push(t.clone())
                    }
                    return this.closed = source.closed, this.curveType = source.curveType, this.tension = source.tension, this
                }
                toJSON() {
                    const data = super.toJSON();
                    data.points = [];
                    for (let i = 0, t = this.points.length; i < t; i++) {
                        const t = this.points[i];
                        data.points.push(t.toArray())
                    }
                    return data.closed = this.closed, data.curveType = this.curveType, data.tension = this.tension, data
                }
                fromJSON(t) {
                    super.fromJSON(t), this.points = [];
                    for (let i = 0, e = t.points.length; i < e; i++) {
                        const e = t.points[i];
                        this.points.push((new vt).fromArray(e))
                    }
                    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                }
            }

            function fa(t, e, r, n, o) {
                const h = .5 * (n - e),
                    l = .5 * (o - r),
                    c = t * t;
                return (2 * r - 2 * n + h + l) * (t * c) + (-3 * r + 3 * n - 2 * h - l) * c + h * t + r
            }

            function ga(t, e, r, n) {
                return function (t, p) {
                    const e = 1 - t;
                    return e * e * p
                }(t, e) + function (t, p) {
                    return 2 * (1 - t) * t * p
                }(t, r) + function (t, p) {
                    return t * t * p
                }(t, n)
            }

            function ya(t, e, r, n, o) {
                return function (t, p) {
                    const e = 1 - t;
                    return e * e * e * p
                }(t, e) + function (t, p) {
                    const e = 1 - t;
                    return 3 * e * e * t * p
                }(t, r) + function (t, p) {
                    return 3 * (1 - t) * t * t * p
                }(t, n) + function (t, p) {
                    return t * t * t * p
                }(t, o)
            }
            ma.prototype.isCatmullRomCurve3 = !0;
            class va extends aa {
                constructor(t = new at, e = new at, r = new at, n = new at) {
                    super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = r, this.v3 = n
                }
                getPoint(t, e = new at) {
                    const r = e,
                        n = this.v0,
                        o = this.v1,
                        h = this.v2,
                        l = this.v3;
                    return r.set(ya(t, n.x, o.x, h.x, l.x), ya(t, n.y, o.y, h.y, l.y)), r
                }
                copy(source) {
                    return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this.v3.copy(source.v3), this
                }
                toJSON() {
                    const data = super.toJSON();
                    return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data.v3 = this.v3.toArray(), data
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                }
            }
            va.prototype.isCubicBezierCurve = !0;
            class xa extends aa {
                constructor(t = new vt, e = new vt, r = new vt, n = new vt) {
                    super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = r, this.v3 = n
                }
                getPoint(t, e = new vt) {
                    const r = e,
                        n = this.v0,
                        o = this.v1,
                        h = this.v2,
                        l = this.v3;
                    return r.set(ya(t, n.x, o.x, h.x, l.x), ya(t, n.y, o.y, h.y, l.y), ya(t, n.z, o.z, h.z, l.z)), r
                }
                copy(source) {
                    return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this.v3.copy(source.v3), this
                }
                toJSON() {
                    const data = super.toJSON();
                    return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data.v3 = this.v3.toArray(), data
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                }
            }
            xa.prototype.isCubicBezierCurve3 = !0;
            class _a extends aa {
                constructor(t = new at, e = new at) {
                    super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
                }
                getPoint(t, e = new at) {
                    const r = e;
                    return 1 === t ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(t).add(this.v1)), r
                }
                getPointAt(u, t) {
                    return this.getPoint(u, t)
                }
                getTangent(t, e) {
                    const r = e || new at;
                    return r.copy(this.v2).sub(this.v1).normalize(), r
                }
                copy(source) {
                    return super.copy(source), this.v1.copy(source.v1), this.v2.copy(source.v2), this
                }
                toJSON() {
                    const data = super.toJSON();
                    return data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            }
            _a.prototype.isLineCurve = !0;
            class ba extends aa {
                constructor(t = new at, e = new at, r = new at) {
                    super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = r
                }
                getPoint(t, e = new at) {
                    const r = e,
                        n = this.v0,
                        o = this.v1,
                        h = this.v2;
                    return r.set(ga(t, n.x, o.x, h.x), ga(t, n.y, o.y, h.y)), r
                }
                copy(source) {
                    return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this
                }
                toJSON() {
                    const data = super.toJSON();
                    return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            }
            ba.prototype.isQuadraticBezierCurve = !0;
            class Ma extends aa {
                constructor(t = new vt, e = new vt, r = new vt) {
                    super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = r
                }
                getPoint(t, e = new vt) {
                    const r = e,
                        n = this.v0,
                        o = this.v1,
                        h = this.v2;
                    return r.set(ga(t, n.x, o.x, h.x), ga(t, n.y, o.y, h.y), ga(t, n.z, o.z, h.z)), r
                }
                copy(source) {
                    return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this
                }
                toJSON() {
                    const data = super.toJSON();
                    return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            }
            Ma.prototype.isQuadraticBezierCurve3 = !0;
            class Sa extends aa {
                constructor(t = []) {
                    super(), this.type = "SplineCurve", this.points = t
                }
                getPoint(t, e = new at) {
                    const r = e,
                        n = this.points,
                        p = (n.length - 1) * t,
                        o = Math.floor(p),
                        h = p - o,
                        l = n[0 === o ? o : o - 1],
                        c = n[o],
                        d = n[o > n.length - 2 ? n.length - 1 : o + 1],
                        m = n[o > n.length - 3 ? n.length - 1 : o + 2];
                    return r.set(fa(h, l.x, c.x, d.x, m.x), fa(h, l.y, c.y, d.y, m.y)), r
                }
                copy(source) {
                    super.copy(source), this.points = [];
                    for (let i = 0, t = source.points.length; i < t; i++) {
                        const t = source.points[i];
                        this.points.push(t.clone())
                    }
                    return this
                }
                toJSON() {
                    const data = super.toJSON();
                    data.points = [];
                    for (let i = 0, t = this.points.length; i < t; i++) {
                        const t = this.points[i];
                        data.points.push(t.toArray())
                    }
                    return data
                }
                fromJSON(t) {
                    super.fromJSON(t), this.points = [];
                    for (let i = 0, e = t.points.length; i < e; i++) {
                        const e = t.points[i];
                        this.points.push((new at).fromArray(e))
                    }
                    return this
                }
            }
            Sa.prototype.isSplineCurve = !0;
            var wa = Object.freeze({
                __proto__: null,
                ArcCurve: ha,
                CatmullRomCurve3: ma,
                CubicBezierCurve: va,
                CubicBezierCurve3: xa,
                EllipseCurve: oa,
                LineCurve: _a,
                LineCurve3: class extends aa {
                    constructor(t = new vt, e = new vt) {
                        super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
                    }
                    getPoint(t, e = new vt) {
                        const r = e;
                        return 1 === t ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(t).add(this.v1)), r
                    }
                    getPointAt(u, t) {
                        return this.getPoint(u, t)
                    }
                    copy(source) {
                        return super.copy(source), this.v1.copy(source.v1), this.v2.copy(source.v2), this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        return data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                },
                QuadraticBezierCurve: ba,
                QuadraticBezierCurve3: Ma,
                SplineCurve: Sa
            });
            const Ea = function (data, t, e = 2) {
                const r = t && t.length,
                    n = r ? t[0] * e : data.length;
                let o = Ta(data, 0, n, e, !0);
                const h = [];
                if (!o || o.next === o.prev) return h;
                let l, c, d, m, f, y, v;
                if (r && (o = function (data, t, e, r) {
                        const n = [];
                        let i, o, h, l, c;
                        for (i = 0, o = t.length; i < o; i++) h = t[i] * r, l = i < o - 1 ? t[i + 1] * r : data.length, c = Ta(data, h, l, r, !1), c === c.next && (c.steiner = !0), n.push(Ba(c));
                        for (n.sort(Ia), i = 0; i < n.length; i++) Fa(n[i], e), e = Aa(e, e.next);
                        return e
                    }(data, t, o, e)), data.length > 80 * e) {
                    l = d = data[0], c = m = data[1];
                    for (let i = e; i < n; i += e) f = data[i], y = data[i + 1], f < l && (l = f), y < c && (c = y), f > d && (d = f), y > m && (m = y);
                    v = Math.max(d - l, m - c), v = 0 !== v ? 1 / v : 0
                }
                return Pa(o, h, e, l, c, v), h
            };

            function Ta(data, t, e, r, n) {
                let i, o;
                if (n === function (data, t, e, r) {
                        let n = 0;
                        for (let i = t, o = e - r; i < e; i += r) n += (data[o] - data[i]) * (data[i + 1] + data[o + 1]), o = i;
                        return n
                    }(data, t, e, r) > 0)
                    for (i = t; i < e; i += r) o = qa(i, data[i], data[i + 1], o);
                else
                    for (i = e - r; i >= t; i -= r) o = qa(i, data[i], data[i + 1], o);
                return o && Oa(o, o.next) && (Xa(o), o = o.next), o
            }

            function Aa(t, e) {
                if (!t) return t;
                e || (e = t);
                let r, p = t;
                do {
                    if (r = !1, p.steiner || !Oa(p, p.next) && 0 !== area(p.prev, p, p.next)) p = p.next;
                    else {
                        if (Xa(p), p = e = p.prev, p === p.next) break;
                        r = !0
                    }
                } while (r || p !== e);
                return e
            }

            function Pa(t, e, r, n, o, h, l) {
                if (!t) return;
                !l && h && function (t, e, r, n) {
                    let p = t;
                    do {
                        null === p.z && (p.z = Na(p.x, p.y, e, r, n)), p.prevZ = p.prev, p.nextZ = p.next, p = p.next
                    } while (p !== t);
                    p.prevZ.nextZ = null, p.prevZ = null,
                        function (t) {
                            let i, p, q, e, r, n, o, h, l = 1;
                            do {
                                for (p = t, t = null, r = null, n = 0; p;) {
                                    for (n++, q = p, o = 0, i = 0; i < l && (o++, q = q.nextZ, q); i++);
                                    for (h = l; o > 0 || h > 0 && q;) 0 !== o && (0 === h || !q || p.z <= q.z) ? (e = p, p = p.nextZ, o--) : (e = q, q = q.nextZ, h--), r ? r.nextZ = e : t = e, e.prevZ = r, r = e;
                                    p = q
                                }
                                r.nextZ = null, l *= 2
                            } while (n > 1)
                        }(p)
                }(t, n, o, h);
                let c, d, m = t;
                for (; t.prev !== t.next;)
                    if (c = t.prev, d = t.next, h ? La(t, n, o, h) : Ca(t)) e.push(c.i / r), e.push(t.i / r), e.push(d.i / r), Xa(t), t = d.next, m = d.next;
                    else if ((t = d) === m) {
                    l ? 1 === l ? Pa(t = Da(Aa(t), e, r), e, r, n, o, h, 2) : 2 === l && Ra(t, e, r, n, o, h) : Pa(Aa(t), e, r, n, o, h, 1);
                    break
                }
            }

            function Ca(t) {
                const a = t.prev,
                    b = t,
                    e = t.next;
                if (area(a, b, e) >= 0) return !1;
                let p = t.next.next;
                for (; p !== t.prev;) {
                    if (za(a.x, a.y, b.x, b.y, e.x, e.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
                    p = p.next
                }
                return !0
            }

            function La(t, e, r, n) {
                const a = t.prev,
                    b = t,
                    o = t.next;
                if (area(a, b, o) >= 0) return !1;
                const h = a.x < b.x ? a.x < o.x ? a.x : o.x : b.x < o.x ? b.x : o.x,
                    l = a.y < b.y ? a.y < o.y ? a.y : o.y : b.y < o.y ? b.y : o.y,
                    c = a.x > b.x ? a.x > o.x ? a.x : o.x : b.x > o.x ? b.x : o.x,
                    d = a.y > b.y ? a.y > o.y ? a.y : o.y : b.y > o.y ? b.y : o.y,
                    m = Na(h, l, e, r, n),
                    f = Na(c, d, e, r, n);
                let p = t.prevZ,
                    y = t.nextZ;
                for (; p && p.z >= m && y && y.z <= f;) {
                    if (p !== t.prev && p !== t.next && za(a.x, a.y, b.x, b.y, o.x, o.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
                    if (p = p.prevZ, y !== t.prev && y !== t.next && za(a.x, a.y, b.x, b.y, o.x, o.y, y.x, y.y) && area(y.prev, y, y.next) >= 0) return !1;
                    y = y.nextZ
                }
                for (; p && p.z >= m;) {
                    if (p !== t.prev && p !== t.next && za(a.x, a.y, b.x, b.y, o.x, o.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                for (; y && y.z <= f;) {
                    if (y !== t.prev && y !== t.next && za(a.x, a.y, b.x, b.y, o.x, o.y, y.x, y.y) && area(y.prev, y, y.next) >= 0) return !1;
                    y = y.nextZ
                }
                return !0
            }

            function Da(t, e, r) {
                let p = t;
                do {
                    const a = p.prev,
                        b = p.next.next;
                    !Oa(a, b) && Ga(a, p, p.next, b) && Wa(a, b) && Wa(b, a) && (e.push(a.i / r), e.push(p.i / r), e.push(b.i / r), Xa(p), Xa(p.next), p = t = b), p = p.next
                } while (p !== t);
                return Aa(p)
            }

            function Ra(t, e, r, n, o, h) {
                let a = t;
                do {
                    let b = a.next.next;
                    for (; b !== a.prev;) {
                        if (a.i !== b.i && Va(a, b)) {
                            let t = ja(a, b);
                            return a = Aa(a, a.next), t = Aa(t, t.next), Pa(a, e, r, n, o, h), void Pa(t, e, r, n, o, h)
                        }
                        b = b.next
                    }
                    a = a.next
                } while (a !== t)
            }

            function Ia(a, b) {
                return a.x - b.x
            }

            function Fa(t, e) {
                if (e = function (t, e) {
                        let p = e;
                        const r = t.x,
                            n = t.y;
                        let o, h = -1 / 0;
                        do {
                            if (n <= p.y && n >= p.next.y && p.next.y !== p.y) {
                                const t = p.x + (n - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                                if (t <= r && t > h) {
                                    if (h = t, t === r) {
                                        if (n === p.y) return p;
                                        if (n === p.next.y) return p.next
                                    }
                                    o = p.x < p.next.x ? p : p.next
                                }
                            }
                            p = p.next
                        } while (p !== e);
                        if (!o) return null;
                        if (r === h) return o;
                        const l = o,
                            c = o.x,
                            d = o.y;
                        let m, f = 1 / 0;
                        p = o;
                        do {
                            r >= p.x && p.x >= c && r !== p.x && za(n < d ? r : h, n, c, d, n < d ? h : r, n, p.x, p.y) && (m = Math.abs(n - p.y) / (r - p.x), Wa(p, t) && (m < f || m === f && (p.x > o.x || p.x === o.x && ka(o, p))) && (o = p, f = m)), p = p.next
                        } while (p !== l);
                        return o
                    }(t, e)) {
                    const b = ja(e, t);
                    Aa(e, e.next), Aa(b, b.next)
                }
            }

            function ka(t, p) {
                return area(t.prev, t, p.prev) < 0 && area(p.next, t, t.next) < 0
            }

            function Na(t, e, r, n, o) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * o) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * o) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }

            function Ba(t) {
                let p = t,
                    e = t;
                do {
                    (p.x < e.x || p.x === e.x && p.y < e.y) && (e = p), p = p.next
                } while (p !== t);
                return e
            }

            function za(t, e, r, n, o, h, l, c) {
                return (o - l) * (e - c) - (t - l) * (h - c) >= 0 && (t - l) * (n - c) - (r - l) * (e - c) >= 0 && (r - l) * (h - c) - (o - l) * (n - c) >= 0
            }

            function Va(a, b) {
                return a.next.i !== b.i && a.prev.i !== b.i && ! function (a, b) {
                    let p = a;
                    do {
                        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && Ga(p, p.next, a, b)) return !0;
                        p = p.next
                    } while (p !== a);
                    return !1
                }(a, b) && (Wa(a, b) && Wa(b, a) && function (a, b) {
                    let p = a,
                        t = !1;
                    const e = (a.x + b.x) / 2,
                        r = (a.y + b.y) / 2;
                    do {
                        p.y > r != p.next.y > r && p.next.y !== p.y && e < (p.next.x - p.x) * (r - p.y) / (p.next.y - p.y) + p.x && (t = !t), p = p.next
                    } while (p !== a);
                    return t
                }(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || Oa(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0)
            }

            function area(p, q, t) {
                return (q.y - p.y) * (t.x - q.x) - (q.x - p.x) * (t.y - q.y)
            }

            function Oa(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function Ga(t, e, r, n) {
                const o = Ua(area(t, e, r)),
                    h = Ua(area(t, e, n)),
                    l = Ua(area(r, n, t)),
                    c = Ua(area(r, n, e));
                return o !== h && l !== c || (!(0 !== o || !Ha(t, r, e)) || (!(0 !== h || !Ha(t, n, e)) || (!(0 !== l || !Ha(r, t, n)) || !(0 !== c || !Ha(r, e, n)))))
            }

            function Ha(p, q, t) {
                return q.x <= Math.max(p.x, t.x) && q.x >= Math.min(p.x, t.x) && q.y <= Math.max(p.y, t.y) && q.y >= Math.min(p.y, t.y)
            }

            function Ua(t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0
            }

            function Wa(a, b) {
                return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0
            }

            function ja(a, b) {
                const t = new Ya(a.i, a.x, a.y),
                    e = new Ya(b.i, b.x, b.y),
                    r = a.next,
                    n = b.prev;
                return a.next = b, b.prev = a, t.next = r, r.prev = t, e.next = t, t.prev = e, n.next = e, e.prev = n, e
            }

            function qa(i, t, e, r) {
                const p = new Ya(i, t, e);
                return r ? (p.next = r.next, p.prev = r, r.next.prev = p, r.next = p) : (p.prev = p, p.next = p), p
            }

            function Xa(p) {
                p.next.prev = p.prev, p.prev.next = p.next, p.prevZ && (p.prevZ.nextZ = p.nextZ), p.nextZ && (p.nextZ.prevZ = p.prevZ)
            }

            function Ya(i, t, e) {
                this.i = i, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            class Ja {
                static area(t) {
                    const e = t.length;
                    let a = 0;
                    for (let p = e - 1, q = 0; q < e; p = q++) a += t[p].x * t[q].y - t[q].x * t[p].y;
                    return .5 * a
                }
                static isClockWise(t) {
                    return Ja.area(t) < 0
                }
                static triangulateShape(t, e) {
                    const r = [],
                        n = [],
                        o = [];
                    Za(t), Ka(r, t);
                    let h = t.length;
                    e.forEach(Za);
                    for (let i = 0; i < e.length; i++) n.push(h), h += e[i].length, Ka(r, e[i]);
                    const l = Ea(r, n);
                    for (let i = 0; i < l.length; i += 3) o.push(l.slice(i, i + 3));
                    return o
                }
            }

            function Za(t) {
                const e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }

            function Ka(t, e) {
                for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
            }
            class Qa extends ii {
                constructor(t, e) {
                    super(), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: t,
                        options: e
                    }, t = Array.isArray(t) ? t : [t];
                    const r = this,
                        n = [],
                        o = [];
                    for (let i = 0, e = t.length; i < e; i++) {
                        h(t[i])
                    }

                    function h(t) {
                        const h = [],
                            l = void 0 !== e.curveSegments ? e.curveSegments : 12,
                            c = void 0 !== e.steps ? e.steps : 1;
                        let d = void 0 !== e.depth ? e.depth : 100,
                            m = void 0 === e.bevelEnabled || e.bevelEnabled,
                            f = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                            y = void 0 !== e.bevelSize ? e.bevelSize : f - 2,
                            v = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                            x = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                        const _ = e.extrudePath,
                            M = void 0 !== e.UVGenerator ? e.UVGenerator : $a;
                        void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), d = e.amount);
                        let S, w, E, T, A, P = !1;
                        _ && (S = _.getSpacedPoints(c), P = !0, m = !1, w = _.computeFrenetFrames(c, !1), E = new vt, T = new vt, A = new vt), m || (x = 0, f = 0, y = 0, v = 0);
                        const C = t.extractPoints(l);
                        let L = C.shape;
                        const D = C.holes;
                        if (!Ja.isClockWise(L)) {
                            L = L.reverse();
                            for (let t = 0, e = D.length; t < e; t++) {
                                const e = D[t];
                                Ja.isClockWise(e) && (D[t] = e.reverse())
                            }
                        }
                        const R = Ja.triangulateShape(L, D),
                            I = L;
                        for (let t = 0, e = D.length; t < e; t++) {
                            const e = D[t];
                            L = L.concat(e)
                        }

                        function F(t, e, r) {
                            return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(r).add(t)
                        }
                        const k = L.length,
                            N = R.length;

                        function B(t, e, r) {
                            let n, o, h;
                            const l = t.x - e.x,
                                c = t.y - e.y,
                                d = r.x - t.x,
                                m = r.y - t.y,
                                f = l * l + c * c,
                                y = l * m - c * d;
                            if (Math.abs(y) > Number.EPSILON) {
                                const y = Math.sqrt(f),
                                    v = Math.sqrt(d * d + m * m),
                                    x = e.x - c / y,
                                    _ = e.y + l / y,
                                    M = ((r.x - m / v - x) * m - (r.y + d / v - _) * d) / (l * m - c * d);
                                n = x + l * M - t.x, o = _ + c * M - t.y;
                                const S = n * n + o * o;
                                if (S <= 2) return new at(n, o);
                                h = Math.sqrt(S / 2)
                            } else {
                                let t = !1;
                                l > Number.EPSILON ? d > Number.EPSILON && (t = !0) : l < -Number.EPSILON ? d < -Number.EPSILON && (t = !0) : Math.sign(c) === Math.sign(m) && (t = !0), t ? (n = -c, o = l, h = Math.sqrt(f)) : (n = l, o = c, h = Math.sqrt(f / 2))
                            }
                            return new at(n / h, o / h)
                        }
                        const z = [];
                        for (let i = 0, t = I.length, e = t - 1, r = i + 1; i < t; i++, e++, r++) e === t && (e = 0), r === t && (r = 0), z[i] = B(I[i], I[e], I[r]);
                        const V = [];
                        let O, G = z.concat();
                        for (let t = 0, e = D.length; t < e; t++) {
                            const e = D[t];
                            O = [];
                            for (let i = 0, t = e.length, r = t - 1, n = i + 1; i < t; i++, r++, n++) r === t && (r = 0), n === t && (n = 0), O[i] = B(e[i], e[r], e[n]);
                            V.push(O), G = G.concat(O)
                        }
                        for (let b = 0; b < x; b++) {
                            const t = b / x,
                                e = f * Math.cos(t * Math.PI / 2),
                                r = y * Math.sin(t * Math.PI / 2) + v;
                            for (let i = 0, t = I.length; i < t; i++) {
                                const t = F(I[i], z[i], r);
                                W(t.x, t.y, -e)
                            }
                            for (let t = 0, n = D.length; t < n; t++) {
                                const n = D[t];
                                O = V[t];
                                for (let i = 0, t = n.length; i < t; i++) {
                                    const t = F(n[i], O[i], r);
                                    W(t.x, t.y, -e)
                                }
                            }
                        }
                        const H = y + v;
                        for (let i = 0; i < k; i++) {
                            const t = m ? F(L[i], G[i], H) : L[i];
                            P ? (T.copy(w.normals[0]).multiplyScalar(t.x), E.copy(w.binormals[0]).multiplyScalar(t.y), A.copy(S[0]).add(T).add(E), W(A.x, A.y, A.z)) : W(t.x, t.y, 0)
                        }
                        for (let s = 1; s <= c; s++)
                            for (let i = 0; i < k; i++) {
                                const t = m ? F(L[i], G[i], H) : L[i];
                                P ? (T.copy(w.normals[s]).multiplyScalar(t.x), E.copy(w.binormals[s]).multiplyScalar(t.y), A.copy(S[s]).add(T).add(E), W(A.x, A.y, A.z)) : W(t.x, t.y, d / c * s)
                            }
                        for (let b = x - 1; b >= 0; b--) {
                            const t = b / x,
                                e = f * Math.cos(t * Math.PI / 2),
                                r = y * Math.sin(t * Math.PI / 2) + v;
                            for (let i = 0, t = I.length; i < t; i++) {
                                const t = F(I[i], z[i], r);
                                W(t.x, t.y, d + e)
                            }
                            for (let t = 0, n = D.length; t < n; t++) {
                                const n = D[t];
                                O = V[t];
                                for (let i = 0, t = n.length; i < t; i++) {
                                    const t = F(n[i], O[i], r);
                                    P ? W(t.x, t.y + S[c - 1].y, S[c - 1].x + e) : W(t.x, t.y, d + e)
                                }
                            }
                        }

                        function U(t, e) {
                            let i = t.length;
                            for (; --i >= 0;) {
                                const r = i;
                                let n = i - 1;
                                n < 0 && (n = t.length - 1);
                                for (let s = 0, t = c + 2 * x; s < t; s++) {
                                    const t = k * s,
                                        o = k * (s + 1);
                                    X(e + r + t, e + n + t, e + n + o, e + r + o)
                                }
                            }
                        }

                        function W(t, e, r) {
                            h.push(t), h.push(e), h.push(r)
                        }

                        function j(a, b, t) {
                            Y(a), Y(b), Y(t);
                            const e = n.length / 3,
                                o = M.generateTopUV(r, n, e - 3, e - 2, e - 1);
                            J(o[0]), J(o[1]), J(o[2])
                        }

                        function X(a, b, t, e) {
                            Y(a), Y(b), Y(e), Y(b), Y(t), Y(e);
                            const o = n.length / 3,
                                h = M.generateSideWallUV(r, n, o - 6, o - 3, o - 2, o - 1);
                            J(h[0]), J(h[1]), J(h[3]), J(h[1]), J(h[2]), J(h[3])
                        }

                        function Y(t) {
                            n.push(h[3 * t + 0]), n.push(h[3 * t + 1]), n.push(h[3 * t + 2])
                        }

                        function J(t) {
                            o.push(t.x), o.push(t.y)
                        }! function () {
                            const t = n.length / 3;
                            if (m) {
                                let t = 0,
                                    e = k * t;
                                for (let i = 0; i < N; i++) {
                                    const t = R[i];
                                    j(t[2] + e, t[1] + e, t[0] + e)
                                }
                                t = c + 2 * x, e = k * t;
                                for (let i = 0; i < N; i++) {
                                    const t = R[i];
                                    j(t[0] + e, t[1] + e, t[2] + e)
                                }
                            } else {
                                for (let i = 0; i < N; i++) {
                                    const t = R[i];
                                    j(t[2], t[1], t[0])
                                }
                                for (let i = 0; i < N; i++) {
                                    const t = R[i];
                                    j(t[0] + k * c, t[1] + k * c, t[2] + k * c)
                                }
                            }
                            r.addGroup(t, n.length / 3 - t, 0)
                        }(),
                        function () {
                            const t = n.length / 3;
                            let e = 0;
                            U(I, e), e += I.length;
                            for (let t = 0, r = D.length; t < r; t++) {
                                const r = D[t];
                                U(r, e), e += r.length
                            }
                            r.addGroup(t, n.length / 3 - t, 1)
                        }()
                    }
                    this.setAttribute("position", new Xe(n, 3)), this.setAttribute("uv", new Xe(o, 2)), this.computeVertexNormals()
                }
                toJSON() {
                    const data = super.toJSON();
                    return function (t, e, data) {
                        if (data.shapes = [], Array.isArray(t))
                            for (let i = 0, e = t.length; i < e; i++) {
                                const e = t[i];
                                data.shapes.push(e.uuid)
                            } else data.shapes.push(t.uuid);
                        void 0 !== e.extrudePath && (data.options.extrudePath = e.extrudePath.toJSON());
                        return data
                    }(this.parameters.shapes, this.parameters.options, data)
                }
                static fromJSON(data, t) {
                    const e = [];
                    for (let r = 0, n = data.shapes.length; r < n; r++) {
                        const n = t[data.shapes[r]];
                        e.push(n)
                    }
                    const r = data.options.extrudePath;
                    return void 0 !== r && (data.options.extrudePath = (new wa[r.type]).fromJSON(r)), new Qa(e, data.options)
                }
            }
            const $a = {
                generateTopUV: function (t, e, r, n, o) {
                    const h = e[3 * r],
                        l = e[3 * r + 1],
                        c = e[3 * n],
                        d = e[3 * n + 1],
                        m = e[3 * o],
                        f = e[3 * o + 1];
                    return [new at(h, l), new at(c, d), new at(m, f)]
                },
                generateSideWallUV: function (t, e, r, n, o, h) {
                    const l = e[3 * r],
                        c = e[3 * r + 1],
                        d = e[3 * r + 2],
                        m = e[3 * n],
                        f = e[3 * n + 1],
                        y = e[3 * n + 2],
                        v = e[3 * o],
                        x = e[3 * o + 1],
                        _ = e[3 * o + 2],
                        M = e[3 * h],
                        S = e[3 * h + 1],
                        w = e[3 * h + 2];
                    return Math.abs(c - f) < Math.abs(l - m) ? [new at(l, 1 - d), new at(m, 1 - y), new at(v, 1 - _), new at(M, 1 - w)] : [new at(c, 1 - d), new at(f, 1 - y), new at(x, 1 - _), new at(S, 1 - w)]
                }
            };
            class to extends ii {
                constructor(t, e = 12) {
                    super(), this.type = "ShapeGeometry", this.parameters = {
                        shapes: t,
                        curveSegments: e
                    };
                    const r = [],
                        n = [],
                        o = [],
                        h = [];
                    let l = 0,
                        c = 0;
                    if (!1 === Array.isArray(t)) d(t);
                    else
                        for (let i = 0; i < t.length; i++) d(t[i]), this.addGroup(l, c, i), l += c, c = 0;

                    function d(t) {
                        const l = n.length / 3,
                            d = t.extractPoints(e);
                        let m = d.shape;
                        const f = d.holes;
                        !1 === Ja.isClockWise(m) && (m = m.reverse());
                        for (let i = 0, t = f.length; i < t; i++) {
                            const t = f[i];
                            !0 === Ja.isClockWise(t) && (f[i] = t.reverse())
                        }
                        const y = Ja.triangulateShape(m, f);
                        for (let i = 0, t = f.length; i < t; i++) {
                            const t = f[i];
                            m = m.concat(t)
                        }
                        for (let i = 0, t = m.length; i < t; i++) {
                            const t = m[i];
                            n.push(t.x, t.y, 0), o.push(0, 0, 1), h.push(t.x, t.y)
                        }
                        for (let i = 0, t = y.length; i < t; i++) {
                            const t = y[i],
                                a = t[0] + l,
                                b = t[1] + l,
                                e = t[2] + l;
                            r.push(a, b, e), c += 3
                        }
                    }
                    this.setIndex(r), this.setAttribute("position", new Xe(n, 3)), this.setAttribute("normal", new Xe(o, 3)), this.setAttribute("uv", new Xe(h, 2))
                }
                toJSON() {
                    const data = super.toJSON();
                    return function (t, data) {
                        if (data.shapes = [], Array.isArray(t))
                            for (let i = 0, e = t.length; i < e; i++) {
                                const e = t[i];
                                data.shapes.push(e.uuid)
                            } else data.shapes.push(t.uuid);
                        return data
                    }(this.parameters.shapes, data)
                }
                static fromJSON(data, t) {
                    const e = [];
                    for (let r = 0, n = data.shapes.length; r < n; r++) {
                        const n = t[data.shapes[r]];
                        e.push(n)
                    }
                    return new to(e, data.curveSegments)
                }
            }
            class eo extends Ie {
                constructor(t) {
                    super(), this.type = "ShadowMaterial", this.color = new Oe(0), this.transparent = !0, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.color.copy(source.color), this
                }
            }
            eo.prototype.isShadowMaterial = !0;
            class io extends Ai {
                constructor(t) {
                    super(t), this.type = "RawShaderMaterial"
                }
            }
            io.prototype.isRawShaderMaterial = !0;
            class ro extends Ie {
                constructor(t) {
                    super(), this.defines = {
                        STANDARD: ""
                    }, this.type = "MeshStandardMaterial", this.color = new Oe(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Oe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new at(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.defines = {
                        STANDARD: ""
                    }, this.color.copy(source.color), this.roughness = source.roughness, this.metalness = source.metalness, this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.roughnessMap = source.roughnessMap, this.metalnessMap = source.metalnessMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.envMapIntensity = source.envMapIntensity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, this.flatShading = source.flatShading, this.vertexTangents = source.vertexTangents, this
                }
            }
            ro.prototype.isMeshStandardMaterial = !0;
            class no extends ro {
                constructor(t) {
                    super(), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new at(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", {
                        get: function () {
                            return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                        },
                        set: function (t) {
                            this.reflectivity = tt(2.5 * (t - 1) / (t + 1), 0, 1)
                        }
                    }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Oe(1, 1, 1), this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    }, this.clearcoat = source.clearcoat, this.clearcoatMap = source.clearcoatMap, this.clearcoatRoughness = source.clearcoatRoughness, this.clearcoatRoughnessMap = source.clearcoatRoughnessMap, this.clearcoatNormalMap = source.clearcoatNormalMap, this.clearcoatNormalScale.copy(source.clearcoatNormalScale), this.reflectivity = source.reflectivity, source.sheen ? this.sheen = (this.sheen || new Oe).copy(source.sheen) : this.sheen = null, this.transmission = source.transmission, this.transmissionMap = source.transmissionMap, this.thickness = source.thickness, this.thicknessMap = source.thicknessMap, this.attenuationDistance = source.attenuationDistance, this.attenuationColor.copy(source.attenuationColor), this
                }
            }
            no.prototype.isMeshPhysicalMaterial = !0;
            class so extends Ie {
                constructor(t) {
                    super(), this.type = "MeshPhongMaterial", this.color = new Oe(16777215), this.specular = new Oe(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Oe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new at(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.color.copy(source.color), this.specular.copy(source.specular), this.shininess = source.shininess, this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, this.flatShading = source.flatShading, this
                }
            }
            so.prototype.isMeshPhongMaterial = !0;
            class ao extends Ie {
                constructor(t) {
                    super(), this.defines = {
                        TOON: ""
                    }, this.type = "MeshToonMaterial", this.color = new Oe(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Oe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new at(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.color.copy(source.color), this.map = source.map, this.gradientMap = source.gradientMap, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.alphaMap = source.alphaMap, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, this
                }
            }
            ao.prototype.isMeshToonMaterial = !0;
            class oo extends Ie {
                constructor(t) {
                    super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new at(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, this.flatShading = source.flatShading, this
                }
            }
            oo.prototype.isMeshNormalMaterial = !0;
            class ho extends Ie {
                constructor(t) {
                    super(), this.type = "MeshLambertMaterial", this.color = new Oe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Oe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.color.copy(source.color), this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, this
                }
            }
            ho.prototype.isMeshLambertMaterial = !0;
            class lo extends Ie {
                constructor(t) {
                    super(), this.defines = {
                        MATCAP: ""
                    }, this.type = "MeshMatcapMaterial", this.color = new Oe(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new at(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.defines = {
                        MATCAP: ""
                    }, this.color.copy(source.color), this.matcap = source.matcap, this.map = source.map, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.alphaMap = source.alphaMap, this.morphTargets = source.morphTargets, this.morphNormals = source.morphNormals, this.flatShading = source.flatShading, this
                }
            }
            lo.prototype.isMeshMatcapMaterial = !0;
            class co extends Gs {
                constructor(t) {
                    super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
                }
                copy(source) {
                    return super.copy(source), this.scale = source.scale, this.dashSize = source.dashSize, this.gapSize = source.gapSize, this
                }
            }
            co.prototype.isLineDashedMaterial = !0;
            const po = {
                arraySlice: function (t, e, r) {
                    return po.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== r ? r : t.length)) : t.slice(e, r)
                },
                convertArray: function (t, e, r) {
                    return !t || !r && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                },
                isTypedArray: function (object) {
                    return ArrayBuffer.isView(object) && !(object instanceof DataView)
                },
                getKeyframeOrder: function (t) {
                    const e = t.length,
                        r = new Array(e);
                    for (let i = 0; i !== e; ++i) r[i] = i;
                    return r.sort((function (i, e) {
                        return t[i] - t[e]
                    })), r
                },
                sortedArray: function (t, e, r) {
                    const n = t.length,
                        o = new t.constructor(n);
                    for (let i = 0, h = 0; h !== n; ++i) {
                        const n = r[i] * e;
                        for (let r = 0; r !== e; ++r) o[h++] = t[n + r]
                    }
                    return o
                },
                flattenJSON: function (t, e, r, n) {
                    let i = 1,
                        o = t[0];
                    for (; void 0 !== o && void 0 === o[n];) o = t[i++];
                    if (void 0 === o) return;
                    let h = o[n];
                    if (void 0 !== h)
                        if (Array.isArray(h))
                            do {
                                h = o[n], void 0 !== h && (e.push(o.time), r.push.apply(r, h)), o = t[i++]
                            } while (void 0 !== o);
                        else if (void 0 !== h.toArray)
                        do {
                            h = o[n], void 0 !== h && (e.push(o.time), h.toArray(r, r.length)), o = t[i++]
                        } while (void 0 !== o);
                    else
                        do {
                            h = o[n], void 0 !== h && (e.push(o.time), r.push(h)), o = t[i++]
                        } while (void 0 !== o)
                },
                subclip: function (t, e, r, n, o = 30) {
                    const h = t.clone();
                    h.name = e;
                    const l = [];
                    for (let i = 0; i < h.tracks.length; ++i) {
                        const track = h.tracks[i],
                            t = track.getValueSize(),
                            e = [],
                            c = [];
                        for (let h = 0; h < track.times.length; ++h) {
                            const l = track.times[h] * o;
                            if (!(l < r || l >= n)) {
                                e.push(track.times[h]);
                                for (let e = 0; e < t; ++e) c.push(track.values[h * t + e])
                            }
                        }
                        0 !== e.length && (track.times = po.convertArray(e, track.times.constructor), track.values = po.convertArray(c, track.values.constructor), l.push(track))
                    }
                    h.tracks = l;
                    let c = 1 / 0;
                    for (let i = 0; i < h.tracks.length; ++i) c > h.tracks[i].times[0] && (c = h.tracks[i].times[0]);
                    for (let i = 0; i < h.tracks.length; ++i) h.tracks[i].shift(-1 * c);
                    return h.resetDuration(), h
                },
                makeClipAdditive: function (t, e = 0, r = t, n = 30) {
                    n <= 0 && (n = 30);
                    const o = r.tracks.length,
                        h = e / n;
                    for (let i = 0; i < o; ++i) {
                        const e = r.tracks[i],
                            n = e.ValueTypeName;
                        if ("bool" === n || "string" === n) continue;
                        const o = t.tracks.find((function (track) {
                            return track.name === e.name && track.ValueTypeName === n
                        }));
                        if (void 0 === o) continue;
                        let l = 0;
                        const c = e.getValueSize();
                        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (l = c / 3);
                        let d = 0;
                        const m = o.getValueSize();
                        o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = m / 3);
                        const f = e.times.length - 1;
                        let y;
                        if (h <= e.times[0]) {
                            const t = l,
                                r = c - l;
                            y = po.arraySlice(e.values, t, r)
                        } else if (h >= e.times[f]) {
                            const t = f * c + l,
                                r = t + c - l;
                            y = po.arraySlice(e.values, t, r)
                        } else {
                            const t = e.createInterpolant(),
                                r = l,
                                n = c - l;
                            t.evaluate(h), y = po.arraySlice(t.resultBuffer, r, n)
                        }
                        if ("quaternion" === n) {
                            (new yt).fromArray(y).normalize().conjugate().toArray(y)
                        }
                        const v = o.times.length;
                        for (let t = 0; t < v; ++t) {
                            const e = t * m + d;
                            if ("quaternion" === n) yt.multiplyQuaternionsFlat(o.values, e, y, 0, o.values, e);
                            else {
                                const t = m - 2 * d;
                                for (let r = 0; r < t; ++r) o.values[e + r] -= y[r]
                            }
                        }
                    }
                    return t.blendMode = 2501, t
                }
            };
            class uo {
                constructor(t, e, r, n) {
                    this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(r), this.sampleValues = e, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {}
                }
                evaluate(t) {
                    const e = this.parameterPositions;
                    let r = this._cachedIndex,
                        n = e[r],
                        o = e[r - 1];
                    t: {
                        e: {
                            let h;i: {
                                r: if (!(t < n)) {
                                    for (let h = r + 2;;) {
                                        if (void 0 === n) {
                                            if (t < o) break r;
                                            return r = e.length, this._cachedIndex = r, this.afterEnd_(r - 1, t, o)
                                        }
                                        if (r === h) break;
                                        if (o = n, n = e[++r], t < n) break e
                                    }
                                    h = e.length;
                                    break i
                                }if (t >= o) break t; {
                                    const l = e[1];
                                    t < l && (r = 2, o = l);
                                    for (let h = r - 2;;) {
                                        if (void 0 === o) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                                        if (r === h) break;
                                        if (n = o, o = e[--r - 1], t >= o) break e
                                    }
                                    h = r, r = 0
                                }
                            }
                            for (; r < h;) {
                                const n = r + h >>> 1;
                                t < e[n] ? h = n : r = n + 1
                            }
                            if (n = e[r], o = e[r - 1], void 0 === o) return this._cachedIndex = 0,
                            this.beforeStart_(0, t, n);
                            if (void 0 === n) return r = e.length,
                            this._cachedIndex = r,
                            this.afterEnd_(r - 1, o, t)
                        }
                        this._cachedIndex = r,
                        this.intervalChanged_(r, o, n)
                    }
                    return this.interpolate_(r, o, t, n)
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_
                }
                copySampleValue_(t) {
                    const e = this.resultBuffer,
                        r = this.sampleValues,
                        n = this.valueSize,
                        o = t * n;
                    for (let i = 0; i !== n; ++i) e[i] = r[o + i];
                    return e
                }
                interpolate_() {
                    throw new Error("call to abstract method")
                }
                intervalChanged_() {}
            }
            uo.prototype.beforeStart_ = uo.prototype.copySampleValue_, uo.prototype.afterEnd_ = uo.prototype.copySampleValue_;
            class mo extends uo {
                constructor(t, e, r, n) {
                    super(t, e, r, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                        endingStart: N,
                        endingEnd: N
                    }
                }
                intervalChanged_(t, e, r) {
                    const n = this.parameterPositions;
                    let o = t - 2,
                        h = t + 1,
                        l = n[o],
                        c = n[h];
                    if (void 0 === l) switch (this.getSettings_().endingStart) {
                        case B:
                            o = t, l = 2 * e - r;
                            break;
                        case z:
                            o = n.length - 2, l = e + n[o] - n[o + 1];
                            break;
                        default:
                            o = t, l = r
                    }
                    if (void 0 === c) switch (this.getSettings_().endingEnd) {
                        case B:
                            h = t, c = 2 * r - e;
                            break;
                        case z:
                            h = 1, c = r + n[1] - n[0];
                            break;
                        default:
                            h = t - 1, c = e
                    }
                    const d = .5 * (r - e),
                        m = this.valueSize;
                    this._weightPrev = d / (e - l), this._weightNext = d / (c - r), this._offsetPrev = o * m, this._offsetNext = h * m
                }
                interpolate_(t, e, r, n) {
                    const o = this.resultBuffer,
                        h = this.sampleValues,
                        l = this.valueSize,
                        c = t * l,
                        d = c - l,
                        m = this._offsetPrev,
                        f = this._offsetNext,
                        y = this._weightPrev,
                        v = this._weightNext,
                        p = (r - e) / (n - e),
                        x = p * p,
                        _ = x * p,
                        M = -y * _ + 2 * y * x - y * p,
                        S = (1 + y) * _ + (-1.5 - 2 * y) * x + (-.5 + y) * p + 1,
                        w = (-1 - v) * _ + (1.5 + v) * x + .5 * p,
                        E = v * _ - v * x;
                    for (let i = 0; i !== l; ++i) o[i] = M * h[m + i] + S * h[d + i] + w * h[c + i] + E * h[f + i];
                    return o
                }
            }
            class fo extends uo {
                constructor(t, e, r, n) {
                    super(t, e, r, n)
                }
                interpolate_(t, e, r, n) {
                    const o = this.resultBuffer,
                        h = this.sampleValues,
                        l = this.valueSize,
                        c = t * l,
                        d = c - l,
                        m = (r - e) / (n - e),
                        f = 1 - m;
                    for (let i = 0; i !== l; ++i) o[i] = h[d + i] * f + h[c + i] * m;
                    return o
                }
            }
            class go extends uo {
                constructor(t, e, r, n) {
                    super(t, e, r, n)
                }
                interpolate_(t) {
                    return this.copySampleValue_(t - 1)
                }
            }
            class yo {
                constructor(t, e, r, n) {
                    if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                    this.name = t, this.times = po.convertArray(e, this.TimeBufferType), this.values = po.convertArray(r, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
                }
                static toJSON(track) {
                    const t = track.constructor;
                    let e;
                    if (t.toJSON !== this.toJSON) e = t.toJSON(track);
                    else {
                        e = {
                            name: track.name,
                            times: po.convertArray(track.times, Array),
                            values: po.convertArray(track.values, Array)
                        };
                        const t = track.getInterpolation();
                        t !== track.DefaultInterpolation && (e.interpolation = t)
                    }
                    return e.type = track.ValueTypeName, e
                }
                InterpolantFactoryMethodDiscrete(t) {
                    return new go(this.times, this.values, this.getValueSize(), t)
                }
                InterpolantFactoryMethodLinear(t) {
                    return new fo(this.times, this.values, this.getValueSize(), t)
                }
                InterpolantFactoryMethodSmooth(t) {
                    return new mo(this.times, this.values, this.getValueSize(), t)
                }
                setInterpolation(t) {
                    let e;
                    switch (t) {
                        case I:
                            e = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case F:
                            e = this.InterpolantFactoryMethodLinear;
                            break;
                        case k:
                            e = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === e) {
                        const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (t === this.DefaultInterpolation) throw new Error(e);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return console.warn("THREE.KeyframeTrack:", e), this
                    }
                    return this.createInterpolant = e, this
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return I;
                        case this.InterpolantFactoryMethodLinear:
                            return F;
                        case this.InterpolantFactoryMethodSmooth:
                            return k
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length
                }
                shift(t) {
                    if (0 !== t) {
                        const e = this.times;
                        for (let i = 0, r = e.length; i !== r; ++i) e[i] += t
                    }
                    return this
                }
                scale(t) {
                    if (1 !== t) {
                        const e = this.times;
                        for (let i = 0, r = e.length; i !== r; ++i) e[i] *= t
                    }
                    return this
                }
                trim(t, e) {
                    const r = this.times,
                        n = r.length;
                    let o = 0,
                        h = n - 1;
                    for (; o !== n && r[o] < t;) ++o;
                    for (; - 1 !== h && r[h] > e;) --h;
                    if (++h, 0 !== o || h !== n) {
                        o >= h && (h = Math.max(h, 1), o = h - 1);
                        const t = this.getValueSize();
                        this.times = po.arraySlice(r, o, h), this.values = po.arraySlice(this.values, o * t, h * t)
                    }
                    return this
                }
                validate() {
                    let t = !0;
                    const e = this.getValueSize();
                    e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                    const r = this.times,
                        n = this.values,
                        o = r.length;
                    0 === o && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                    let h = null;
                    for (let i = 0; i !== o; i++) {
                        const e = r[i];
                        if ("number" == typeof e && isNaN(e)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, e), t = !1;
                            break
                        }
                        if (null !== h && h > e) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, i, e, h), t = !1;
                            break
                        }
                        h = e
                    }
                    if (void 0 !== n && po.isTypedArray(n))
                        for (let i = 0, e = n.length; i !== e; ++i) {
                            const e = n[i];
                            if (isNaN(e)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, e), t = !1;
                                break
                            }
                        }
                    return t
                }
                optimize() {
                    const t = po.arraySlice(this.times),
                        e = po.arraySlice(this.values),
                        r = this.getValueSize(),
                        n = this.getInterpolation() === k,
                        o = t.length - 1;
                    let h = 1;
                    for (let i = 1; i < o; ++i) {
                        let o = !1;
                        const time = t[i];
                        if (time !== t[i + 1] && (1 !== i || time !== t[0]))
                            if (n) o = !0;
                            else {
                                const t = i * r,
                                    n = t - r,
                                    h = t + r;
                                for (let l = 0; l !== r; ++l) {
                                    const r = e[t + l];
                                    if (r !== e[n + l] || r !== e[h + l]) {
                                        o = !0;
                                        break
                                    }
                                }
                            } if (o) {
                            if (i !== h) {
                                t[h] = t[i];
                                const n = i * r,
                                    o = h * r;
                                for (let t = 0; t !== r; ++t) e[o + t] = e[n + t]
                            }++h
                        }
                    }
                    if (o > 0) {
                        t[h] = t[o];
                        for (let t = o * r, n = h * r, l = 0; l !== r; ++l) e[n + l] = e[t + l];
                        ++h
                    }
                    return h !== t.length ? (this.times = po.arraySlice(t, 0, h), this.values = po.arraySlice(e, 0, h * r)) : (this.times = t, this.values = e), this
                }
                clone() {
                    const t = po.arraySlice(this.times, 0),
                        e = po.arraySlice(this.values, 0),
                        track = new(0, this.constructor)(this.name, t, e);
                    return track.createInterpolant = this.createInterpolant, track
                }
            }
            yo.prototype.TimeBufferType = Float32Array, yo.prototype.ValueBufferType = Float32Array, yo.prototype.DefaultInterpolation = F;
            class vo extends yo {}
            vo.prototype.ValueTypeName = "bool", vo.prototype.ValueBufferType = Array, vo.prototype.DefaultInterpolation = I, vo.prototype.InterpolantFactoryMethodLinear = void 0, vo.prototype.InterpolantFactoryMethodSmooth = void 0;
            class xo extends yo {}
            xo.prototype.ValueTypeName = "color";
            class _o extends yo {}
            _o.prototype.ValueTypeName = "number";
            class bo extends uo {
                constructor(t, e, r, n) {
                    super(t, e, r, n)
                }
                interpolate_(t, e, r, n) {
                    const o = this.resultBuffer,
                        h = this.sampleValues,
                        l = this.valueSize,
                        c = (r - e) / (n - e);
                    let d = t * l;
                    for (let t = d + l; d !== t; d += 4) yt.slerpFlat(o, 0, h, d - l, h, d, c);
                    return o
                }
            }
            class Mo extends yo {
                InterpolantFactoryMethodLinear(t) {
                    return new bo(this.times, this.values, this.getValueSize(), t)
                }
            }
            Mo.prototype.ValueTypeName = "quaternion", Mo.prototype.DefaultInterpolation = F, Mo.prototype.InterpolantFactoryMethodSmooth = void 0;
            class So extends yo {}
            So.prototype.ValueTypeName = "string", So.prototype.ValueBufferType = Array, So.prototype.DefaultInterpolation = I, So.prototype.InterpolantFactoryMethodLinear = void 0, So.prototype.InterpolantFactoryMethodSmooth = void 0;
            class wo extends yo {}
            wo.prototype.ValueTypeName = "vector";
            class Eo {
                constructor(t, e = -1, r, n = 2500) {
                    this.name = t, this.tracks = r, this.duration = e, this.blendMode = n, this.uuid = $(), this.duration < 0 && this.resetDuration()
                }
                static parse(t) {
                    const e = [],
                        r = t.tracks,
                        n = 1 / (t.fps || 1);
                    for (let i = 0, t = r.length; i !== t; ++i) e.push(To(r[i]).scale(n));
                    const o = new this(t.name, t.duration, e, t.blendMode);
                    return o.uuid = t.uuid, o
                }
                static toJSON(t) {
                    const e = [],
                        r = t.tracks,
                        n = {
                            name: t.name,
                            duration: t.duration,
                            tracks: e,
                            uuid: t.uuid,
                            blendMode: t.blendMode
                        };
                    for (let i = 0, t = r.length; i !== t; ++i) e.push(yo.toJSON(r[i]));
                    return n
                }
                static CreateFromMorphTargetSequence(t, e, r, n) {
                    const o = e.length,
                        h = [];
                    for (let i = 0; i < o; i++) {
                        let t = [],
                            l = [];
                        t.push((i + o - 1) % o, i, (i + 1) % o), l.push(0, 1, 0);
                        const c = po.getKeyframeOrder(t);
                        t = po.sortedArray(t, 1, c), l = po.sortedArray(l, 1, c), n || 0 !== t[0] || (t.push(o), l.push(l[0])), h.push(new _o(".morphTargetInfluences[" + e[i].name + "]", t, l).scale(1 / r))
                    }
                    return new this(t, -1, h)
                }
                static findByName(t, e) {
                    let r = t;
                    if (!Array.isArray(t)) {
                        const e = t;
                        r = e.geometry && e.geometry.animations || e.animations
                    }
                    for (let i = 0; i < r.length; i++)
                        if (r[i].name === e) return r[i];
                    return null
                }
                static CreateClipsFromMorphTargetSequences(t, e, r) {
                    const n = {},
                        pattern = /^([\w-]*?)([\d]+)$/;
                    for (let i = 0, e = t.length; i < e; i++) {
                        const e = t[i],
                            r = e.name.match(pattern);
                        if (r && r.length > 1) {
                            const t = r[1];
                            let o = n[t];
                            o || (n[t] = o = []), o.push(e)
                        }
                    }
                    const o = [];
                    for (const t in n) o.push(this.CreateFromMorphTargetSequence(t, n[t], e, r));
                    return o
                }
                static parseAnimation(t, e) {
                    if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    const r = function (t, e, r, n, o) {
                            if (0 !== r.length) {
                                const h = [],
                                    l = [];
                                po.flattenJSON(r, h, l, n), 0 !== h.length && o.push(new t(e, h, l))
                            }
                        },
                        n = [],
                        o = t.name || "default",
                        h = t.fps || 30,
                        l = t.blendMode;
                    let c = t.length || -1;
                    const d = t.hierarchy || [];
                    for (let t = 0; t < d.length; t++) {
                        const o = d[t].keys;
                        if (o && 0 !== o.length)
                            if (o[0].morphTargets) {
                                const t = {};
                                let e;
                                for (e = 0; e < o.length; e++)
                                    if (o[e].morphTargets)
                                        for (let r = 0; r < o[e].morphTargets.length; r++) t[o[e].morphTargets[r]] = -1;
                                for (const r in t) {
                                    const t = [],
                                        h = [];
                                    for (let n = 0; n !== o[e].morphTargets.length; ++n) {
                                        const n = o[e];
                                        t.push(n.time), h.push(n.morphTarget === r ? 1 : 0)
                                    }
                                    n.push(new _o(".morphTargetInfluence[" + r + "]", t, h))
                                }
                                c = t.length * (h || 1)
                            } else {
                                const h = ".bones[" + e[t].name + "]";
                                r(wo, h + ".position", o, "pos", n), r(Mo, h + ".quaternion", o, "rot", n), r(wo, h + ".scale", o, "scl", n)
                            }
                    }
                    if (0 === n.length) return null;
                    return new this(o, c, n, l)
                }
                resetDuration() {
                    let t = 0;
                    for (let i = 0, e = this.tracks.length; i !== e; ++i) {
                        const track = this.tracks[i];
                        t = Math.max(t, track.times[track.times.length - 1])
                    }
                    return this.duration = t, this
                }
                trim() {
                    for (let i = 0; i < this.tracks.length; i++) this.tracks[i].trim(0, this.duration);
                    return this
                }
                validate() {
                    let t = !0;
                    for (let i = 0; i < this.tracks.length; i++) t = t && this.tracks[i].validate();
                    return t
                }
                optimize() {
                    for (let i = 0; i < this.tracks.length; i++) this.tracks[i].optimize();
                    return this
                }
                clone() {
                    const t = [];
                    for (let i = 0; i < this.tracks.length; i++) t.push(this.tracks[i].clone());
                    return new this.constructor(this.name, this.duration, t, this.blendMode)
                }
                toJSON() {
                    return this.constructor.toJSON(this)
                }
            }

            function To(t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                const e = function (t) {
                    switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return _o;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return wo;
                        case "color":
                            return xo;
                        case "quaternion":
                            return Mo;
                        case "bool":
                        case "boolean":
                            return vo;
                        case "string":
                            return So
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                }(t.type);
                if (void 0 === t.times) {
                    const e = [],
                        r = [];
                    po.flattenJSON(t.keys, e, r, "value"), t.times = e, t.values = r
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            }
            const Ao = {
                enabled: !1,
                files: {},
                add: function (t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function (t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function (t) {
                    delete this.files[t]
                },
                clear: function () {
                    this.files = {}
                }
            };
            class Po {
                constructor(t, e, r) {
                    const n = this;
                    let o, h = !1,
                        l = 0,
                        c = 0;
                    const d = [];
                    this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = r, this.itemStart = function (t) {
                        c++, !1 === h && void 0 !== n.onStart && n.onStart(t, l, c), h = !0
                    }, this.itemEnd = function (t) {
                        l++, void 0 !== n.onProgress && n.onProgress(t, l, c), l === c && (h = !1, void 0 !== n.onLoad && n.onLoad())
                    }, this.itemError = function (t) {
                        void 0 !== n.onError && n.onError(t)
                    }, this.resolveURL = function (t) {
                        return o ? o(t) : t
                    }, this.setURLModifier = function (t) {
                        return o = t, this
                    }, this.addHandler = function (t, e) {
                        return d.push(t, e), this
                    }, this.removeHandler = function (t) {
                        const e = d.indexOf(t);
                        return -1 !== e && d.splice(e, 2), this
                    }, this.getHandler = function (t) {
                        for (let i = 0, e = d.length; i < e; i += 2) {
                            const e = d[i],
                                r = d[i + 1];
                            if (e.global && (e.lastIndex = 0), e.test(t)) return r
                        }
                        return null
                    }
                }
            }
            const Co = new Po;
            class Lo {
                constructor(t) {
                    this.manager = void 0 !== t ? t : Co, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                }
                load() {}
                loadAsync(t, e) {
                    const r = this;
                    return new Promise((function (n, o) {
                        r.load(t, n, e, o)
                    }))
                }
                parse() {}
                setCrossOrigin(t) {
                    return this.crossOrigin = t, this
                }
                setWithCredentials(t) {
                    return this.withCredentials = t, this
                }
                setPath(path) {
                    return this.path = path, this
                }
                setResourcePath(t) {
                    return this.resourcePath = t, this
                }
                setRequestHeader(t) {
                    return this.requestHeader = t, this
                }
            }
            const Do = {};
            class Ro extends Lo {
                constructor(t) {
                    super(t)
                }
                load(t, e, r, n) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const o = this,
                        h = Ao.get(t);
                    if (void 0 !== h) return o.manager.itemStart(t), setTimeout((function () {
                        e && e(h), o.manager.itemEnd(t)
                    }), 0), h;
                    if (void 0 !== Do[t]) return void Do[t].push({
                        onLoad: e,
                        onProgress: r,
                        onError: n
                    });
                    const l = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                    let c;
                    if (l) {
                        const r = l[1],
                            h = !!l[2];
                        let data = l[3];
                        data = decodeURIComponent(data), h && (data = atob(data));
                        try {
                            let n;
                            const h = (this.responseType || "").toLowerCase();
                            switch (h) {
                                case "arraybuffer":
                                case "blob":
                                    const view = new Uint8Array(data.length);
                                    for (let i = 0; i < data.length; i++) view[i] = data.charCodeAt(i);
                                    n = "blob" === h ? new Blob([view.buffer], {
                                        type: r
                                    }) : view.buffer;
                                    break;
                                case "document":
                                    const t = new DOMParser;
                                    n = t.parseFromString(data, r);
                                    break;
                                case "json":
                                    n = JSON.parse(data);
                                    break;
                                default:
                                    n = data
                            }
                            setTimeout((function () {
                                e && e(n), o.manager.itemEnd(t)
                            }), 0)
                        } catch (e) {
                            setTimeout((function () {
                                n && n(e), o.manager.itemError(t), o.manager.itemEnd(t)
                            }), 0)
                        }
                    } else {
                        Do[t] = [], Do[t].push({
                            onLoad: e,
                            onProgress: r,
                            onError: n
                        }), c = new XMLHttpRequest, c.open("GET", t, !0), c.addEventListener("load", (function (e) {
                            const r = this.response,
                                n = Do[t];
                            if (delete Do[t], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Ao.add(t, r);
                                for (let i = 0, t = n.length; i < t; i++) {
                                    const t = n[i];
                                    t.onLoad && t.onLoad(r)
                                }
                                o.manager.itemEnd(t)
                            } else {
                                for (let i = 0, t = n.length; i < t; i++) {
                                    const t = n[i];
                                    t.onError && t.onError(e)
                                }
                                o.manager.itemError(t), o.manager.itemEnd(t)
                            }
                        }), !1), c.addEventListener("progress", (function (e) {
                            const r = Do[t];
                            for (let i = 0, t = r.length; i < t; i++) {
                                const t = r[i];
                                t.onProgress && t.onProgress(e)
                            }
                        }), !1), c.addEventListener("error", (function (e) {
                            const r = Do[t];
                            delete Do[t];
                            for (let i = 0, t = r.length; i < t; i++) {
                                const t = r[i];
                                t.onError && t.onError(e)
                            }
                            o.manager.itemError(t), o.manager.itemEnd(t)
                        }), !1), c.addEventListener("abort", (function (e) {
                            const r = Do[t];
                            delete Do[t];
                            for (let i = 0, t = r.length; i < t; i++) {
                                const t = r[i];
                                t.onError && t.onError(e)
                            }
                            o.manager.itemError(t), o.manager.itemEnd(t)
                        }), !1), void 0 !== this.responseType && (c.responseType = this.responseType), void 0 !== this.withCredentials && (c.withCredentials = this.withCredentials), c.overrideMimeType && c.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                        for (const header in this.requestHeader) c.setRequestHeader(header, this.requestHeader[header]);
                        c.send(null)
                    }
                    return o.manager.itemStart(t), c
                }
                setResponseType(t) {
                    return this.responseType = t, this
                }
                setMimeType(t) {
                    return this.mimeType = t, this
                }
            }
            class Io extends Lo {
                constructor(t) {
                    super(t)
                }
                load(t, e, r, n) {
                    void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const o = this,
                        h = Ao.get(t);
                    if (void 0 !== h) return o.manager.itemStart(t), setTimeout((function () {
                        e && e(h), o.manager.itemEnd(t)
                    }), 0), h;
                    const image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function l() {
                        image.removeEventListener("load", l, !1), image.removeEventListener("error", c, !1), Ao.add(t, this), e && e(this), o.manager.itemEnd(t)
                    }

                    function c(e) {
                        image.removeEventListener("load", l, !1), image.removeEventListener("error", c, !1), n && n(e), o.manager.itemError(t), o.manager.itemEnd(t)
                    }
                    return image.addEventListener("load", l, !1), image.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (image.crossOrigin = this.crossOrigin), o.manager.itemStart(t), image.src = t, image
                }
            }
            class Fo extends Lo {
                constructor(t) {
                    super(t)
                }
                load(t, e, r, n) {
                    const o = new Ri,
                        h = new Io(this.manager);
                    h.setCrossOrigin(this.crossOrigin), h.setPath(this.path);
                    let l = 0;

                    function c(i) {
                        h.load(t[i], (function (image) {
                            o.images[i] = image, l++, 6 === l && (o.needsUpdate = !0, e && e(o))
                        }), void 0, n)
                    }
                    for (let i = 0; i < t.length; ++i) c(i);
                    return o
                }
            }
            class ko extends Lo {
                constructor(t) {
                    super(t)
                }
                load(t, e, r, n) {
                    const o = new pt,
                        h = new Io(this.manager);
                    return h.setCrossOrigin(this.crossOrigin), h.setPath(this.path), h.load(t, (function (image) {
                        o.image = image;
                        const r = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                        o.format = r ? C : L, o.needsUpdate = !0, void 0 !== e && e(o)
                    }), r, n), o
                }
            }
            class No extends aa {
                constructor() {
                    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                }
                add(t) {
                    this.curves.push(t)
                }
                closePath() {
                    const t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new _a(e, t))
                }
                getPoint(t) {
                    const e = t * this.getLength(),
                        r = this.getCurveLengths();
                    let i = 0;
                    for (; i < r.length;) {
                        if (r[i] >= e) {
                            const t = r[i] - e,
                                n = this.curves[i],
                                o = n.getLength(),
                                u = 0 === o ? 0 : 1 - t / o;
                            return n.getPointAt(u)
                        }
                        i++
                    }
                    return null
                }
                getLength() {
                    const t = this.getCurveLengths();
                    return t[t.length - 1]
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                }
                getCurveLengths() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    const t = [];
                    let e = 0;
                    for (let i = 0, r = this.curves.length; i < r; i++) e += this.curves[i].getLength(), t.push(e);
                    return this.cacheLengths = t, t
                }
                getSpacedPoints(t = 40) {
                    const e = [];
                    for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                    return this.autoClose && e.push(e[0]), e
                }
                getPoints(t = 12) {
                    const e = [];
                    let r;
                    for (let i = 0, n = this.curves; i < n.length; i++) {
                        const o = n[i],
                            h = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t,
                            l = o.getPoints(h);
                        for (let t = 0; t < l.length; t++) {
                            const n = l[t];
                            r && r.equals(n) || (e.push(n), r = n)
                        }
                    }
                    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
                }
                copy(source) {
                    super.copy(source), this.curves = [];
                    for (let i = 0, t = source.curves.length; i < t; i++) {
                        const t = source.curves[i];
                        this.curves.push(t.clone())
                    }
                    return this.autoClose = source.autoClose, this
                }
                toJSON() {
                    const data = super.toJSON();
                    data.autoClose = this.autoClose, data.curves = [];
                    for (let i = 0, t = this.curves.length; i < t; i++) {
                        const t = this.curves[i];
                        data.curves.push(t.toJSON())
                    }
                    return data
                }
                fromJSON(t) {
                    super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                    for (let i = 0, e = t.curves.length; i < e; i++) {
                        const e = t.curves[i];
                        this.curves.push((new wa[e.type]).fromJSON(e))
                    }
                    return this
                }
            }
            class Bo extends No {
                constructor(t) {
                    super(), this.type = "Path", this.currentPoint = new at, t && this.setFromPoints(t)
                }
                setFromPoints(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (let i = 1, e = t.length; i < e; i++) this.lineTo(t[i].x, t[i].y);
                    return this
                }
                moveTo(t, e) {
                    return this.currentPoint.set(t, e), this
                }
                lineTo(t, e) {
                    const r = new _a(this.currentPoint.clone(), new at(t, e));
                    return this.curves.push(r), this.currentPoint.set(t, e), this
                }
                quadraticCurveTo(t, e, r, n) {
                    const o = new ba(this.currentPoint.clone(), new at(t, e), new at(r, n));
                    return this.curves.push(o), this.currentPoint.set(r, n), this
                }
                bezierCurveTo(t, e, r, n, o, h) {
                    const l = new va(this.currentPoint.clone(), new at(t, e), new at(r, n), new at(o, h));
                    return this.curves.push(l), this.currentPoint.set(o, h), this
                }
                splineThru(t) {
                    const e = [this.currentPoint.clone()].concat(t),
                        r = new Sa(e);
                    return this.curves.push(r), this.currentPoint.copy(t[t.length - 1]), this
                }
                arc(t, e, r, n, o, h) {
                    const l = this.currentPoint.x,
                        c = this.currentPoint.y;
                    return this.absarc(t + l, e + c, r, n, o, h), this
                }
                absarc(t, e, r, n, o, h) {
                    return this.absellipse(t, e, r, r, n, o, h), this
                }
                ellipse(t, e, r, n, o, h, l, c) {
                    const d = this.currentPoint.x,
                        m = this.currentPoint.y;
                    return this.absellipse(t + d, e + m, r, n, o, h, l, c), this
                }
                absellipse(t, e, r, n, o, h, l, c) {
                    const d = new oa(t, e, r, n, o, h, l, c);
                    if (this.curves.length > 0) {
                        const t = d.getPoint(0);
                        t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                    }
                    this.curves.push(d);
                    const m = d.getPoint(1);
                    return this.currentPoint.copy(m), this
                }
                copy(source) {
                    return super.copy(source), this.currentPoint.copy(source.currentPoint), this
                }
                toJSON() {
                    const data = super.toJSON();
                    return data.currentPoint = this.currentPoint.toArray(), data
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }
            class zo extends Bo {
                constructor(t) {
                    super(t), this.uuid = $(), this.type = "Shape", this.holes = []
                }
                getPointsHoles(t) {
                    const e = [];
                    for (let i = 0, r = this.holes.length; i < r; i++) e[i] = this.holes[i].getPoints(t);
                    return e
                }
                extractPoints(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                }
                copy(source) {
                    super.copy(source), this.holes = [];
                    for (let i = 0, t = source.holes.length; i < t; i++) {
                        const t = source.holes[i];
                        this.holes.push(t.clone())
                    }
                    return this
                }
                toJSON() {
                    const data = super.toJSON();
                    data.uuid = this.uuid, data.holes = [];
                    for (let i = 0, t = this.holes.length; i < t; i++) {
                        const t = this.holes[i];
                        data.holes.push(t.toJSON())
                    }
                    return data
                }
                fromJSON(t) {
                    super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                    for (let i = 0, e = t.holes.length; i < e; i++) {
                        const e = t.holes[i];
                        this.holes.push((new Bo).fromJSON(e))
                    }
                    return this
                }
            }
            class Vo extends _e {
                constructor(t, e = 1) {
                    super(), this.type = "Light", this.color = new Oe(t), this.intensity = e
                }
                dispose() {}
                copy(source) {
                    return super.copy(source), this.color.copy(source.color), this.intensity = source.intensity, this
                }
                toJSON(meta) {
                    const data = super.toJSON(meta);
                    return data.object.color = this.color.getHex(), data.object.intensity = this.intensity, void 0 !== this.groundColor && (data.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (data.object.distance = this.distance), void 0 !== this.angle && (data.object.angle = this.angle), void 0 !== this.decay && (data.object.decay = this.decay), void 0 !== this.penumbra && (data.object.penumbra = this.penumbra), void 0 !== this.shadow && (data.object.shadow = this.shadow.toJSON()), data
                }
            }
            Vo.prototype.isLight = !0;
            class Oo extends Vo {
                constructor(t, e, r) {
                    super(t, r), this.type = "HemisphereLight", this.position.copy(_e.DefaultUp), this.updateMatrix(), this.groundColor = new Oe(e)
                }
                copy(source) {
                    return Vo.prototype.copy.call(this, source), this.groundColor.copy(source.groundColor), this
                }
            }
            Oo.prototype.isHemisphereLight = !0;
            const Go = new Jt,
                Ho = new vt,
                Uo = new vt;
            class Wo {
                constructor(t) {
                    this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new at(512, 512), this.map = null, this.mapPass = null, this.matrix = new Jt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Oi, this._frameExtents = new at(1, 1), this._viewportCount = 1, this._viewports = [new mt(0, 0, 1, 1)]
                }
                getViewportCount() {
                    return this._viewportCount
                }
                getFrustum() {
                    return this._frustum
                }
                updateMatrices(t) {
                    const e = this.camera,
                        r = this.matrix;
                    Ho.setFromMatrixPosition(t.matrixWorld), e.position.copy(Ho), Uo.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Uo), e.updateMatrixWorld(), Go.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Go), r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), r.multiply(e.projectionMatrix), r.multiply(e.matrixWorldInverse)
                }
                getViewport(t) {
                    return this._viewports[t]
                }
                getFrameExtents() {
                    return this._frameExtents
                }
                dispose() {
                    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                }
                copy(source) {
                    return this.camera = source.camera.clone(), this.bias = source.bias, this.radius = source.radius, this.mapSize.copy(source.mapSize), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    const object = {};
                    return 0 !== this.bias && (object.bias = this.bias), 0 !== this.normalBias && (object.normalBias = this.normalBias), 1 !== this.radius && (object.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (object.mapSize = this.mapSize.toArray()), object.camera = this.camera.toJSON(!1).object, delete object.camera.matrix, object
                }
            }
            class jo extends Wo {
                constructor() {
                    super(new Ci(50, 1, .5, 500)), this.focus = 1
                }
                updateMatrices(t) {
                    const e = this.camera,
                        r = 2 * Q * t.angle * this.focus,
                        n = this.mapSize.width / this.mapSize.height,
                        o = t.distance || e.far;
                    r === e.fov && n === e.aspect && o === e.far || (e.fov = r, e.aspect = n, e.far = o, e.updateProjectionMatrix()), super.updateMatrices(t)
                }
                copy(source) {
                    return super.copy(source), this.focus = source.focus, this
                }
            }
            jo.prototype.isSpotLightShadow = !0;
            class qo extends Vo {
                constructor(t, e, r = 0, n = Math.PI / 3, o = 0, h = 1) {
                    super(t, e), this.type = "SpotLight", this.position.copy(_e.DefaultUp), this.updateMatrix(), this.target = new _e, this.distance = r, this.angle = n, this.penumbra = o, this.decay = h, this.shadow = new jo
                }
                get power() {
                    return this.intensity * Math.PI
                }
                set power(t) {
                    this.intensity = t / Math.PI
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(source) {
                    return super.copy(source), this.distance = source.distance, this.angle = source.angle, this.penumbra = source.penumbra, this.decay = source.decay, this.target = source.target.clone(), this.shadow = source.shadow.clone(), this
                }
            }
            qo.prototype.isSpotLight = !0;
            const Xo = new Jt,
                Yo = new vt,
                Jo = new vt;
            class Zo extends Wo {
                constructor() {
                    super(new Ci(90, 1, .5, 500)), this._frameExtents = new at(4, 2), this._viewportCount = 6, this._viewports = [new mt(2, 1, 1, 1), new mt(0, 1, 1, 1), new mt(3, 1, 1, 1), new mt(1, 1, 1, 1), new mt(3, 0, 1, 1), new mt(1, 0, 1, 1)], this._cubeDirections = [new vt(1, 0, 0), new vt(-1, 0, 0), new vt(0, 0, 1), new vt(0, 0, -1), new vt(0, 1, 0), new vt(0, -1, 0)], this._cubeUps = [new vt(0, 1, 0), new vt(0, 1, 0), new vt(0, 1, 0), new vt(0, 1, 0), new vt(0, 0, 1), new vt(0, 0, -1)]
                }
                updateMatrices(t, e = 0) {
                    const r = this.camera,
                        n = this.matrix,
                        o = t.distance || r.far;
                    o !== r.far && (r.far = o, r.updateProjectionMatrix()), Yo.setFromMatrixPosition(t.matrixWorld), r.position.copy(Yo), Jo.copy(r.position), Jo.add(this._cubeDirections[e]), r.up.copy(this._cubeUps[e]), r.lookAt(Jo), r.updateMatrixWorld(), n.makeTranslation(-Yo.x, -Yo.y, -Yo.z), Xo.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Xo)
                }
            }
            Zo.prototype.isPointLightShadow = !0;
            class Ko extends Vo {
                constructor(t, e, r = 0, n = 1) {
                    super(t, e), this.type = "PointLight", this.distance = r, this.decay = n, this.shadow = new Zo
                }
                get power() {
                    return 4 * this.intensity * Math.PI
                }
                set power(t) {
                    this.intensity = t / (4 * Math.PI)
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(source) {
                    return super.copy(source), this.distance = source.distance, this.decay = source.decay, this.shadow = source.shadow.clone(), this
                }
            }
            Ko.prototype.isPointLight = !0;
            class Qo extends Pi {
                constructor(t = -1, e = 1, r = 1, n = -1, o = .1, h = 2e3) {
                    super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = r, this.bottom = n, this.near = o, this.far = h, this.updateProjectionMatrix()
                }
                copy(source, t) {
                    return super.copy(source, t), this.left = source.left, this.right = source.right, this.top = source.top, this.bottom = source.bottom, this.near = source.near, this.far = source.far, this.zoom = source.zoom, this.view = null === source.view ? null : Object.assign({}, source.view), this
                }
                setViewOffset(t, e, r, n, o, h) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = r, this.view.offsetY = n, this.view.width = o, this.view.height = h, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        r = (this.right + this.left) / 2,
                        n = (this.top + this.bottom) / 2;
                    let o = r - t,
                        h = r + t,
                        l = n + e,
                        c = n - e;
                    if (null !== this.view && this.view.enabled) {
                        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        o += t * this.view.offsetX, h = o + t * this.view.width, l -= e * this.view.offsetY, c = l - e * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(o, h, l, c, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(meta) {
                    const data = super.toJSON(meta);
                    return data.object.zoom = this.zoom, data.object.left = this.left, data.object.right = this.right, data.object.top = this.top, data.object.bottom = this.bottom, data.object.near = this.near, data.object.far = this.far, null !== this.view && (data.object.view = Object.assign({}, this.view)), data
                }
            }
            Qo.prototype.isOrthographicCamera = !0;
            class $o extends Wo {
                constructor() {
                    super(new Qo(-5, 5, 5, -5, .5, 500))
                }
            }
            $o.prototype.isDirectionalLightShadow = !0;
            class eh extends Vo {
                constructor(t, e) {
                    super(t, e), this.type = "DirectionalLight", this.position.copy(_e.DefaultUp), this.updateMatrix(), this.target = new _e, this.shadow = new $o
                }
                dispose() {
                    this.shadow.dispose()
                }
                copy(source) {
                    return super.copy(source), this.target = source.target.clone(), this.shadow = source.shadow.clone(), this
                }
            }
            eh.prototype.isDirectionalLight = !0;
            class ih extends Vo {
                constructor(t, e) {
                    super(t, e), this.type = "AmbientLight"
                }
            }
            ih.prototype.isAmbientLight = !0;
            class rh extends Vo {
                constructor(t, e, r = 10, n = 10) {
                    super(t, e), this.type = "RectAreaLight", this.width = r, this.height = n
                }
                copy(source) {
                    return super.copy(source), this.width = source.width, this.height = source.height, this
                }
                toJSON(meta) {
                    const data = super.toJSON(meta);
                    return data.object.width = this.width, data.object.height = this.height, data
                }
            }
            rh.prototype.isRectAreaLight = !0;
            class nh {
                constructor() {
                    this.coefficients = [];
                    for (let i = 0; i < 9; i++) this.coefficients.push(new vt)
                }
                set(t) {
                    for (let i = 0; i < 9; i++) this.coefficients[i].copy(t[i]);
                    return this
                }
                zero() {
                    for (let i = 0; i < 9; i++) this.coefficients[i].set(0, 0, 0);
                    return this
                }
                getAt(t, e) {
                    const r = t.x,
                        n = t.y,
                        o = t.z,
                        h = this.coefficients;
                    return e.copy(h[0]).multiplyScalar(.282095), e.addScaledVector(h[1], .488603 * n), e.addScaledVector(h[2], .488603 * o), e.addScaledVector(h[3], .488603 * r), e.addScaledVector(h[4], r * n * 1.092548), e.addScaledVector(h[5], n * o * 1.092548), e.addScaledVector(h[6], .315392 * (3 * o * o - 1)), e.addScaledVector(h[7], r * o * 1.092548), e.addScaledVector(h[8], .546274 * (r * r - n * n)), e
                }
                getIrradianceAt(t, e) {
                    const r = t.x,
                        n = t.y,
                        o = t.z,
                        h = this.coefficients;
                    return e.copy(h[0]).multiplyScalar(.886227), e.addScaledVector(h[1], 1.023328 * n), e.addScaledVector(h[2], 1.023328 * o), e.addScaledVector(h[3], 1.023328 * r), e.addScaledVector(h[4], .858086 * r * n), e.addScaledVector(h[5], .858086 * n * o), e.addScaledVector(h[6], .743125 * o * o - .247708), e.addScaledVector(h[7], .858086 * r * o), e.addScaledVector(h[8], .429043 * (r * r - n * n)), e
                }
                add(t) {
                    for (let i = 0; i < 9; i++) this.coefficients[i].add(t.coefficients[i]);
                    return this
                }
                addScaledSH(t, s) {
                    for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(t.coefficients[i], s);
                    return this
                }
                scale(s) {
                    for (let i = 0; i < 9; i++) this.coefficients[i].multiplyScalar(s);
                    return this
                }
                lerp(t, e) {
                    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e);
                    return this
                }
                equals(t) {
                    for (let i = 0; i < 9; i++)
                        if (!this.coefficients[i].equals(t.coefficients[i])) return !1;
                    return !0
                }
                copy(t) {
                    return this.set(t.coefficients)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                fromArray(t, e = 0) {
                    const r = this.coefficients;
                    for (let i = 0; i < 9; i++) r[i].fromArray(t, e + 3 * i);
                    return this
                }
                toArray(t = [], e = 0) {
                    const r = this.coefficients;
                    for (let i = 0; i < 9; i++) r[i].toArray(t, e + 3 * i);
                    return t
                }
                static getBasisAt(t, e) {
                    const r = t.x,
                        n = t.y,
                        o = t.z;
                    e[0] = .282095, e[1] = .488603 * n, e[2] = .488603 * o, e[3] = .488603 * r, e[4] = 1.092548 * r * n, e[5] = 1.092548 * n * o, e[6] = .315392 * (3 * o * o - 1), e[7] = 1.092548 * r * o, e[8] = .546274 * (r * r - n * n)
                }
            }
            nh.prototype.isSphericalHarmonics3 = !0;
            class sh extends Vo {
                constructor(t = new nh, e = 1) {
                    super(void 0, e), this.sh = t
                }
                copy(source) {
                    return super.copy(source), this.sh.copy(source.sh), this
                }
                fromJSON(t) {
                    return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                }
                toJSON(meta) {
                    const data = super.toJSON(meta);
                    return data.object.sh = this.sh.toArray(), data
                }
            }
            sh.prototype.isLightProbe = !0;
            class ah {
                static decodeText(t) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                    let s = "";
                    for (let i = 0, e = t.length; i < e; i++) s += String.fromCharCode(t[i]);
                    try {
                        return decodeURIComponent(escape(s))
                    } catch (t) {
                        return s
                    }
                }
                static extractUrlBase(t) {
                    const e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.substr(0, e + 1)
                }
            }
            class oh extends ii {
                constructor() {
                    super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
                }
                copy(source) {
                    return super.copy(source), this.instanceCount = source.instanceCount, this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    const data = super.toJSON(this);
                    return data.instanceCount = this.instanceCount, data.isInstancedBufferGeometry = !0, data
                }
            }
            oh.prototype.isInstancedBufferGeometry = !0;
            class hh extends We {
                constructor(t, e, r, n = 1) {
                    "number" == typeof r && (n = r, r = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, r), this.meshPerAttribute = n
                }
                copy(source) {
                    return super.copy(source), this.meshPerAttribute = source.meshPerAttribute, this
                }
                toJSON() {
                    const data = super.toJSON();
                    return data.meshPerAttribute = this.meshPerAttribute, data.isInstancedBufferAttribute = !0, data
                }
            }
            hh.prototype.isInstancedBufferAttribute = !0;
            (class extends Lo {
                constructor(t) {
                    super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                        premultiplyAlpha: "none"
                    }
                }
                setOptions(t) {
                    return this.options = t, this
                }
                load(t, e, r, n) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const o = this,
                        h = Ao.get(t);
                    if (void 0 !== h) return o.manager.itemStart(t), setTimeout((function () {
                        e && e(h), o.manager.itemEnd(t)
                    }), 0), h;
                    const l = {};
                    l.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", l.headers = this.requestHeader, fetch(t, l).then((function (t) {
                        return t.blob()
                    })).then((function (t) {
                        return createImageBitmap(t, Object.assign(o.options, {
                            colorSpaceConversion: "none"
                        }))
                    })).then((function (r) {
                        Ao.add(t, r), e && e(r), o.manager.itemEnd(t)
                    })).catch((function (e) {
                        n && n(e), o.manager.itemError(t), o.manager.itemEnd(t)
                    })), o.manager.itemStart(t)
                }
            }).prototype.isImageBitmapLoader = !0;
            class lh {
                constructor() {
                    this.type = "ShapePath", this.color = new Oe, this.subPaths = [], this.currentPath = null
                }
                moveTo(t, e) {
                    return this.currentPath = new Bo, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
                }
                lineTo(t, e) {
                    return this.currentPath.lineTo(t, e), this
                }
                quadraticCurveTo(t, e, r, n) {
                    return this.currentPath.quadraticCurveTo(t, e, r, n), this
                }
                bezierCurveTo(t, e, r, n, o, h) {
                    return this.currentPath.bezierCurveTo(t, e, r, n, o, h), this
                }
                splineThru(t) {
                    return this.currentPath.splineThru(t), this
                }
                toShapes(t, e) {
                    function r(t) {
                        const e = [];
                        for (let i = 0, r = t.length; i < r; i++) {
                            const r = t[i],
                                n = new zo;
                            n.curves = r.curves, e.push(n)
                        }
                        return e
                    }

                    function n(t, e) {
                        const r = e.length;
                        let n = !1;
                        for (let p = r - 1, q = 0; q < r; p = q++) {
                            let r = e[p],
                                o = e[q],
                                h = o.x - r.x,
                                l = o.y - r.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if (l < 0 && (r = e[q], h = -h, o = e[p], l = -l), t.y < r.y || t.y > o.y) continue;
                                if (t.y === r.y) {
                                    if (t.x === r.x) return !0
                                } else {
                                    const e = l * (t.x - r.x) - h * (t.y - r.y);
                                    if (0 === e) return !0;
                                    if (e < 0) continue;
                                    n = !n
                                }
                            } else {
                                if (t.y !== r.y) continue;
                                if (o.x <= t.x && t.x <= r.x || r.x <= t.x && t.x <= o.x) return !0
                            }
                        }
                        return n
                    }
                    const o = Ja.isClockWise,
                        h = this.subPaths;
                    if (0 === h.length) return [];
                    if (!0 === e) return r(h);
                    let l, c, d;
                    const m = [];
                    if (1 === h.length) return c = h[0], d = new zo, d.curves = c.curves, m.push(d), m;
                    let f = !o(h[0].getPoints());
                    f = t ? !f : f;
                    const y = [],
                        v = [];
                    let x, _, M = [],
                        S = 0;
                    v[S] = void 0, M[S] = [];
                    for (let i = 0, e = h.length; i < e; i++) c = h[i], x = c.getPoints(), l = o(x), l = t ? !l : l, l ? (!f && v[S] && S++, v[S] = {
                        s: new zo,
                        p: x
                    }, v[S].s.curves = c.curves, f && S++, M[S] = []) : M[S].push({
                        h: c,
                        p: x[0]
                    });
                    if (!v[0]) return r(h);
                    if (v.length > 1) {
                        let t = !1;
                        const e = [];
                        for (let t = 0, e = v.length; t < e; t++) y[t] = [];
                        for (let r = 0, o = v.length; r < o; r++) {
                            const o = M[r];
                            for (let h = 0; h < o.length; h++) {
                                const l = o[h];
                                let c = !0;
                                for (let o = 0; o < v.length; o++) n(l.p, v[o].p) && (r !== o && e.push({
                                    froms: r,
                                    tos: o,
                                    hole: h
                                }), c ? (c = !1, y[o].push(l)) : t = !0);
                                c && y[r].push(l)
                            }
                        }
                        e.length > 0 && (t || (M = y))
                    }
                    for (let i = 0, t = v.length; i < t; i++) {
                        d = v[i].s, m.push(d), _ = M[i];
                        for (let t = 0, e = _.length; t < e; t++) d.holes.push(_[t].h)
                    }
                    return m
                }
            }
            class ch {
                constructor(data) {
                    this.type = "Font", this.data = data
                }
                generateShapes(text, t = 100) {
                    const e = [],
                        r = function (text, t, data) {
                            const e = Array.from(text),
                                r = t / data.resolution,
                                n = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * r,
                                o = [];
                            let h = 0,
                                l = 0;
                            for (let i = 0; i < e.length; i++) {
                                const t = e[i];
                                if ("\n" === t) h = 0, l -= n;
                                else {
                                    const e = ph(t, r, h, l, data);
                                    h += e.offsetX, o.push(e.path)
                                }
                            }
                            return o
                        }(text, t, this.data);
                    for (let p = 0, t = r.length; p < t; p++) Array.prototype.push.apply(e, r[p].toShapes());
                    return e
                }
            }

            function ph(t, e, r, n, data) {
                const glyph = data.glyphs[t] || data.glyphs["?"];
                if (!glyph) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + data.familyName + ".");
                const path = new lh;
                let o, h, l, c, d, m, f, y;
                if (glyph.o) {
                    const t = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
                    for (let i = 0, v = t.length; i < v;) {
                        switch (t[i++]) {
                            case "m":
                                o = t[i++] * e + r, h = t[i++] * e + n, path.moveTo(o, h);
                                break;
                            case "l":
                                o = t[i++] * e + r, h = t[i++] * e + n, path.lineTo(o, h);
                                break;
                            case "q":
                                l = t[i++] * e + r, c = t[i++] * e + n, d = t[i++] * e + r, m = t[i++] * e + n, path.quadraticCurveTo(d, m, l, c);
                                break;
                            case "b":
                                l = t[i++] * e + r, c = t[i++] * e + n, d = t[i++] * e + r, m = t[i++] * e + n, f = t[i++] * e + r, y = t[i++] * e + n, path.bezierCurveTo(d, m, f, y, l, c)
                        }
                    }
                }
                return {
                    offsetX: glyph.ha * e,
                    path: path
                }
            }
            ch.prototype.isFont = !0;
            let uh;
            const dh = function () {
                return void 0 === uh && (uh = new(window.AudioContext || window.webkitAudioContext)), uh
            };
            class mh extends Lo {
                constructor(t) {
                    super(t)
                }
                load(t, e, r, n) {
                    const o = this,
                        h = new Ro(this.manager);
                    h.setResponseType("arraybuffer"), h.setPath(this.path), h.setRequestHeader(this.requestHeader), h.setWithCredentials(this.withCredentials), h.load(t, (function (r) {
                        try {
                            const t = r.slice(0);
                            dh().decodeAudioData(t, (function (t) {
                                e(t)
                            }))
                        } catch (e) {
                            n ? n(e) : console.error(e), o.manager.itemError(t)
                        }
                    }), r, n)
                }
            }(class extends sh {
                constructor(t, e, r = 1) {
                    super(void 0, r);
                    const n = (new Oe).set(t),
                        o = (new Oe).set(e),
                        h = new vt(n.r, n.g, n.b),
                        l = new vt(o.r, o.g, o.b),
                        c = Math.sqrt(Math.PI),
                        d = c * Math.sqrt(.75);
                    this.sh.coefficients[0].copy(h).add(l).multiplyScalar(c), this.sh.coefficients[1].copy(h).sub(l).multiplyScalar(d)
                }
            }).prototype.isHemisphereLightProbe = !0;
            (class extends sh {
                constructor(t, e = 1) {
                    super(void 0, e);
                    const r = (new Oe).set(t);
                    this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                }
            }).prototype.isAmbientLightProbe = !0;
            class fh extends _e {
                constructor(t) {
                    super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                }
                getOutput() {
                    return this.gain
                }
                setNodeSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                }
                setMediaElementSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                }
                setMediaStreamSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
                }
                setBuffer(t) {
                    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                }
                play(t = 0) {
                    if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                    if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                    this._startedAt = this.context.currentTime + t;
                    const source = this.context.createBufferSource();
                    return source.buffer = this.buffer, source.loop = this.loop, source.loopStart = this.loopStart, source.loopEnd = this.loopEnd, source.onended = this.onEnded.bind(this), source.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = source, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                pause() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                stop() {
                    if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                connect() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (let i = 1, t = this.filters.length; i < t; i++) this.filters[i - 1].connect(this.filters[i]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this._connected = !0, this
                }
                disconnect() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let i = 1, t = this.filters.length; i < t; i++) this.filters[i - 1].disconnect(this.filters[i]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this._connected = !1, this
                }
                getFilters() {
                    return this.filters
                }
                setFilters(t) {
                    return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
                }
                setDetune(t) {
                    if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                }
                getDetune() {
                    return this.detune
                }
                getFilter() {
                    return this.getFilters()[0]
                }
                setFilter(filter) {
                    return this.setFilters(filter ? [filter] : [])
                }
                setPlaybackRate(t) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                getPlaybackRate() {
                    return this.playbackRate
                }
                onEnded() {
                    this.isPlaying = !1
                }
                getLoop() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                }
                setLoop(t) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                setLoopStart(t) {
                    return this.loopStart = t, this
                }
                setLoopEnd(t) {
                    return this.loopEnd = t, this
                }
                getVolume() {
                    return this.gain.gain.value
                }
                setVolume(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                }
            }
            class gh {
                constructor(t, e, r) {
                    let n, o, h;
                    switch (this.binding = t, this.valueSize = r, e) {
                        case "quaternion":
                            n = this._slerp, o = this._slerpAdditive, h = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * r), this._workIndex = 5;
                            break;
                        case "string":
                        case "bool":
                            n = this._select, o = this._select, h = this._setAdditiveIdentityOther, this.buffer = new Array(5 * r);
                            break;
                        default:
                            n = this._lerp, o = this._lerpAdditive, h = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * r)
                    }
                    this._mixBufferRegion = n, this._mixBufferRegionAdditive = o, this._setIdentity = h, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                }
                accumulate(t, e) {
                    const r = this.buffer,
                        n = this.valueSize,
                        o = t * n + n;
                    let h = this.cumulativeWeight;
                    if (0 === h) {
                        for (let i = 0; i !== n; ++i) r[o + i] = r[i];
                        h = e
                    } else {
                        h += e;
                        const t = e / h;
                        this._mixBufferRegion(r, o, 0, t, n)
                    }
                    this.cumulativeWeight = h
                }
                accumulateAdditive(t) {
                    const e = this.buffer,
                        r = this.valueSize,
                        n = r * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, n, 0, t, r), this.cumulativeWeightAdditive += t
                }
                apply(t) {
                    const e = this.valueSize,
                        r = this.buffer,
                        n = t * e + e,
                        o = this.cumulativeWeight,
                        h = this.cumulativeWeightAdditive,
                        l = this.binding;
                    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, o < 1) {
                        const t = e * this._origIndex;
                        this._mixBufferRegion(r, n, t, 1 - o, e)
                    }
                    h > 0 && this._mixBufferRegionAdditive(r, n, this._addIndex * e, 1, e);
                    for (let i = e, t = e + e; i !== t; ++i)
                        if (r[i] !== r[i + e]) {
                            l.setValue(r, n);
                            break
                        }
                }
                saveOriginalState() {
                    const t = this.binding,
                        e = this.buffer,
                        r = this.valueSize,
                        n = r * this._origIndex;
                    t.getValue(e, n);
                    for (let i = r, t = n; i !== t; ++i) e[i] = e[n + i % r];
                    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                }
                restoreOriginalState() {
                    const t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t)
                }
                _setAdditiveIdentityNumeric() {
                    const t = this._addIndex * this.valueSize,
                        e = t + this.valueSize;
                    for (let i = t; i < e; i++) this.buffer[i] = 0
                }
                _setAdditiveIdentityQuaternion() {
                    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                }
                _setAdditiveIdentityOther() {
                    const t = this._origIndex * this.valueSize,
                        e = this._addIndex * this.valueSize;
                    for (let i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i]
                }
                _select(t, e, r, n, o) {
                    if (n >= .5)
                        for (let i = 0; i !== o; ++i) t[e + i] = t[r + i]
                }
                _slerp(t, e, r, n) {
                    yt.slerpFlat(t, e, t, e, t, r, n)
                }
                _slerpAdditive(t, e, r, n, o) {
                    const h = this._workIndex * o;
                    yt.multiplyQuaternionsFlat(t, h, t, e, t, r), yt.slerpFlat(t, e, t, e, t, h, n)
                }
                _lerp(t, e, r, n, o) {
                    const s = 1 - n;
                    for (let i = 0; i !== o; ++i) {
                        const o = e + i;
                        t[o] = t[o] * s + t[r + i] * n
                    }
                }
                _lerpAdditive(t, e, r, n, o) {
                    for (let i = 0; i !== o; ++i) {
                        const o = e + i;
                        t[o] = t[o] + t[r + i] * n
                    }
                }
            }
            const yh = "\\[\\]\\.:\\/",
                vh = new RegExp("[\\[\\]\\.:\\/]", "g"),
                xh = "[^\\[\\]\\.:\\/]",
                _h = "[^" + yh.replace("\\.", "") + "]",
                bh = /((?:WC+[\/:])*)/.source.replace("WC", xh),
                Mh = /(WCOD+)?/.source.replace("WCOD", _h),
                Sh = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", xh),
                wh = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", xh),
                Eh = new RegExp("^" + bh + Mh + Sh + wh + "$"),
                Th = ["material", "materials", "bones"];
            class Ah {
                constructor(t, path, e) {
                    this.path = path, this.parsedPath = e || Ah.parseTrackName(path), this.node = Ah.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
                static create(t, path, e) {
                    return t && t.isAnimationObjectGroup ? new Ah.Composite(t, path, e) : new Ah(t, path, e)
                }
                static sanitizeNodeName(t) {
                    return t.replace(/\s/g, "_").replace(vh, "")
                }
                static parseTrackName(t) {
                    const e = Eh.exec(t);
                    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    const r = {
                            nodeName: e[2],
                            objectName: e[3],
                            objectIndex: e[4],
                            propertyName: e[5],
                            propertyIndex: e[6]
                        },
                        n = r.nodeName && r.nodeName.lastIndexOf(".");
                    if (void 0 !== n && -1 !== n) {
                        const t = r.nodeName.substring(n + 1); - 1 !== Th.indexOf(t) && (r.nodeName = r.nodeName.substring(0, n), r.objectName = t)
                    }
                    if (null === r.propertyName || 0 === r.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return r
                }
                static findNode(t, e) {
                    if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                    if (t.skeleton) {
                        const r = t.skeleton.getBoneByName(e);
                        if (void 0 !== r) return r
                    }
                    if (t.children) {
                        const r = function (t) {
                                for (let i = 0; i < t.length; i++) {
                                    const n = t[i];
                                    if (n.name === e || n.uuid === e) return n;
                                    const o = r(n.children);
                                    if (o) return o
                                }
                                return null
                            },
                            n = r(t.children);
                        if (n) return n
                    }
                    return null
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(t, e) {
                    t[e] = this.node[this.propertyName]
                }
                _getValue_array(t, e) {
                    const source = this.resolvedProperty;
                    for (let i = 0, r = source.length; i !== r; ++i) t[e++] = source[i]
                }
                _getValue_arrayElement(t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex]
                }
                _getValue_toArray(t, e) {
                    this.resolvedProperty.toArray(t, e)
                }
                _setValue_direct(t, e) {
                    this.targetObject[this.propertyName] = t[e]
                }
                _setValue_direct_setNeedsUpdate(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                    this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_array(t, e) {
                    const r = this.resolvedProperty;
                    for (let i = 0, n = r.length; i !== n; ++i) r[i] = t[e++]
                }
                _setValue_array_setNeedsUpdate(t, e) {
                    const r = this.resolvedProperty;
                    for (let i = 0, n = r.length; i !== n; ++i) r[i] = t[e++];
                    this.targetObject.needsUpdate = !0
                }
                _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                    const r = this.resolvedProperty;
                    for (let i = 0, n = r.length; i !== n; ++i) r[i] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_arrayElement(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e]
                }
                _setValue_arrayElement_setNeedsUpdate(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_fromArray(t, e) {
                    this.resolvedProperty.fromArray(t, e)
                }
                _setValue_fromArray_setNeedsUpdate(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                    this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _getValue_unbound(t, e) {
                    this.bind(), this.getValue(t, e)
                }
                _setValue_unbound(t, e) {
                    this.bind(), this.setValue(t, e)
                }
                bind() {
                    let t = this.node;
                    const e = this.parsedPath,
                        r = e.objectName,
                        n = e.propertyName;
                    let o = e.propertyIndex;
                    if (t || (t = Ah.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                    if (r) {
                        let n = e.objectIndex;
                        switch (r) {
                            case "materials":
                                if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                t = t.skeleton.bones;
                                for (let i = 0; i < t.length; i++)
                                    if (t[i].name === n) {
                                        n = i;
                                        break
                                    } break;
                            default:
                                if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                t = t[r]
                        }
                        if (void 0 !== n) {
                            if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                            t = t[n]
                        }
                    }
                    const h = t[n];
                    if (void 0 === h) {
                        const r = e.nodeName;
                        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + r + "." + n + " but it wasn't found.", t)
                    }
                    let l = this.Versioning.None;
                    this.targetObject = t, void 0 !== t.needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate);
                    let c = this.BindingType.Direct;
                    if (void 0 !== o) {
                        if ("morphTargetInfluences" === n) {
                            if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== t.morphTargetDictionary[o] && (o = t.morphTargetDictionary[o])
                        }
                        c = this.BindingType.ArrayElement, this.resolvedProperty = h, this.propertyIndex = o
                    } else void 0 !== h.fromArray && void 0 !== h.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = h) : Array.isArray(h) ? (c = this.BindingType.EntireArray, this.resolvedProperty = h) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l]
                }
                unbind() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }
            Ah.Composite = class {
                constructor(t, path, e) {
                    const r = e || Ah.parseTrackName(path);
                    this._targetGroup = t, this._bindings = t.subscribe_(path, r)
                }
                getValue(t, e) {
                    this.bind();
                    const r = this._targetGroup.nCachedObjects_,
                        n = this._bindings[r];
                    void 0 !== n && n.getValue(t, e)
                }
                setValue(t, e) {
                    const r = this._bindings;
                    for (let i = this._targetGroup.nCachedObjects_, n = r.length; i !== n; ++i) r[i].setValue(t, e)
                }
                bind() {
                    const t = this._bindings;
                    for (let i = this._targetGroup.nCachedObjects_, e = t.length; i !== e; ++i) t[i].bind()
                }
                unbind() {
                    const t = this._bindings;
                    for (let i = this._targetGroup.nCachedObjects_, e = t.length; i !== e; ++i) t[i].unbind()
                }
            }, Ah.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            }, Ah.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            }, Ah.prototype.GetterByBindingType = [Ah.prototype._getValue_direct, Ah.prototype._getValue_array, Ah.prototype._getValue_arrayElement, Ah.prototype._getValue_toArray], Ah.prototype.SetterByBindingTypeAndVersioning = [
                [Ah.prototype._setValue_direct, Ah.prototype._setValue_direct_setNeedsUpdate, Ah.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                [Ah.prototype._setValue_array, Ah.prototype._setValue_array_setNeedsUpdate, Ah.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                [Ah.prototype._setValue_arrayElement, Ah.prototype._setValue_arrayElement_setNeedsUpdate, Ah.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                [Ah.prototype._setValue_fromArray, Ah.prototype._setValue_fromArray_setNeedsUpdate, Ah.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
            ];
            class Ph {
                constructor(t, e, r = null, n = e.blendMode) {
                    this._mixer = t, this._clip = e, this._localRoot = r, this.blendMode = n;
                    const o = e.tracks,
                        h = o.length,
                        l = new Array(h),
                        c = {
                            endingStart: N,
                            endingEnd: N
                        };
                    for (let i = 0; i !== h; ++i) {
                        const t = o[i].createInterpolant(null);
                        l[i] = t, t.settings = c
                    }
                    this._interpolantSettings = c, this._interpolants = l, this._propertyBindings = new Array(h), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                }
                play() {
                    return this._mixer._activateAction(this), this
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset()
                }
                reset() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                }
                isRunning() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this)
                }
                startAt(time) {
                    return this._startTime = time, this
                }
                setLoop(t, e) {
                    return this.loop = t, this.repetitions = e, this
                }
                setEffectiveWeight(t) {
                    return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                }
                getEffectiveWeight() {
                    return this._effectiveWeight
                }
                fadeIn(t) {
                    return this._scheduleFading(t, 0, 1)
                }
                fadeOut(t) {
                    return this._scheduleFading(t, 1, 0)
                }
                crossFadeFrom(t, e, r) {
                    if (t.fadeOut(e), this.fadeIn(e), r) {
                        const r = this._clip.duration,
                            n = t._clip.duration,
                            o = n / r,
                            h = r / n;
                        t.warp(1, o, e), this.warp(h, 1, e)
                    }
                    return this
                }
                crossFadeTo(t, e, r) {
                    return t.crossFadeFrom(this, e, r)
                }
                stopFading() {
                    const t = this._weightInterpolant;
                    return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                }
                setEffectiveTimeScale(t) {
                    return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale
                }
                setDuration(t) {
                    return this.timeScale = this._clip.duration / t, this.stopWarping()
                }
                syncWith(t) {
                    return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                }
                halt(t) {
                    return this.warp(this._effectiveTimeScale, 0, t)
                }
                warp(t, e, r) {
                    const n = this._mixer,
                        o = n.time,
                        h = this.timeScale;
                    let l = this._timeScaleInterpolant;
                    null === l && (l = n._lendControlInterpolant(), this._timeScaleInterpolant = l);
                    const c = l.parameterPositions,
                        d = l.sampleValues;
                    return c[0] = o, c[1] = o + r, d[0] = t / h, d[1] = e / h, this
                }
                stopWarping() {
                    const t = this._timeScaleInterpolant;
                    return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                }
                getMixer() {
                    return this._mixer
                }
                getClip() {
                    return this._clip
                }
                getRoot() {
                    return this._localRoot || this._mixer._root
                }
                _update(time, t, e, r) {
                    if (!this.enabled) return void this._updateWeight(time);
                    const n = this._startTime;
                    if (null !== n) {
                        const r = (time - n) * e;
                        if (r < 0 || 0 === e) return;
                        this._startTime = null, t = e * r
                    }
                    t *= this._updateTimeScale(time);
                    const o = this._updateTime(t),
                        h = this._updateWeight(time);
                    if (h > 0) {
                        const t = this._interpolants,
                            e = this._propertyBindings;
                        switch (this.blendMode) {
                            case 2501:
                                for (let r = 0, n = t.length; r !== n; ++r) t[r].evaluate(o), e[r].accumulateAdditive(h);
                                break;
                            case V:
                            default:
                                for (let n = 0, l = t.length; n !== l; ++n) t[n].evaluate(o), e[n].accumulate(r, h)
                        }
                    }
                }
                _updateWeight(time) {
                    let t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        const e = this._weightInterpolant;
                        if (null !== e) {
                            const r = e.evaluate(time)[0];
                            t *= r, time > e.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = t, t
                }
                _updateTimeScale(time) {
                    let t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        const e = this._timeScaleInterpolant;
                        if (null !== e) {
                            t *= e.evaluate(time)[0], time > e.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                        }
                    }
                    return this._effectiveTimeScale = t, t
                }
                _updateTime(t) {
                    const e = this._clip.duration,
                        r = this.loop;
                    let time = this.time + t,
                        n = this._loopCount;
                    const o = 2202 === r;
                    if (0 === t) return -1 === n ? time : o && 1 == (1 & n) ? e - time : time;
                    if (2200 === r) {
                        -1 === n && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        t: {
                            if (time >= e) time = e;
                            else {
                                if (!(time < 0)) {
                                    this.time = time;
                                    break t
                                }
                                time = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = time,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === n && (t >= 0 ? (n = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), time >= e || time < 0) {
                            const r = Math.floor(time / e);
                            time -= e * r, n += Math.abs(r);
                            const h = this.repetitions - n;
                            if (h <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, time = t > 0 ? e : 0, this.time = time, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t > 0 ? 1 : -1
                            });
                            else {
                                if (1 === h) {
                                    const e = t < 0;
                                    this._setEndings(e, !e, o)
                                } else this._setEndings(!1, !1, o);
                                this._loopCount = n, this.time = time, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: r
                                })
                            }
                        } else this.time = time;
                        if (o && 1 == (1 & n)) return e - time
                    }
                    return time
                }
                _setEndings(t, e, r) {
                    const n = this._interpolantSettings;
                    r ? (n.endingStart = B, n.endingEnd = B) : (n.endingStart = t ? this.zeroSlopeAtStart ? B : N : z, n.endingEnd = e ? this.zeroSlopeAtEnd ? B : N : z)
                }
                _scheduleFading(t, e, r) {
                    const n = this._mixer,
                        o = n.time;
                    let h = this._weightInterpolant;
                    null === h && (h = n._lendControlInterpolant(), this._weightInterpolant = h);
                    const l = h.parameterPositions,
                        c = h.sampleValues;
                    return l[0] = o, c[0] = e, l[1] = o + t, c[1] = r, this
                }
            }(class extends J {
                constructor(t) {
                    super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                }
                _bindAction(t, e) {
                    const r = t._localRoot || this._root,
                        n = t._clip.tracks,
                        o = n.length,
                        h = t._propertyBindings,
                        l = t._interpolants,
                        c = r.uuid,
                        d = this._bindingsByRootAndName;
                    let m = d[c];
                    void 0 === m && (m = {}, d[c] = m);
                    for (let i = 0; i !== o; ++i) {
                        const track = n[i],
                            t = track.name;
                        let o = m[t];
                        if (void 0 !== o) h[i] = o;
                        else {
                            if (o = h[i], void 0 !== o) {
                                null === o._cacheIndex && (++o.referenceCount, this._addInactiveBinding(o, c, t));
                                continue
                            }
                            const path = e && e._propertyBindings[i].binding.parsedPath;
                            o = new gh(Ah.create(r, t, path), track.ValueTypeName, track.getValueSize()), ++o.referenceCount, this._addInactiveBinding(o, c, t), h[i] = o
                        }
                        l[i].resultBuffer = o.buffer
                    }
                }
                _activateAction(t) {
                    if (!this._isActiveAction(t)) {
                        if (null === t._cacheIndex) {
                            const e = (t._localRoot || this._root).uuid,
                                r = t._clip.uuid,
                                n = this._actionsByClip[r];
                            this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, r, e)
                        }
                        const e = t._propertyBindings;
                        for (let i = 0, t = e.length; i !== t; ++i) {
                            const t = e[i];
                            0 == t.useCount++ && (this._lendBinding(t), t.saveOriginalState())
                        }
                        this._lendAction(t)
                    }
                }
                _deactivateAction(t) {
                    if (this._isActiveAction(t)) {
                        const e = t._propertyBindings;
                        for (let i = 0, t = e.length; i !== t; ++i) {
                            const t = e[i];
                            0 == --t.useCount && (t.restoreOriginalState(), this._takeBackBinding(t))
                        }
                        this._takeBackAction(t)
                    }
                }
                _initMemoryManager() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    const t = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return t._actions.length
                            },
                            get inUse() {
                                return t._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return t._bindings.length
                            },
                            get inUse() {
                                return t._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return t._controlInterpolants.length
                            },
                            get inUse() {
                                return t._nActiveControlInterpolants
                            }
                        }
                    }
                }
                _isActiveAction(t) {
                    const e = t._cacheIndex;
                    return null !== e && e < this._nActiveActions
                }
                _addInactiveAction(t, e, r) {
                    const n = this._actions,
                        o = this._actionsByClip;
                    let h = o[e];
                    if (void 0 === h) h = {
                        knownActions: [t],
                        actionByRoot: {}
                    }, t._byClipCacheIndex = 0, o[e] = h;
                    else {
                        const e = h.knownActions;
                        t._byClipCacheIndex = e.length, e.push(t)
                    }
                    t._cacheIndex = n.length, n.push(t), h.actionByRoot[r] = t
                }
                _removeInactiveAction(t) {
                    const e = this._actions,
                        r = e[e.length - 1],
                        n = t._cacheIndex;
                    r._cacheIndex = n, e[n] = r, e.pop(), t._cacheIndex = null;
                    const o = t._clip.uuid,
                        h = this._actionsByClip,
                        l = h[o],
                        c = l.knownActions,
                        d = c[c.length - 1],
                        m = t._byClipCacheIndex;
                    d._byClipCacheIndex = m, c[m] = d, c.pop(), t._byClipCacheIndex = null;
                    delete l.actionByRoot[(t._localRoot || this._root).uuid], 0 === c.length && delete h[o], this._removeInactiveBindingsForAction(t)
                }
                _removeInactiveBindingsForAction(t) {
                    const e = t._propertyBindings;
                    for (let i = 0, t = e.length; i !== t; ++i) {
                        const t = e[i];
                        0 == --t.referenceCount && this._removeInactiveBinding(t)
                    }
                }
                _lendAction(t) {
                    const e = this._actions,
                        r = t._cacheIndex,
                        n = this._nActiveActions++,
                        o = e[n];
                    t._cacheIndex = n, e[n] = t, o._cacheIndex = r, e[r] = o
                }
                _takeBackAction(t) {
                    const e = this._actions,
                        r = t._cacheIndex,
                        n = --this._nActiveActions,
                        o = e[n];
                    t._cacheIndex = n, e[n] = t, o._cacheIndex = r, e[r] = o
                }
                _addInactiveBinding(t, e, r) {
                    const n = this._bindingsByRootAndName,
                        o = this._bindings;
                    let h = n[e];
                    void 0 === h && (h = {}, n[e] = h), h[r] = t, t._cacheIndex = o.length, o.push(t)
                }
                _removeInactiveBinding(t) {
                    const e = this._bindings,
                        r = t.binding,
                        n = r.rootNode.uuid,
                        o = r.path,
                        h = this._bindingsByRootAndName,
                        l = h[n],
                        c = e[e.length - 1],
                        d = t._cacheIndex;
                    c._cacheIndex = d, e[d] = c, e.pop(), delete l[o], 0 === Object.keys(l).length && delete h[n]
                }
                _lendBinding(t) {
                    const e = this._bindings,
                        r = t._cacheIndex,
                        n = this._nActiveBindings++,
                        o = e[n];
                    t._cacheIndex = n, e[n] = t, o._cacheIndex = r, e[r] = o
                }
                _takeBackBinding(t) {
                    const e = this._bindings,
                        r = t._cacheIndex,
                        n = --this._nActiveBindings,
                        o = e[n];
                    t._cacheIndex = n, e[n] = t, o._cacheIndex = r, e[r] = o
                }
                _lendControlInterpolant() {
                    const t = this._controlInterpolants,
                        e = this._nActiveControlInterpolants++;
                    let r = t[e];
                    return void 0 === r && (r = new fo(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), r.__cacheIndex = e, t[e] = r), r
                }
                _takeBackControlInterpolant(t) {
                    const e = this._controlInterpolants,
                        r = t.__cacheIndex,
                        n = --this._nActiveControlInterpolants,
                        o = e[n];
                    t.__cacheIndex = n, e[n] = t, o.__cacheIndex = r, e[r] = o
                }
                clipAction(t, e, r) {
                    const n = e || this._root,
                        o = n.uuid;
                    let h = "string" == typeof t ? Eo.findByName(n, t) : t;
                    const l = null !== h ? h.uuid : t,
                        c = this._actionsByClip[l];
                    let d = null;
                    if (void 0 === r && (r = null !== h ? h.blendMode : V), void 0 !== c) {
                        const t = c.actionByRoot[o];
                        if (void 0 !== t && t.blendMode === r) return t;
                        d = c.knownActions[0], null === h && (h = d._clip)
                    }
                    if (null === h) return null;
                    const m = new Ph(this, h, e, r);
                    return this._bindAction(m, d), this._addInactiveAction(m, l, o), m
                }
                existingAction(t, e) {
                    const r = e || this._root,
                        n = r.uuid,
                        o = "string" == typeof t ? Eo.findByName(r, t) : t,
                        h = o ? o.uuid : t,
                        l = this._actionsByClip[h];
                    return void 0 !== l && l.actionByRoot[n] || null
                }
                stopAllAction() {
                    const t = this._actions;
                    for (let i = this._nActiveActions - 1; i >= 0; --i) t[i].stop();
                    return this
                }
                update(t) {
                    t *= this.timeScale;
                    const e = this._actions,
                        r = this._nActiveActions,
                        time = this.time += t,
                        n = Math.sign(t),
                        o = this._accuIndex ^= 1;
                    for (let i = 0; i !== r; ++i) {
                        e[i]._update(time, t, n, o)
                    }
                    const h = this._bindings,
                        l = this._nActiveBindings;
                    for (let i = 0; i !== l; ++i) h[i].apply(o);
                    return this
                }
                setTime(t) {
                    this.time = 0;
                    for (let i = 0; i < this._actions.length; i++) this._actions[i].time = 0;
                    return this.update(t)
                }
                getRoot() {
                    return this._root
                }
                uncacheClip(t) {
                    const e = this._actions,
                        r = t.uuid,
                        n = this._actionsByClip,
                        o = n[r];
                    if (void 0 !== o) {
                        const t = o.knownActions;
                        for (let i = 0, r = t.length; i !== r; ++i) {
                            const r = t[i];
                            this._deactivateAction(r);
                            const n = r._cacheIndex,
                                o = e[e.length - 1];
                            r._cacheIndex = null, r._byClipCacheIndex = null, o._cacheIndex = n, e[n] = o, e.pop(), this._removeInactiveBindingsForAction(r)
                        }
                        delete n[r]
                    }
                }
                uncacheRoot(t) {
                    const e = t.uuid,
                        r = this._actionsByClip;
                    for (const t in r) {
                        const n = r[t].actionByRoot[e];
                        void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                    }
                    const n = this._bindingsByRootAndName[e];
                    if (void 0 !== n)
                        for (const t in n) {
                            const e = n[t];
                            e.restoreOriginalState(), this._removeInactiveBinding(e)
                        }
                }
                uncacheAction(t, e) {
                    const r = this.existingAction(t, e);
                    null !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                }
            }).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
            class Ch {
                constructor(t) {
                    "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
                }
                clone() {
                    return new Ch(void 0 === this.value.clone ? this.value : this.value.clone())
                }
            }(class extends ls {
                constructor(t, e, r = 1) {
                    super(t, e), this.meshPerAttribute = r
                }
                copy(source) {
                    return super.copy(source), this.meshPerAttribute = source.meshPerAttribute, this
                }
                clone(data) {
                    const t = super.clone(data);
                    return t.meshPerAttribute = this.meshPerAttribute, t
                }
                toJSON(data) {
                    const t = super.toJSON(data);
                    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
                }
            }).prototype.isInstancedInterleavedBuffer = !0;
            const Lh = new at;
            class Dh {
                constructor(t = new at(1 / 0, 1 / 0), e = new at(-1 / 0, -1 / 0)) {
                    this.min = t, this.max = e
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let i = 0, e = t.length; i < e; i++) this.expandByPoint(t[i]);
                    return this
                }
                setFromCenterAndSize(t, e) {
                    const r = Lh.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                }
                getCenter(t) {
                    return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(t) {
                    return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                }
                containsPoint(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                }
                containsBox(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                }
                getParameter(t, e) {
                    return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                }
                intersectsBox(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                }
                clampPoint(t, e) {
                    return e.copy(t).clamp(this.min, this.max)
                }
                distanceToPoint(t) {
                    return Lh.copy(t).clamp(this.min, this.max).sub(t).length()
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }
            Dh.prototype.isBox2 = !0;
            (class extends _e {
                constructor(t) {
                    super(), this.material = t, this.render = function () {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
                }
            }).prototype.isImmediateRenderObject = !0;
            const Rh = new vt,
                Ih = new Jt,
                Fh = new Jt;

            function kh(object) {
                const t = [];
                object && object.isBone && t.push(object);
                for (let i = 0; i < object.children.length; i++) t.push.apply(t, kh(object.children[i]));
                return t
            }
            const Nh = new Float32Array(1);
            new Int32Array(Nh.buffer);
            Math.pow(2, 8);
            const Bh = [.125, .215, .35, .446, .526, .582],
                zh = 5 + Bh.length,
                Vh = new Ge({
                    side: 1,
                    depthWrite: !1,
                    depthTest: !1
                }),
                {
                    _lodPlanes: Oh,
                    _sizeLods: Gh,
                    _sigmas: Hh
                } = (new bi(new Si, Vh), Uh());
            Math.sqrt(5);

            function Uh() {
                const t = [],
                    e = [],
                    r = [];
                let n = 8;
                for (let i = 0; i < zh; i++) {
                    const o = Math.pow(2, n);
                    e.push(o);
                    let h = 1 / o;
                    i > 4 ? h = Bh[i - 8 + 4 - 1] : 0 == i && (h = 0), r.push(h);
                    const l = 1 / (o - 1),
                        c = -l / 2,
                        d = 1 + l / 2,
                        m = [c, c, d, c, d, d, c, c, d, d, c, d],
                        f = 6,
                        y = 6,
                        v = 3,
                        x = 2,
                        _ = 1,
                        M = new Float32Array(v * y * f),
                        S = new Float32Array(x * y * f),
                        w = new Float32Array(_ * y * f);
                    for (let t = 0; t < f; t++) {
                        const e = t % 3 * 2 / 3 - 1,
                            r = t > 2 ? 0 : -1,
                            n = [e, r, 0, e + 2 / 3, r, 0, e + 2 / 3, r + 1, 0, e, r, 0, e + 2 / 3, r + 1, 0, e, r + 1, 0];
                        M.set(n, v * y * t), S.set(m, x * y * t);
                        const o = [t, t, t, t, t, t];
                        w.set(o, _ * y * t)
                    }
                    const E = new ii;
                    E.setAttribute("position", new We(M, v)), E.setAttribute("uv", new We(S, x)), E.setAttribute("faceIndex", new We(w, _)), t.push(E), n > 4 && n--
                }
                return {
                    _lodPlanes: t,
                    _sizeLods: e,
                    _sigmas: r
                }
            }
            aa.create = function (t, e) {
                return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(aa.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
            }, Bo.prototype.fromPoints = function (t) {
                return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
            }, class extends Zs {
                constructor(t = 10, e = 10, r = 4473924, n = 8947848) {
                    r = new Oe(r), n = new Oe(n);
                    const o = e / 2,
                        h = t / e,
                        l = t / 2,
                        c = [],
                        d = [];
                    for (let i = 0, t = 0, m = -l; i <= e; i++, m += h) {
                        c.push(-l, 0, m, l, 0, m), c.push(m, 0, -l, m, 0, l);
                        const e = i === o ? r : n;
                        e.toArray(d, t), t += 3, e.toArray(d, t), t += 3, e.toArray(d, t), t += 3, e.toArray(d, t), t += 3
                    }
                    const m = new ii;
                    m.setAttribute("position", new Xe(c, 3)), m.setAttribute("color", new Xe(d, 3));
                    super(m, new Gs({
                        vertexColors: !0,
                        toneMapped: !1
                    })), this.type = "GridHelper"
                }
            }.prototype.setColors = function () {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, class extends Zs {
                constructor(object) {
                    const t = kh(object),
                        e = new ii,
                        r = [],
                        n = [],
                        o = new Oe(0, 0, 1),
                        h = new Oe(0, 1, 0);
                    for (let i = 0; i < t.length; i++) {
                        const e = t[i];
                        e.parent && e.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), n.push(o.r, o.g, o.b), n.push(h.r, h.g, h.b))
                    }
                    e.setAttribute("position", new Xe(r, 3)), e.setAttribute("color", new Xe(n, 3));
                    super(e, new Gs({
                        vertexColors: !0,
                        depthTest: !1,
                        depthWrite: !1,
                        toneMapped: !1,
                        transparent: !0
                    })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = object, this.bones = t, this.matrix = object.matrixWorld, this.matrixAutoUpdate = !1
                }
                updateMatrixWorld(t) {
                    const e = this.bones,
                        r = this.geometry,
                        n = r.getAttribute("position");
                    Fh.copy(this.root.matrixWorld).invert();
                    for (let i = 0, t = 0; i < e.length; i++) {
                        const r = e[i];
                        r.parent && r.parent.isBone && (Ih.multiplyMatrices(Fh, r.matrixWorld), Rh.setFromMatrixPosition(Ih), n.setXYZ(t, Rh.x, Rh.y, Rh.z), Ih.multiplyMatrices(Fh, r.parent.matrixWorld), Rh.setFromMatrixPosition(Ih), n.setXYZ(t + 1, Rh.x, Rh.y, Rh.z), t += 2)
                    }
                    r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                }
            }.prototype.update = function () {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, Lo.prototype.extractUrlBase = function (t) {
                return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), ah.extractUrlBase(t)
            }, Lo.Handlers = {
                add: function () {
                    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                },
                get: function () {
                    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                }
            }, Dh.prototype.center = function (t) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, Dh.prototype.empty = function () {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, Dh.prototype.isIntersectionBox = function (t) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, Dh.prototype.size = function (t) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
            }, bt.prototype.center = function (t) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, bt.prototype.empty = function () {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, bt.prototype.isIntersectionBox = function (t) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, bt.prototype.isIntersectionSphere = function (t) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }, bt.prototype.size = function (t) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
            }, Ot.prototype.empty = function () {
                return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, Oi.prototype.setFromMatrix = function (t) {
                return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
            }, ot.prototype.flattenToArrayOffset = function (t, e) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            }, ot.prototype.multiplyVector3 = function (t) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
            }, ot.prototype.multiplyVector3Array = function () {
                console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
            }, ot.prototype.applyToBufferAttribute = function (t) {
                return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
            }, ot.prototype.applyToVector3Array = function () {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }, ot.prototype.getInverse = function (t) {
                return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
            }, Jt.prototype.extractPosition = function (t) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
            }, Jt.prototype.flattenToArrayOffset = function (t, e) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            }, Jt.prototype.getPosition = function () {
                return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new vt).setFromMatrixColumn(this, 3)
            }, Jt.prototype.setRotationFromQuaternion = function (q) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(q)
            }, Jt.prototype.multiplyToArray = function () {
                console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
            }, Jt.prototype.multiplyVector3 = function (t) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, Jt.prototype.multiplyVector4 = function (t) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, Jt.prototype.multiplyVector3Array = function () {
                console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
            }, Jt.prototype.rotateAxis = function (t) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
            }, Jt.prototype.crossVector = function (t) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, Jt.prototype.translate = function () {
                console.error("THREE.Matrix4: .translate() has been removed.")
            }, Jt.prototype.rotateX = function () {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            }, Jt.prototype.rotateY = function () {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            }, Jt.prototype.rotateZ = function () {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            }, Jt.prototype.rotateByAxis = function () {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            }, Jt.prototype.applyToBufferAttribute = function (t) {
                return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, Jt.prototype.applyToVector3Array = function () {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            }, Jt.prototype.makeFrustum = function (t, e, r, n, o, h) {
                return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, r, o, h)
            }, Jt.prototype.getInverse = function (t) {
                return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
            }, Bi.prototype.isIntersectionLine = function (line) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(line)
            }, yt.prototype.multiplyVector3 = function (t) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
            }, yt.prototype.inverse = function () {
                return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
            }, Yt.prototype.isIntersectionBox = function (t) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, Yt.prototype.isIntersectionPlane = function (t) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
            }, Yt.prototype.isIntersectionSphere = function (t) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }, De.prototype.area = function () {
                return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
            }, De.prototype.barycoordFromPoint = function (t, e) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
            }, De.prototype.midpoint = function (t) {
                return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
            }, De.prototypenormal = function (t) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
            }, De.prototype.plane = function (t) {
                return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
            }, De.barycoordFromPoint = function (t, a, b, e, r) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), De.getBarycoord(t, a, b, e, r)
            }, De.normal = function (a, b, t, e) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), De.getNormal(a, b, t, e)
            }, zo.prototype.extractAllPoints = function (t) {
                return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
            }, zo.prototype.extrude = function (t) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Qa(this, t)
            }, zo.prototype.makeGeometry = function (t) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new to(this, t)
            }, at.prototype.fromAttribute = function (t, e, r) {
                return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, r)
            }, at.prototype.distanceToManhattan = function (t) {
                return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            }, at.prototype.lengthManhattan = function () {
                return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, vt.prototype.setEulerFromRotationMatrix = function () {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            }, vt.prototype.setEulerFromQuaternion = function () {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            }, vt.prototype.getPositionFromMatrix = function (t) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
            }, vt.prototype.getScaleFromMatrix = function (t) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
            }, vt.prototype.getColumnFromMatrix = function (t, e) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
            }, vt.prototype.applyProjection = function (t) {
                return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
            }, vt.prototype.fromAttribute = function (t, e, r) {
                return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, r)
            }, vt.prototype.distanceToManhattan = function (t) {
                return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            }, vt.prototype.lengthManhattan = function () {
                return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, mt.prototype.fromAttribute = function (t, e, r) {
                return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, r)
            }, mt.prototype.lengthManhattan = function () {
                return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, _e.prototype.getChildByName = function (t) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
            }, _e.prototype.renderDepth = function () {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            }, _e.prototype.translate = function (t, e) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
            }, _e.prototype.getWorldRotation = function () {
                console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
            }, _e.prototype.applyMatrix = function (t) {
                return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
            }, Object.defineProperties(_e.prototype, {
                eulerOrder: {
                    get: function () {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function (t) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function () {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function () {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), bi.prototype.setDrawMode = function () {
                console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }, Object.defineProperties(bi.prototype, {
                drawMode: {
                    get: function () {
                        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                    },
                    set: function () {
                        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                    }
                }
            }), Is.prototype.initBones = function () {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, Ci.prototype.setLens = function (t, e) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
            }, Object.defineProperties(Vo.prototype, {
                onlyShadow: {
                    set: function () {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function (t) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function (t) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function (t) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function (t) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function (t) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function (t) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function (t) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function () {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function (t) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function () {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function (t) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function (t) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                    }
                }
            }), Object.defineProperties(We.prototype, {
                length: {
                    get: function () {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                dynamic: {
                    get: function () {
                        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === X
                    },
                    set: function () {
                        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(X)
                    }
                }
            }), We.prototype.setDynamic = function (t) {
                return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? X : j), this
            }, We.prototype.copyIndicesArray = function () {
                console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
            }, We.prototype.setArray = function () {
                console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }, ii.prototype.addIndex = function (t) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
            }, ii.prototype.addAttribute = function (t, e) {
                return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new We(arguments[1], arguments[2])))
            }, ii.prototype.addDrawCall = function (t, e, r) {
                void 0 !== r && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
            }, ii.prototype.clearDrawCalls = function () {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            }, ii.prototype.computeOffsets = function () {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }, ii.prototype.removeAttribute = function (t) {
                return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
            }, ii.prototype.applyMatrix = function (t) {
                return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
            }, Object.defineProperties(ii.prototype, {
                drawcalls: {
                    get: function () {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function () {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), ls.prototype.setDynamic = function (t) {
                return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? X : j), this
            }, ls.prototype.setArray = function () {
                console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }, Qa.prototype.getArrays = function () {
                console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
            }, Qa.prototype.addShapeList = function () {
                console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
            }, Qa.prototype.addShape = function () {
                console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
            }, hs.prototype.dispose = function () {
                console.error("THREE.Scene: .dispose() has been removed.")
            }, Ch.prototype.onUpdate = function () {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }, Object.defineProperties(Ie.prototype, {
                wrapAround: {
                    get: function () {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function () {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function () {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function () {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function () {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new Oe
                    }
                },
                shading: {
                    get: function () {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function (t) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                    }
                },
                stencilMask: {
                    get: function () {
                        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                    },
                    set: function (t) {
                        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
                    }
                }
            }), Object.defineProperties(Ai.prototype, {
                derivatives: {
                    get: function () {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function (t) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                    }
                }
            }), ss.prototype.clearTarget = function (t, e, r, n) {
                console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, r, n)
            }, ss.prototype.animate = function (t) {
                console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
            }, ss.prototype.getCurrentRenderTarget = function () {
                return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
            }, ss.prototype.getMaxAnisotropy = function () {
                return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
            }, ss.prototype.getPrecision = function () {
                return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
            }, ss.prototype.resetGLState = function () {
                return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
            }, ss.prototype.supportsFloatTextures = function () {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            }, ss.prototype.supportsHalfFloatTextures = function () {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            }, ss.prototype.supportsStandardDerivatives = function () {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            }, ss.prototype.supportsCompressedTextureS3TC = function () {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            }, ss.prototype.supportsCompressedTexturePVRTC = function () {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            }, ss.prototype.supportsBlendMinMax = function () {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            }, ss.prototype.supportsVertexTextures = function () {
                return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
            }, ss.prototype.supportsInstancedArrays = function () {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            }, ss.prototype.enableScissorTest = function (t) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
            }, ss.prototype.initMaterial = function () {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            }, ss.prototype.addPrePlugin = function () {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            }, ss.prototype.addPostPlugin = function () {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            }, ss.prototype.updateShadowMap = function () {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            }, ss.prototype.setFaceCulling = function () {
                console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
            }, ss.prototype.allocTextureUnit = function () {
                console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
            }, ss.prototype.setTexture = function () {
                console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
            }, ss.prototype.setTexture2D = function () {
                console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
            }, ss.prototype.setTextureCube = function () {
                console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
            }, ss.prototype.getActiveMipMapLevel = function () {
                return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
            }, Object.defineProperties(ss.prototype, {
                shadowMapEnabled: {
                    get: function () {
                        return this.shadowMap.enabled
                    },
                    set: function (t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                    }
                },
                shadowMapType: {
                    get: function () {
                        return this.shadowMap.type
                    },
                    set: function (t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                    }
                },
                shadowMapCullFace: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                context: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                    }
                },
                vr: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                    }
                },
                gammaInput: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                    }
                },
                gammaOutput: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                    },
                    set: function (t) {
                        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? G : O
                    }
                },
                toneMappingWhitePoint: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                    }
                }
            }), Object.defineProperties(Jn.prototype, {
                cullFace: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(ft.prototype, {
                wrapS: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function (t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                    }
                },
                wrapT: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function (t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                    }
                },
                magFilter: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function (t) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                    }
                },
                minFilter: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function (t) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                    }
                },
                anisotropy: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function (t) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                    }
                },
                offset: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function (t) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                    }
                },
                repeat: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function (t) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                    }
                },
                format: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function (t) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                    }
                },
                type: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function (t) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                    }
                },
                generateMipmaps: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function (t) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                    }
                }
            }), fh.prototype.load = function (t) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                const e = this;
                return (new mh).load(t, (function (t) {
                    e.setBuffer(t)
                })), this
            }, Di.prototype.updateCubeMap = function (t, e) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
            }, Di.prototype.clear = function (t, e, r, n) {
                return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, r, n)
            }, lt.crossOrigin = void 0, lt.loadTexture = function (t, e, r, n) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                const o = new ko;
                o.setCrossOrigin(this.crossOrigin);
                const h = o.load(t, r, void 0, n);
                return e && (h.mapping = e), h
            }, lt.loadTextureCube = function (t, e, r, n) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                const o = new Fo;
                o.setCrossOrigin(this.crossOrigin);
                const h = o.load(t, r, void 0, n);
                return e && (h.mapping = e), h
            }, lt.loadCompressedTexture = function () {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, lt.loadCompressedTextureCube = function () {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: "130"
                }
            })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "130")
        },
        245: function (t, e, r) {
            "use strict";
            r(212);
            var n = r(242),
                o = r.n(n),
                h = {
                    props: {
                        options: {
                            type: Object,
                            required: !0
                        },
                        height: Number,
                        width: Number
                    },
                    data: function () {
                        return {
                            style: {
                                width: this.width ? "".concat(this.width, "px") : "100%",
                                height: this.height ? "".concat(this.height, "px") : "100%",
                                overflow: "hidden",
                                margin: "0 auto"
                            }
                        }
                    },
                    mounted: function () {
                        this.anim = o.a.loadAnimation({
                            container: this.$refs.lavContainer,
                            renderer: "svg",
                            loop: !1 !== this.options.loop,
                            autoplay: !1 !== this.options.autoplay,
                            animationData: this.options.animationData,
                            rendererSettings: this.options.rendererSettings
                        }), this.$emit("animCreated", this.anim)
                    }
                },
                l = r(40),
                component = Object(l.a)(h, (function () {
                    var t = this,
                        e = t.$createElement;
                    return (t._self._c || e)("div", {
                        ref: "lavContainer",
                        style: t.style
                    })
                }), [], !1, null, null, null);
            e.a = component.exports
        }
    }
]);